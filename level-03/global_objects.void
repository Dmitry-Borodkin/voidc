//---------------------------------------------------------------------
//- Copyright (C) 2020-2024 Dmitry Borodkin <borodkin.dn@gmail.com>
//- SDPX-License-Identifier: LGPL-3.0-or-later
//---------------------------------------------------------------------
{   voidc_guard_target("global_objects.void  must be imported into the voidc target only!");

    v_import("level-00");
    v_import("level-01");
    v_import("level-02");

    v_import("llvm-c/Core.void");

    v_import("intrinsics_derive.void");
    v_import("local_objects.void");
    v_import("heap_objects.void");

//  v_import("printf.void");
}

{   v_enable_level_01();
    v_enable_level_02();

    voidc_enable_intrinsics_derive();
    voidc_enable_local_objects();
    voidc_enable_heap_objects();
}


//---------------------------------------------------------------------
qf_export  = voidc_definitions_internal_qf_export;      //- 1 << 0
qf_private = voidc_definitions_internal_qf_private;     //- 1 << 1

//---------------------------------------------------------------------
{   q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("enabled_q", q_ref, q("voidc.internal.global_objects_enabled"));

    v_add_symbol("q_initialize", q_ref, q("v_initialize"));
    v_add_symbol("q_terminate",  q_ref, q("v_terminate"));
    v_add_symbol("q_copy",       q_ref, q("v_copy"));

    v_add_symbol("voidc_compile_type_q", q_ref, q("voidc.compile_type"));

    v_add_symbol("q_export_symbol_type", q_ref, q("v_export_symbol_type"));
    v_add_symbol("q_export_type",        q_ref, q("v_export_type"));
    v_add_symbol("q_export_constant",    q_ref, q("v_export_constant"));
    v_add_symbol("q_add_symbol",         q_ref, q("v_add_symbol"));
    v_add_symbol("q_add_type",           q_ref, q("v_add_type"));
    v_add_symbol("q_add_constant",       q_ref, q("v_add_constant"));

    v_add_symbol("typ_q", q_ref, q("typ"));

    v_add_symbol("LLVMGetNamedGlobal_q", q_ref, q("LLVMGetNamedGlobal"));
    v_add_symbol("LLVMGetInitializer_q", q_ref, q("LLVMGetInitializer"));

    v_add_symbol("unit_var_defn_q",  q_ref, q("unit_var_defn"));
    v_add_symbol("unit_val_defn_q",  q_ref, q("unit_val_defn"));
    v_add_symbol("unit_stmt_init_q", q_ref, q("unit_stmt_init"));
    v_add_symbol("unit_stmt_term_q", q_ref, q("unit_stmt_term"));
    v_add_symbol("defn_list_unit_q", q_ref, q("defn_list_unit"));

    v_add_symbol("mod_const_q", q_ref, q("voidc.constants_module"));

    v_add_symbol("voidc_obtain_special_result_value_q", q_ref, q("voidc.obtain_special_result_value"));

    v_add_symbol("voidc_abstract_static_constant_q", q_ref, q("voidc.abstract_static_constant"));

    v_add_symbol("voidc_abstract_static_type_intrinsic_q", q_ref, q("voidc.abstract_static_type_intrinsic"));
}


//=====================================================================
{   voidc_unit_begin_module("global_objects_module"); }


//---------------------------------------------------------------------
//- v_ast_unit_stmt_t ...
//---------------------------------------------------------------------
export
struct v_ast_unit_stmt_t
{
    body: v_ast_stmt_t;                 //- Statement...
};

//---------------------------------------------------------------------
private
ast_unit_stmt_init: (void_obj: *void) ~> void
{
    obj = *(void_obj: *v_ast_unit_stmt_t);

    v_initialize(&obj.body);
}

//---------------------------------------------------------------------
private
ast_unit_stmt_term: (void_obj: *void) ~> void
{
    obj = *(void_obj: *v_ast_unit_stmt_t);

    v_terminate(&obj.body);
}


//---------------------------------------------------------------------
ast_unit_stmt_init_vtable: &v_ast_generic_vtable :=
{
    ast_unit_stmt_init,
    ast_unit_stmt_term,
};

//---------------------------------------------------------------------
export
v_ast_make_unit_stmt_init: (ret: *v_ast_base_t, body: *v_ast_stmt_t) ~> void
{
    atmp: &v_ast_base_t := {};      atmp = &atmp;

    v_ast_make_generic(atmp, &ast_unit_stmt_init_vtable, v_ast_unit_stmt_t.size);

    void_obj = v_ast_generic_get_object(atmp);

    obj = *(void_obj: *v_ast_unit_stmt_t);

    if (body)  v_copy(&obj.body, body);

    v_copy(ret,  atmp);
}


//---------------------------------------------------------------------
ast_unit_stmt_term_vtable: &v_ast_generic_vtable :=
{
    ast_unit_stmt_init,
    ast_unit_stmt_term,
};

//---------------------------------------------------------------------
export
v_ast_make_unit_stmt_term: (ret: *v_ast_base_t, body: *v_ast_stmt_t) ~> void
{
    atmp: &v_ast_base_t := {};      atmp = &atmp;

    v_ast_make_generic(atmp, &ast_unit_stmt_term_vtable, v_ast_unit_stmt_t.size);

    void_obj = v_ast_generic_get_object(atmp);

    obj = *(void_obj: *v_ast_unit_stmt_t);

    if (body)  v_copy(&obj.body, body);

    v_copy(ret,  atmp);
}


//---------------------------------------------------------------------
//- Grammar actions ...
//---------------------------------------------------------------------
private
mk_unit_stmt_init_grammar_action: (ret: *v_std_any_t, *void, any: *v_std_any_t, size_t) ~> void
{
    body = v_std_any_get_pointer(v_ast_stmt_t, any+0);

    defn: &v_ast_base_t := {};      defn = &defn;

    v_ast_make_unit_stmt_init(defn, body);

    v_std_any_set_pointer(ret, defn);
}

//---------------------------------------------------------------------
private
mk_unit_stmt_term_grammar_action: (ret: *v_std_any_t, *void, any: *v_std_any_t, size_t) ~> void
{
    body = v_std_any_get_pointer(v_ast_stmt_t, any+0);

    defn: &v_ast_base_t := {};      defn = &defn;

    v_ast_make_unit_stmt_term(defn, body);

    v_std_any_set_pointer(ret, defn);
}


//---------------------------------------------------------------------
//- obtain_special_result_value_global_ctx_t ...
//---------------------------------------------------------------------
private
obtain_special_result_value_global_ctx_t = struct
{
    name: *const char;                  //- Global variable name

    init_list: v_util_list_t;           //- List of initializers
    term_list: v_util_list_t;           //- List of terminators
};

//---------------------------------------------------------------------
//- obtain_special_result_value_global ...
//---------------------------------------------------------------------
private
obtain_special_result_value_global: (aux: *void, vis: *voidc_visitor_t, t: *v_type_t) ~> LLVMValueRef
{
    v_assert(v_type_is_special(t, q_initialize));

    ctx = *(aux: *obtain_special_result_value_global_ctx_t);

    raw_name = v_lookup_alias(ctx.name);

    module = v_get_module();

    v_assert(module);

    v: &LLVMValueRef := LLVMGetNamedGlobal(module, raw_name);

    if (!v)     //- WTF ???
    {
        t_ = v_type_get_llvm_type(t);

        v := LLVMAddGlobal(module, t_, raw_name);

        LLVMSetInitializer(v, LLVMGetUndef(t_));
    }

    //--------------------------------------------------------------
    stmt: &v_ast_stmt_t := {};

    voidc_make_special_intrinsic_call(&stmt, q_initialize, t, v, 0);

    v_ast_accept_visitor((&stmt: *v_ast_base_t), vis);

    //--------------------------------------------------------------
    v_return(v);
}

//---------------------------------------------------------------------
//- voidc_obtain_special_result_value ...
//---------------------------------------------------------------------
private
my_obtain_special_result_value_ctx_t = struct
{
    global_flag: bool;
    global_ctx:  obtain_special_result_value_global_ctx_t;

    fun: *((*void, vis: *voidc_visitor_t, t: *v_type_t) ~> LLVMValueRef);
    aux: *void;
};

//---------------------------------------------------------------------
private
my_obtain_special_result_value_helper: (aux: *void, vis: *voidc_visitor_t, t: *v_type_t) ~> LLVMValueRef
{
    v_assert(v_type_is_special(t, q_initialize));

    ctx = *(aux: *my_obtain_special_result_value_ctx_t);

//  ttag = v_get_result_type();
    vtag = v_get_result_value();

    switch((vtag: intptr_t))
    {
    case -2:        //- GLOBAL_VTAG

        ctx.global_flag := true;

        v_return(obtain_special_result_value_global(&ctx.global_ctx, vis, t));

    default:

        v_return(ctx.fun(ctx.aux, vis, t));
    }
}


//---------------------------------------------------------------------
//- prepare_initterm_function - utility
//---------------------------------------------------------------------
private
prepare_initterm_function: (name: *const char) ~> void
{
    ft  = v_function_type(v_void_type(), 0, 0, false);
    ft_ = v_type_get_llvm_type(ft);

    f = LLVMAddFunction(v_get_module(), name, ft_);

    sz: &size_t := v_undef();

    uname = LLVMGetValueName2(f, &sz);          //- Get unique name...

    f = v_prepare_function(uname, ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);
}

//---------------------------------------------------------------------
//- finish_initterm_function - utility
//---------------------------------------------------------------------
private
finish_initterm_function: (list: &v_util_list_t, is_init: bool) ~> void
{
    builder = v_target_get_builder();

    bb = LLVMGetInsertBlock(builder);

    fv = LLVMGetBasicBlockParent(bb);

    is_empty = LLVMCountBasicBlocks(fv) <= 2  &&  !LLVMGetFirstInstruction(LLVMGetEntryBasicBlock(fv));

    if (is_init  &&  is_empty)  v_hold_compilation_state(1);        //- WTF ?!?!?

    v_finish_function();

    if (is_empty)
    {
        //- Remove empty initializer/terminator

        LLVMDeleteFunction(fv);
    }
    else
    {
        any: &v_std_any_t := {};

        v_std_any_set_value(&any, (fv: intptr_t));

        v_list_append(&list, &list, &any);
    }
}

//---------------------------------------------------------------------
//- prepare_initializer_function - utility
//---------------------------------------------------------------------
private
prepare_initializer_function: () ~> void
{
    prepare_initterm_function("v.internal_global_initializer");
}

//---------------------------------------------------------------------
//- finish_initializer_function - utility
//---------------------------------------------------------------------
private
finish_initializer_function: (ctx: &obtain_special_result_value_global_ctx_t) ~> void
{
    finish_initterm_function(ctx.init_list, true);
}

//---------------------------------------------------------------------
//- generate_terminator_function - utility
//---------------------------------------------------------------------
private
generate_terminator_function: (body: &v_ast_stmt_t, ctx: &obtain_special_result_value_global_ctx_t, vis: *voidc_visitor_t) ~> void
{
    prepare_initterm_function("v.internal_global_terminator");

    v_ast_accept_visitor((&body: *v_ast_base_t), vis);

    finish_initterm_function(ctx.term_list, false);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
private
my_abstract_static_type_intrinsic: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t,
                                    t: *v_type_t, v: LLVMValueRef,
                                    name: *const char, export: bool
                                   ) ~> void
{
//printf("my_abstract_static_type_intrinsic start %s\n", name);
//defer printf("my_abstract_static_type_intrinsic stop\n");

    v_assert(t == v_find_type("v_static_type_t"));

    if (export) v_export_type(name, (v: *v_type_t));
    else        v_add_type(name, (v: *v_type_t));

    //-------------------------------------------------------------
    stmt_list = voidc_definitions_context_get_stmt_list();
    if (!stmt_list)  v_return();

    expr: &v_ast_expr_t[2] := {};

    stmt: &v_ast_stmt_t := {};

    v_ast_make_expr_integer(&expr[0], (v: intptr_t));               //- Sic!!!

    v_ast_make_stmt_call(&stmt, typ_q, voidc_compile_type_q, &expr[0], 1);

    v_list_append(stmt_list, stmt_list, &stmt);

    v_ast_make_expr_identifier_q(&expr[1], typ_q);

    v_ast_make_expr_string(&expr[0], name);

    if (export) v_ast_make_stmt_call(&stmt, 0, q_export_type, expr, 2);
    else        v_ast_make_stmt_call(&stmt, 0, q_add_type,    expr, 2);

    v_list_append(stmt_list, stmt_list, &stmt);
}


//---------------------------------------------------------------------
//- my_compile_unit_var_defn - visitor method
//---------------------------------------------------------------------
private
my_compile_unit_var_defn: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
//printf("my_compile_unit_var_defn start\n");
//defer printf("my_compile_unit_var_defn finish\n");

    ctx = *(aux: *my_obtain_special_result_value_ctx_t);

    //-------------------------------------------------------------
    list = (self: *v_ast_generic_list_t);

    ast0 = v_list_get_item(list, 0);
    ast1 = v_list_get_item(list, 1);

    //-------------------------------------------------------------
    hidden_flag = v_get_hidden_flag();
    export_flag = v_get_export_flag();

    stmt_list = voidc_definitions_context_get_stmt_list();

    //-------------------------------------------------------------
    qualif = v_ast_expr_integer_get_number((ast0: *v_ast_expr_t));

    private = qualif & qf_private;
    export  = (export_flag  ||  qualif & qf_export)  &&  !private  &&  !hidden_flag;

    name = v_ast_expr_identifier_get_name((ast1: *v_ast_expr_t));

    type  = v_list_get_item(list, 2);
    value = v_list_get_item(list, 3);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(type, vis);

    var_type: &*v_type_t := (v_get_result_value() : *v_type_t);
    sym_type: &*v_type_t := var_type;

    if (v_empty(value))                 //- Declaration
    block
    {
        v_assert(v_type_get_llvm_type(var_type));

        if (v_type_is_reference(var_type))  v_break();
        if (v_type_is_function(var_type))   v_break();

        //- ... ? ...

        if (export) v_export_constant(name, var_type, 0);       //- Sic!
        else        v_add_constant(name, var_type, 0);          //- Sic!

        sym_type := v_reference_type(var_type, 0);              //- HACK!
    }
    else        //- !v_empty(value)     //- Definition
    {
        v_assert(v_type_is_reference(var_type));

        v_assert(v_get_module() == 0);

        v_set_module(v_obtain_module());

        t = v_type_refptr_get_element_type(var_type);       //- Sic!
        a = v_type_refptr_get_address_space(var_type);      //- Sic!

        v_set_result_type(t);
        v_set_result_value(GLOBAL_VTAG);

        ctx.global_flag := false;

        ctx.global_ctx.name := v_obtain_alias(name, export);    //- ?

        prepare_initializer_function();

        v_push_temporaries();

        v_ast_accept_visitor(value, vis);

        t = v_get_result_type();

        sym_type := var_type := v_reference_type(t, a);
    }

    if (export) v_export_symbol_type(name, sym_type);
    else        v_add_symbol(name, sym_type, 0);

    if (!v_empty(value))                //- Definition
    {
        t = v_get_result_type();
        v = v_get_result_value();

        flag: &bool := true;

        if (v_type_is_special(t, q_initialize))
        block
        {
            if (LLVMIsUndef(v)) v_break();

            if (v == LLVMConstNull(v_type_get_llvm_type(t)))  v_break();

            if (!ctx.global_flag)
            {
               vv = obtain_special_result_value_global(&ctx.global_ctx, vis, t);        //- Sic!!!

               stmt: &v_ast_stmt_t := {};

               voidc_make_special_intrinsic_call(&stmt, q_copy, t, vv, v);              //- Sic!

               v_ast_accept_visitor((&stmt: *v_ast_base_t), vis);
            }

            flag := false;
        }

        value_g: &LLVMValueRef := v_undef();

        v_obtain_identifier(name, 0, &value_g);         //- Sic!

        if (private)  LLVMSetLinkage(value_g, LLVMPrivateLinkage);

        if (flag)
        {
            if (LLVMIsConstant(v))
            {
                LLVMSetInitializer(value_g, v);
            }
            else
            {
                LLVMSetInitializer(value_g, LLVMGetUndef(v_type_get_llvm_type(t)));

                builder = v_target_get_builder();

                LLVMBuildStore(builder, v, value_g);
            }
        }

        v_pop_temporaries();

        finish_initializer_function(ctx.global_ctx);

        if (export) v_export_symbol_type(name, sym_type);           //- WTF ???
        else        v_add_symbol(name, sym_type, 0);                //- WTF ???

        if (!flag  &&  v_type_is_special(t, q_terminate))
        {
            stmt: &v_ast_stmt_t := {};

            voidc_make_special_intrinsic_call(&stmt, q_terminate, t, value_g, 0);

            generate_terminator_function(stmt, ctx.global_ctx, vis);
        }

        v_set_module(0);
    }


    //-------------------------------------------------------------
    if (private  ||  !stmt_list)  v_return();


    expr: &v_ast_expr_t[3] := {};

    elst: &v_ast_expr_list_t := {};

    stmt: &v_ast_stmt_t := {};


    v_ast_make_expr_integer(&expr[0], (var_type: intptr_t));        //- Sic!!!

    v_make_list(&elst, &expr[0], 1);

    v_ast_make_expr_identifier_q(&expr[0], voidc_compile_type_q);

    v_ast_make_expr_call(&expr[1], &expr[0], &elst);

    v_ast_make_expr_string(&expr[0], name);


    v_ast_make_expr_integer(&expr[2], 0);

    if (v_empty(value))
    block
    {
        if (v_type_is_reference(var_type))  v_break();
        if (v_type_is_function(var_type))   v_break();

        //- ... ? ...

        if (export) v_ast_make_stmt_call(&stmt, 0, q_export_constant, expr, 3);
        else        v_ast_make_stmt_call(&stmt, 0, q_add_constant, expr, 3);

        v_list_append(stmt_list, stmt_list, &stmt);
    }

    if (sym_type != var_type)
    {
        v_ast_make_expr_integer(&expr[1], (sym_type: intptr_t));        //- Sic!!!

        v_make_list(&elst, &expr[1], 1);

        v_ast_make_expr_identifier_q(&expr[1], voidc_compile_type_q);

        v_ast_make_expr_call(&expr[1], &expr[1], &elst);
    }

    if (export) v_ast_make_stmt_call(&stmt, 0, q_export_symbol_type, expr, 2);
    else        v_ast_make_stmt_call(&stmt, 0, q_add_symbol, expr, 3);

    v_list_append(stmt_list, stmt_list, &stmt);
}


//---------------------------------------------------------------------
//- my_compile_unit_val_defn - visitor method
//---------------------------------------------------------------------
private
check_parent: (v: LLVMValueRef) ~> bool
{
    if (gv = LLVMIsAGlobalValue(v))
    {
        if (LLVMGetGlobalParent(gv))  v_return(true);
    }

    for (n = LLVMGetNumOperands(v), i: &int := 0; i < n; ++i)
    {
        if (check_parent(LLVMGetOperand(v, i)))  v_return(true);
    }

    v_return(false);
}

//---------------------------------------------------------------------
private
my_compile_unit_val_defn: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
//printf("my_compile_unit_val_defn start\n");
//defer printf("my_compile_unit_val_defn finish\n");

    ctx = *(aux: *my_obtain_special_result_value_ctx_t);

    //-------------------------------------------------------------
    list = (self: *v_ast_generic_list_t);

    ast0 = v_list_get_item(list, 0);
    ast1 = v_list_get_item(list, 1);

    //-------------------------------------------------------------
    hidden_flag = v_get_hidden_flag();
    export_flag = v_get_export_flag();

    stmt_list = voidc_definitions_context_get_stmt_list();
    mod_const = voidc_definitions_context_get_mod_const();

    //-------------------------------------------------------------
    qualif = v_ast_expr_integer_get_number((ast0: *v_ast_expr_t));

    private = qualif & qf_private;
    export  = (export_flag  ||  qualif & qf_export)  &&  !private  &&  !hidden_flag;

    name = v_ast_expr_identifier_get_name((ast1: *v_ast_expr_t));

    type  = v_list_get_item(list, 2);
    value = v_list_get_item(list, 3);

    v_set_result_type(INVIOLABLE_TAG);

    if (!v_empty(type))
    {
        v_set_result_value(0);

        v_ast_accept_visitor(type, vis);

        v_set_result_type((v_get_result_value() : *v_type_t));
    }

    v_assert(v_get_module() == 0);

    v_set_module(v_obtain_module());

    v_set_result_value(GLOBAL_VTAG);

    ctx.global_flag := false;

    ctx.global_ctx.name := name;

    prepare_initializer_function();

    v_push_temporaries();

    v_ast_accept_visitor(value, vis);

    t = v_get_result_type();
    v = v_get_result_value();

    block
    {
        void_aux: &*void := v_undef();

        q = voidc_abstract_static_constant_q;

        fun = v_util_lookup_overload(q, t, &void_aux);
        if (!fun) v_break();

        v_pop_temporaries();

        finish_initializer_function(ctx.global_ctx);

        v_set_module(0);

        intrinsic_ft = (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t,
                        t: *v_type_t, v: LLVMValueRef,
                        name: *const char, export: bool
                       ) ~> void;

        (fun: *intrinsic_ft)(void_aux, vis, self, t, v, name, export);

        v_return();
    }

    is_constant = LLVMIsConstant(v);

    is_strict_constant = (is_constant  &&  !check_parent(v));       //- Must be parentless!

    if (is_strict_constant)
    {
        v_pop_temporaries();

        finish_initializer_function(ctx.global_ctx);

        if (export) v_export_constant(name, t, v);
        else        v_add_constant(name, t, v);
    }
    else    //- Instruction or "weak" constant...
    {
        if (export) v_export_constant(name, t, 0);          //- Sic!
        else        v_add_constant(name, t, 0);             //- Sic!

        {   tt = v_reference_type(t, 0);                    //- HACK!

            if (export) v_export_symbol_type(name, tt);
            else        v_add_symbol(name, tt, 0);
        }

        flag: &bool := true;

        if (v_type_is_special(t, q_initialize))
        {
            if (!ctx.global_flag)
            {
               vv = obtain_special_result_value_global(&ctx.global_ctx, vis, t);        //- Sic!!!

               stmt: &v_ast_stmt_t := {};

               voidc_make_special_intrinsic_call(&stmt, q_copy, t, vv, v);              //- Sic!

               v_ast_accept_visitor((&stmt: *v_ast_base_t), vis);
            }

            flag := false;
        }

        value_g: &LLVMValueRef := v_undef();

        v_obtain_identifier(name, 0, &value_g);         //- Sic!

        if (private)  LLVMSetLinkage(value_g, LLVMPrivateLinkage);

        if (flag)
        {
            if (is_constant)    //- "Weak" constant
            {
                LLVMSetInitializer(value_g, v);

                LLVMSetGlobalConstant(value_g, true);
            }
            else                //- Instruction
            {
                LLVMSetInitializer(value_g, LLVMGetUndef(v_type_get_llvm_type(t)));

                builder = v_target_get_builder();

                LLVMBuildStore(builder, v, value_g);

                //- TODO: How to make it "constant" ?!?!?!?!?
            }
        }

        v_pop_temporaries();

        finish_initializer_function(ctx.global_ctx);

        if (export) v_export_constant(name, t, 0);          //- Sic!        //- WTF ???
        else        v_add_constant(name, t, 0);             //- Sic!        //- WTF ???
                                                                            //- WTF ???
        {   tt = v_reference_type(t, 0);                    //- HACK!       //- WTF ???
                                                                            //- WTF ???
            if (export) v_export_symbol_type(name, tt);                     //- WTF ???
            else        v_add_symbol(name, tt, 0);                          //- WTF ???
        }                                                                   //- WTF ???

        if (!flag  &&  v_type_is_special(t, q_terminate))
        {
            stmt: &v_ast_stmt_t := {};

            voidc_make_special_intrinsic_call(&stmt, q_terminate, t, value_g, 0);

            generate_terminator_function(stmt, ctx.global_ctx, vis);
        }
    }

    v_set_module(0);


    //-------------------------------------------------------------
    if (private  ||  !stmt_list)  v_return();


    expr: &v_ast_expr_t[3] := {};

    elst: &v_ast_expr_list_t := {};

    stmt: &v_ast_stmt_t := {};


    v_ast_make_expr_integer(&expr[0], (t: intptr_t));               //- Sic!!!

    v_ast_make_stmt_call(&stmt, typ_q, voidc_compile_type_q, &expr[0], 1);

    v_list_append(stmt_list, stmt_list, &stmt);

    v_ast_make_expr_identifier_q(&expr[1], typ_q);

    v_ast_make_expr_string(&expr[0], name);


    if (is_strict_constant)
    {
        t_ = v_type_get_llvm_type(t);

        if (!mod_const)
        {
            c_ = LLVMGetTypeContext(t_);

            mod_const := LLVMModuleCreateWithNameInContext("voidc_module_for_constants", c_);
        }

        v_ = LLVMAddGlobal(mod_const, t_, name);

        LLVMSetInitializer(v_, v);


        v_ast_make_expr_identifier_q(&expr[2], mod_const_q);

        v_make_list(&elst, &expr[2], 1);

        v_list_append(&elst, &elst, &expr[0], 1);           //- Sic!

        v_ast_make_expr_identifier_q(&expr[2], LLVMGetNamedGlobal_q);

        v_ast_make_expr_call(&expr[2], &expr[2], &elst);

        v_make_list(&elst, &expr[2], 1);

        v_ast_make_expr_identifier_q(&expr[2], LLVMGetInitializer_q);

        v_ast_make_expr_call(&expr[2], &expr[2], &elst);
    }


    if (is_strict_constant)
    {
        if (export) v_ast_make_stmt_call(&stmt, 0, q_export_constant, expr, 3);
        else        v_ast_make_stmt_call(&stmt, 0, q_add_constant,    expr, 3);
    }
    else    //- Instruction or "weak" constant...
    {
        v_ast_make_expr_integer(&expr[2], 0);

        if (export) v_ast_make_stmt_call(&stmt, 0, q_export_constant, expr, 3);         //- Sic!
        else        v_ast_make_stmt_call(&stmt, 0, q_add_constant,    expr, 3);         //- Sic!

        v_ast_make_expr_integer(&expr[1], (v_reference_type(t, 0) : intptr_t));         //- HACK!

        v_ast_make_stmt_call(&stmt, typ_q, voidc_compile_type_q, &expr[1], 1);

        v_list_append(stmt_list, stmt_list, &stmt);

        v_ast_make_expr_identifier_q(&expr[1], typ_q);

        if (export) v_ast_make_stmt_call(&stmt, 0, q_export_symbol_type, expr, 2);
        else        v_ast_make_stmt_call(&stmt, 0, q_add_symbol,         expr, 3);
    }

    v_list_append(stmt_list, stmt_list, &stmt);
}


//---------------------------------------------------------------------
private
compile_unit_stmt_init: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
//printf("compile_unit_stmt_init start\n");
//defer printf("compile_unit_stmt_init finish\n");

    ctx = *(aux: *obtain_special_result_value_global_ctx_t);

    //-------------------------------------------------------------
    void_obj = v_ast_generic_get_object(self);

    obj = *(void_obj: *v_ast_unit_stmt_t);

    if (v_empty(&obj.body))   v_return();

    //-------------------------------------------------------------
    module = v_get_module();

    if (!module)  v_set_module(v_obtain_module());

    //-------------------------------------------------------------
    prepare_initializer_function();

    v_ast_accept_visitor((&obj.body: *v_ast_base_t), vis);      //- Sic!

    finish_initializer_function(ctx);

    //-------------------------------------------------------------
    if (!module)  v_set_module(0);
}


//---------------------------------------------------------------------
private
compile_unit_stmt_term: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
//printf("compile_unit_stmt_term start\n");
//defer printf("compile_unit_stmt_term finish\n");

    ctx = *(aux: *obtain_special_result_value_global_ctx_t);

    //-------------------------------------------------------------
    void_obj = v_ast_generic_get_object(self);

    obj = *(void_obj: *v_ast_unit_stmt_t);

    if (v_empty(&obj.body))   v_return();

    //-------------------------------------------------------------
    module = v_get_module();

    if (!module)  v_set_module(v_obtain_module());

    //-------------------------------------------------------------
    generate_terminator_function(obj.body, ctx, vis);

    //-------------------------------------------------------------
    if (!module)  v_set_module(0);
}


//---------------------------------------------------------------------
//- my_compile_expr_identifier - visitor method
//---------------------------------------------------------------------
private
my_compile_expr_identifier: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ident = (self: *v_ast_expr_t);

    qname = v_ast_expr_identifier_get_name_q(ident);

    t: &*v_type_t    := 0;
    v: &LLVMValueRef := 0;

    if (!v_obtain_identifier_q(qname, &t, &v))
    {
        struct FILE;

        fprintf: (*FILE, *const char, ...) ~> int;

        stderr: &*FILE;

        fprintf(stderr, "Identifier not found: %s\n", v_quark_to_string(qname));

        abort: () ~> void;

        abort();            //- Sic!!!
    }

    gctx = v_target_get_global_ctx();
    vctx = v_target_get_voidc_global_ctx();

    if (gctx == vctx)
    {
        ttag = v_get_result_type();

        if (t == v_static_type_t  &&  ttag == v_type_ptr)
        {
            raw_qname = v_lookup_alias_q(qname);

            cname = v_quark_to_string(raw_qname);

            module: &LLVMModuleRef := v_get_module();

            if (!module)
            {
                module := v_obtain_module();

                v_set_module(module);       v_assert(module);
            }

            v := LLVMGetNamedGlobal(module, cname);

            if (!v) v := LLVMAddGlobal(module, v_type_get_llvm_type(v_type_t), cname);

            v_adopt_result(ttag, v);        //- Sic!

            v_return();
        }
    }

    block
    {
        if (v_get_variable_q(qname, 0, 0))  v_break();

        {   u: &LLVMValueRef := 0;

            if (!v_find_constant_q(qname, 0, &u)) v_break();

            if (u)  v_break();
        }

        v_assert(v_type_is_reference(t));           //- HACK!

        t := v_type_refptr_get_element_type(t);     //- Sic!!!

        if (v_type_is_special(t, q_initialize)) v_break();

        builder = v_target_get_builder();

        v := LLVMBuildLoad2(builder, v_type_get_llvm_type(t), v, v_quark_to_string(qname));
    }

    v_adopt_result(t, v);
}


//---------------------------------------------------------------------
//- my_compile_defn_list_unit - visitor method
//---------------------------------------------------------------------
private
my_compile_defn_list_unit_ctx_t = struct
{
    obtain_spec: my_obtain_special_result_value_ctx_t;

    fun: *voidc_visitor_method_t;
    aux: *void;
};

//---------------------------------------------------------------------
private global_module_number: &unsigned := 0;           //- Sic!!!

//---------------------------------------------------------------------
private
my_compile_defn_list_unit: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    if (visitor = v_get_compiler(), visitor != vis)
    {
        v_assert(v_target_get_global_ctx() != v_target_get_voidc_global_ctx());

        v_ast_accept_visitor(self, visitor);            //- Sic!!!

        v_return();
    }

    //-------------------------------------------------------------
    ctx = *(aux: *my_compile_defn_list_unit_ctx_t);

    saved_module = v_get_module();

    module: &LLVMModuleRef := saved_module;

    global_ctx = ctx.obtain_spec.global_ctx;

    if (!saved_module)                  //- "direct declarations"
    {
        v_assert(!LLVMGetInsertBlock(v_target_get_builder()));

        //- voidc_guard_target(...);

        sstr: &v_std_string_t := {};

        v_std_string_set(&sstr, "voidc_global_objects_module_");

        v_std_string_append_number(&sstr, global_module_number++);

        module := LLVMModuleCreateWithName(v_std_string_get(&sstr));

        filename = v_target_local_ctx_get_filename(v_target_get_voidc_local_ctx());

        strlen: (*const char) ~> size_t;

        LLVMSetSourceFileName(module, filename, strlen(filename));

        v_set_module(module);
    }


    //--------------------------
    ctx.fun(ctx.aux, vis, self);
    //--------------------------


    if (!saved_module)                  //- "direct declarations"
    {
        //- voidc_guard_target(...);

        v_finish_module(module);

        //- TODO: Check for empty module!

        voidc_prepare_module_for_jit(module);

        voidc_add_local_module_to_jit(module);              //- local?  (TODO)

        LLVMDisposeModule(module);

        v_set_module(0);
    }
}


//---------------------------------------------------------------------
//- Generate/update global ctors/dtors tables...
//---------------------------------------------------------------------
private
my_finish_module_globals_ctx_t = struct
{
    global_ctx: *obtain_special_result_value_global_ctx_t;

    fun: *((*void, LLVMModuleRef) ~> void);
    ctx: *void;
};

//---------------------------------------------------------------------
private
cdtors: &(*const char)[2] :=
{
    "llvm.global_ctors",
    "llvm.global_dtors"
};

//---------------------------------------------------------------------
private
my_finish_module_globals: (void_ctx: *void, module: LLVMModuleRef) ~> void
{
    ctx = *(void_ctx: *my_finish_module_globals_ctx_t);

    global_ctx = *ctx.global_ctx;

    //--------------------------------------------------------------
    lists: &(*v_util_list_t)[2] := {&global_ctx.init_list, &global_ctx.term_list };

    for (i: &int := 0; i < 2; ++i)
    {
        list = lists[i];

        if (!v_list_get_size(list)) v_continue();

        any = v_list_get_item(list, 0);

        fv = (v_std_any_get_value(intptr_t, any) : LLVMValueRef);

        mod = LLVMGetGlobalParent(fv);

        if (mod == module)  v_continue();

        if (ctx.fun)  ctx.fun(ctx.ctx, module);

        v_return();
    }

    //--------------------------------------------------------------
    void_type = v_void_type();

    int32_t  = v_int_type(32);
    void_ptr = v_pointer_type(void_type, 0);

    typ: &(*v_type_t)[3] :=
    {
        int32_t,
        v_pointer_type(v_function_type(void_type, 0, 0, false), 0),
        void_ptr,
    };

    elt_t = v_struct_type(typ, 3, false);

    elt_t_ = v_type_get_llvm_type(elt_t);

    int32_t_  = v_type_get_llvm_type(int32_t);
    void_ptr_ = v_type_get_llvm_type(void_ptr);

    val: &LLVMValueRef[3] :=
    {
        LLVMConstInt(int32_t_, 101, 0),
        v_undef(),
        LLVMConstNull(void_ptr_),
    };

    //--------------------------------------------------------------
    for (i: &int := 0; i < 2; ++i)
    {
        list = lists[i];

        if (list_size = v_list_get_size(list))
        {
            list_size = (list_size: unsigned);

            N: &unsigned := list_size;

            cdname = cdtors[i];

            ev: &*LLVMValueRef := v_undef();

            if (cdt = LLVMGetNamedGlobal(module, cdname))
            {
                cdt0 = LLVMGetOperand(cdt, 0);

                n = LLVMGetNumOperands(cdt0);

                N += n;

                ev := new LLVMValueRef[N];

                for (j: &int := 0; j < n; ++j)
                {
                    ev[j] := LLVMGetOperand(cdt0, j);
                }

                LLVMDeleteGlobal(cdt);
            }
            else
            {
                ev := new LLVMValueRef[list_size];
            }

            if (i == 0)     //- initializers?
            {
                ev = ev + (N - list_size);

                for (j: &int := 0; j < list_size; ++j)
                {
                    any = v_list_get_item(list, j);

                    val[1] := (v_std_any_get_value(intptr_t, any) : LLVMValueRef);

                    elt_v = LLVMConstStruct(val, 3, 0);

                    ev[j] := elt_v;
                }
            }
            else            //- terminators
            {
                ev = ev + (N - 1);

                for (j: &int := list_size-1; j >= 0; --j)
                {
                    any = v_list_get_item(list, j);

                    val[1] := (v_std_any_get_value(intptr_t, any) : LLVMValueRef);

                    elt_v = LLVMConstStruct(val, 3, 0);

                    ev[-j] := elt_v;
                }
            }

            tab_t  = v_array_type(elt_t, N);
            tab_t_ = v_type_get_llvm_type(tab_t);

            tab_v = LLVMConstArray(elt_t_, ev, N);

            cdtors_g = LLVMAddGlobal(module, tab_t_, cdname);

            LLVMSetLinkage(cdtors_g, LLVMAppendingLinkage);

            LLVMSetInitializer(cdtors_g, tab_v);

            delete[] ev;

            v_make_list_nil(list);
        }
    }

    //--------------------------------------------------------------
    global_ctx.name := 0;

    //--------------------------------------------------------------
    if (ctx.fun)  ctx.fun(ctx.ctx, module);
}


//---------------------------------------------------------------------
//- Transform global ctors/dtors tables for voidc's JIT...
//---------------------------------------------------------------------
private
struct voidc_finish_module_cdtors_ctx_t
{
    fun: *((*void, LLVMModuleRef) ~> void);
    ctx: *void;
};

//---------------------------------------------------------------------
private
item_t = struct
{
    pri: int;               //- priority
    num: int;               //- number

    fun: LLVMValueRef;      //- function
};

private
qsort: (ptr: *void, count: size_t, size: size_t, comp: *((*const void, *const void) ~> int)) ~> void;

private
compare: (void_lhs: *const void, void_rhs: *const void) ~> int
{
    lhs = *(void_lhs: *const item_t);
    rhs = *(void_rhs: *const item_t);

    if (lhs.pri == rhs.pri) v_return(lhs.num - rhs.num);
    else                    v_return(lhs.pri - rhs.pri);
}

//---------------------------------------------------------------------
private
prefs: &(*const char)[2] :=
{
    "voidc.init_func.",
    "voidc.term_func.",
};

//---------------------------------------------------------------------
private
voidc_finish_module_cdtors: (void_ctx: *void, module: LLVMModuleRef) ~> void
{
    llvm_ctx = v_target_get_llvm_ctx();

    builder = v_target_get_builder();

    for (i: &int := 0; i < 2; ++i)
    {
        cdt = LLVMGetNamedGlobal(module, cdtors[i]);

        if (!cdt) v_continue();

        cdt0 = LLVMGetOperand(cdt, 0);

        n = LLVMGetNumOperands(cdt0);

        tab = new item_t[n];
        defer delete[] tab;

        for (j: &int := 0; j < n; ++j)
        {
            it = LLVMGetOperand(cdt0, j);

            pri = (LLVMConstIntGetZExtValue(LLVMGetOperand(it, 0)) : int);

            tab_j = tab[j];

            if (i == 0) tab_j.pri :=  pri;
            else        tab_j.pri := -pri;

            tab_j.num := j;
            tab_j.fun := LLVMGetOperand(it, 1);
        }

        qsort(tab, n, item_t.size, compare);

        sstr: &v_std_string_t := {};    sstr = &sstr;

        v_std_string_set(sstr, prefs[i]);

        len: &size_t := v_undef();

        v_std_string_append(sstr, LLVMGetModuleIdentifier(module, &len));

        fun_name = v_std_string_get(sstr);

        ft = v_type_get_llvm_type(v_function_type(v_void_type(), 0, 0, false));
        fv = LLVMAddFunction(module, fun_name, ft);

        LLVMSetVisibility(fv, LLVMHiddenVisibility);        //- ?

        entry = LLVMAppendBasicBlockInContext(llvm_ctx, fv, "entry");

        LLVMPositionBuilderAtEnd(builder, entry);

        for (j: &int := 0; j < n; ++j)
        {
            LLVMBuildCall2(builder, ft, tab[j].fun, 0, 0, "");          //- ft "reuse" - Sic!
        }

        LLVMBuildRetVoid(builder);

        LLVMDeleteGlobal(cdt);
    }

    ctx = *(void_ctx: *voidc_finish_module_cdtors_ctx_t);

    if (ctx.fun)  ctx.fun(ctx.ctx, module);
}


//=====================================================================
private
struct v_global_objects_ctx_t
{
    unit:        my_compile_defn_list_unit_ctx_t;
    fin_globals: my_finish_module_globals_ctx_t;
    fin_cdtors:  voidc_finish_module_cdtors_ctx_t;
};

//---------------------------------------------------------------------
private
global_objects_ctx_cleaner: (aux: *void) ~> void
{
    ctx = *(aux: *v_global_objects_ctx_t);

    v_terminate(&ctx.unit.obtain_spec.global_ctx.term_list);
    v_terminate(&ctx.unit.obtain_spec.global_ctx.init_list);

    free: (*void) ~> void;

    free(&ctx);
}

//---------------------------------------------------------------------
//- Enable global objects
//---------------------------------------------------------------------
export
voidc_enable_global_objects_compiler: () ~> void
{
    v_return_if(v_find_constant_q(enabled_q, 0, 0));

    v_add_constant_q(enabled_q, v_void_type(), 0);

    //-----------------------------------------------------------------
    ctx = *v_malloc(v_global_objects_ctx_t) := 0;

    obtain_spec = ctx.unit.obtain_spec;

    v_initialize(&obtain_spec.global_ctx.init_list);
    v_initialize(&obtain_spec.global_ctx.term_list);

    v_make_list_nil(&obtain_spec.global_ctx.init_list);
    v_make_list_nil(&obtain_spec.global_ctx.term_list);

    //-----------------------------------------------------------------
    v_add_intrinsic_q(voidc_abstract_static_type_intrinsic_q, my_abstract_static_type_intrinsic, 0);

    static_type_t = v_find_type("v_static_type_t");

    v_add_overload_q(voidc_abstract_static_constant_q, static_type_t, voidc_abstract_static_type_intrinsic_q);

    //-----------------------------------------------------------------
    vis = v_get_compiler();

    voidc_visitor_set_method(vis, vis, unit_var_defn_q, my_compile_unit_var_defn, &obtain_spec);
    voidc_visitor_set_method(vis, vis, unit_val_defn_q, my_compile_unit_val_defn, &obtain_spec);

    voidc_visitor_set_method(vis, vis, unit_stmt_init_q, compile_unit_stmt_init, &obtain_spec.global_ctx);
    voidc_visitor_set_method(vis, vis, unit_stmt_term_q, compile_unit_stmt_term, &obtain_spec.global_ctx);

    q = v_ast_expr_identifier_tag;

    voidc_visitor_set_method(vis, vis, q, my_compile_expr_identifier, 0);

    ctx.unit.fun := voidc_visitor_get_method(vis, defn_list_unit_q, &ctx.unit.aux);

    voidc_visitor_set_method(vis, vis, defn_list_unit_q, my_compile_defn_list_unit, &ctx.unit);

    //-----------------------------------------------------------------
    gctx = v_target_get_global_ctx();
    vctx = v_target_get_voidc_global_ctx();

    if (gctx == vctx)
    {
        ctx.fin_cdtors.fun := v_get_finish_module_hook(&ctx.fin_cdtors.ctx);

        v_set_finish_module_hook(voidc_finish_module_cdtors, &ctx.fin_cdtors);
    }

    //-----------------------------------------------------------------
    obtain_spec.fun := v_get_handler(v_obtain_special_result_value, &obtain_spec.aux);

    v_set_handler(v_obtain_special_result_value, my_obtain_special_result_value_helper, &obtain_spec);

    //-----------------------------------------------------------------
    ctx.fin_globals.global_ctx := &obtain_spec.global_ctx;

    ctx.fin_globals.fun := v_get_finish_module_hook(&ctx.fin_globals.ctx);

    v_set_finish_module_hook(my_finish_module_globals, &ctx.fin_globals);

    //-----------------------------------------------------------------
    v_add_local_cleaner(global_objects_ctx_cleaner, &ctx);
}


//---------------------------------------------------------------------
//- Enable global objects
//---------------------------------------------------------------------
export
voidc_enable_global_objects: () ~> void
{
    voidc_enable_global_objects_compiler();

    v_return_if_not(voidc_has_grammar());

    gr0: &v_peg_grammar_t := {};    gr0 = &gr0;

    v_peg_get_grammar(gr0);

    v_return_if(v_peg_grammar_get_action(gr0, "mk_unit_stmt_init", 0));

    //-----------------------------------------------------------------
    grammar gr0
    {
    actions:
        mk_unit_stmt_init = mk_unit_stmt_init_grammar_action;
        mk_unit_stmt_term = mk_unit_stmt_term_grammar_action;

    parsers:
        unit_stmt_init = stmt_big_block
                       / stmt_if_then_else
                       / stmt_loop
                       / stmt_switch
                       / stmt_while
                       / stmt_for
                       ;


        unit_stmt_term = stmt_defer;


        unit_defn += s:unit_stmt_init   { mk_unit_stmt_init(s) }
                   / s:unit_stmt_term   { mk_unit_stmt_term(s) }
                   ;
    }

    v_peg_set_grammar(gr0);

    //- ...
}


//=====================================================================
{   voidc_unit_end_module(); }


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
{   ast_unit_stmt_init_vtable[2] := unit_stmt_init_q;
    ast_unit_stmt_term_vtable[2] := unit_stmt_term_q;
}


