//---------------------------------------------------------------------
//- Copyright (C) 2020-2024 Dmitry Borodkin <borodkin.dn@gmail.com>
//- SDPX-License-Identifier: LGPL-3.0-or-later
//---------------------------------------------------------------------
{   voidc_guard_target("local_objects.void  must be imported into the voidc target only!");

    v_import("level-00");
    v_import("level-01");
    v_import("level-02");

    v_import("llvm-c/Core.void");

    v_import("intrinsics_derive.void");

//  v_import("printf.void");
}

{   v_enable_level_01();
    v_enable_level_02();

    voidc_enable_intrinsics_derive();
}


//=====================================================================
{   voidc_unit_begin_module("local_objects_module"); }

//---------------------------------------------------------------------
{   q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("enabled_q", q_ref, q("voidc.internal.local_objects_enabled"));

    v_add_symbol("expr_stmt_q", q_ref, q("expr_stmt"));

    v_add_symbol("q_initialize", q_ref, q("v_initialize"));
    v_add_symbol("q_terminate",  q_ref, q("v_terminate"));
    v_add_symbol("q_copy",       q_ref, q("v_copy"));

    v_add_symbol("q_getelementptr", q_ref, q("v_getelementptr"));

    v_add_symbol("voidc_internal_return_value_q",        q_ref, q("voidc.internal_return_value"));
    v_add_symbol("voidc_internal_branch_target_leave_q", q_ref, q("voidc.internal_branch_target_leave"));

    v_add_symbol("voidc_internal_break_value_q",                  q_ref, q("voidc.internal_break_value"));
    v_add_symbol("voidc_internal_branch_target_break_variable_q", q_ref, q("voidc.internal_branch_target_break_variable"));
    v_add_symbol("voidc_internal_branch_target_break_q",          q_ref, q("voidc.internal_branch_target_break"));

    v_add_symbol("voidc_incomplete_array_type_tag", q_ref, q("voidc.incomplete_array_type_tag"));

    v_add_symbol("voidc_local_objects_context_q", q_ref, q("voidc.local_objects_context"));
}


//---------------------------------------------------------------------
//- v_ast_expr_stmt_t ...
//---------------------------------------------------------------------
export
struct v_ast_expr_stmt_t
{
    stmt: v_ast_stmt_t;                 //- Statement...
};

//---------------------------------------------------------------------
private
ast_expr_stmt_init: (void_obj: *void) ~> void
{
    obj = *(void_obj: *v_ast_expr_stmt_t);

    v_initialize(&obj.stmt);
}

//---------------------------------------------------------------------
private
ast_expr_stmt_term: (void_obj: *void) ~> void
{
    obj = *(void_obj: *v_ast_expr_stmt_t);

    v_terminate(&obj.stmt);
}


//---------------------------------------------------------------------
ast_expr_stmt_vtable: &v_ast_generic_vtable :=
{
    ast_expr_stmt_init,
    ast_expr_stmt_term,
};

//---------------------------------------------------------------------
export
v_ast_make_expr_stmt: (ret: *v_ast_expr_t, stmt: *v_ast_stmt_t) ~> void
{
    expr = v_alloca(v_ast_expr_t);
    v_initialize(expr);
    defer v_terminate(expr);

    v_ast_make_generic(expr, &ast_expr_stmt_vtable, v_ast_expr_stmt_t.size);

    void_obj = v_ast_generic_get_object(expr);

    obj = *(void_obj: *v_ast_expr_stmt_t);

    if (stmt)  v_copy(&obj.stmt, stmt);

    v_copy(ret,  expr);
}


//---------------------------------------------------------------------
//- Grammar actions ...
//---------------------------------------------------------------------
private
mk_expr_stmt_grammar_action: (ret: v_std_any_ptr, *void, any: v_std_any_ptr, size_t) ~> void
{
    stmt = v_std_any_get_pointer(v_ast_stmt_t, any+0);

    expr = v_alloca(v_ast_expr_t);
    v_initialize(expr);
    defer v_terminate(expr);

    v_ast_make_expr_stmt(expr, stmt);

    v_std_any_set_pointer(ret, expr);
}


//---------------------------------------------------------------------
//- local_objects_ctx_t ...
//---------------------------------------------------------------------
export
voidc_prepare_function_parameters_helper_t = struct
{
    *((*void, LLVMValueRef, intptr_t, *const char, *v_type_t, *v_ast_generic_list_t) ~> void);
    *void;
};

export
voidc_obtain_special_result_value_helper_t = struct
{
    fun: *((*void, vis: *voidc_visitor_t, t: *v_type_t) ~> LLVMValueRef);
    aux: *void;
};

private
my_intrinsic_ctx_t = struct
{
    fun: *((*void, *voidc_visitor_t, *v_ast_base_t) ~> void);
    aux: *void;
};

private
my_adopt_result_ctx_t = struct
{
    fun: *((*void, *v_type_t, LLVMValueRef) ~> void);
    ctx: *void;
};

//---------------------------------------------------------------------
{   v_enable_handler(voidc_prepare_function_parameters_helper_t);
    v_enable_handler(voidc_obtain_special_result_value_helper_t);
    v_enable_handler(my_intrinsic_ctx_t);
    v_enable_handler(my_adopt_result_ctx_t);

    //-----------------------------------------------------------------
    LLVMDisposeMemoryBuffer(voidc_get_unit_buffer());
    voidc_set_unit_buffer(0);
}


//---------------------------------------------------------------------
private
local_objects_ctx_t = struct
{
    obtain_spec_flag: bool;

    fun_params:  voidc_prepare_function_parameters_helper_t;    //- ...
    obtain_spec: voidc_obtain_special_result_value_helper_t;

    stmt_hook:    my_intrinsic_ctx_t;
    adopt_result: my_adopt_result_ctx_t;
    return:       my_intrinsic_ctx_t;
    op_braces:    my_intrinsic_ctx_t;
};


//---------------------------------------------------------------------
private
add_local_objects_context: (ctx: *local_objects_ctx_t) ~> void
{
    any = v_alloca(v_std_any_t);
    v_initialize(any);
    defer v_terminate(any);

    v_std_any_set_value(any, v_cast(ctx, intptr_t));

    v_add_property_q(voidc_local_objects_context_q, any);
}

//---------------------------------------------------------------------
private
get_local_objects_context: () ~> *local_objects_ctx_t
{
    any = v_get_property_q(voidc_local_objects_context_q);

    ctx = (v_std_any_get_value(intptr_t, any) : *local_objects_ctx_t);

    v_return(ctx);
}


//---------------------------------------------------------------------
export
voidc_local_objects_context_get_obtain_special_result_value_helper: () ~> &voidc_obtain_special_result_value_helper_t
{
    ctx = *get_local_objects_context();

    v_return(ctx.obtain_spec);
}


//=====================================================================
private
my_fake_utility_intrinsic: (aux: *void, *voidc_visitor_t, *v_ast_base_t,
                            *v_type_t, LLVMValueRef) ~> void
{
    q = v_quark_to_string((aux: v_quark_t));

    printf: (*const char, ...) ~> int;

    printf("my_fake_utility_intrinsic: %s\n", q);

    exit: (int) ~> void;

    exit(-1);       //- Sic!
}

//---------------------------------------------------------------------
my_fake_utility_intrinsic_ctor: () ~> void
{
    sstr = v_alloca(v_std_string_t);
    v_initialize(sstr);
    defer v_terminate(sstr);

    qnames: &(*const char)[] :=
    {
        "v_initialize",
        "v_terminate",
        "v_copy",
        0
    };

    for (name: &**const char := &qnames[0]; *name; ++name)
    {
        v_std_string_set(sstr, "v.internal.fake_utility.");

        v_std_string_append(sstr, *name);

        q_fake = v_quark_from_string(v_std_string_get(sstr));
        q_name = v_quark_from_string(*name);

        v_add_intrinsic_q(q_fake, my_fake_utility_intrinsic, (q_name: *void));
    }
}


//---------------------------------------------------------------------
v_type_is_special: (t: *v_type_t, q: v_quark_t) ~> bool;

//---------------------------------------------------------------------
v_type_check_special: (t: *v_type_t, q: v_quark_t) ~> void
{
    switch(v_kind(t))
    {
    case v_type_kind_array:
    case v_type_kind_struct:
        v_break();

    default:
        v_return();
    }

    sstr = v_alloca(v_std_string_t);
    v_initialize(sstr);
    defer v_terminate(sstr);

    v_std_string_set(sstr, v_quark_to_string(q));

    v_std_string_append(sstr, ".checked");

    q_checked = v_quark_from_string(v_std_string_get(sstr));

    if (v_get_overload_q(q_checked, t))  v_return();

    block
    {
        if (v_type_is_array(t))
        {
            v_type_check_special(v_type_array_get_element_type(t), q);
            v_break();
        }

        if (v_type_is_struct(t))
        {
            if (v_get_overload_q(q, t))  v_break();

            flag: &bool := false;

            count = v_type_struct_get_element_count(t);
            types = v_type_struct_get_element_types(t);

            for (i: &int := 0; i < count; ++i)
            {
                flag |= v_type_is_special(types[i], q);

                if (flag)   v_break();
            }

            if (flag)
            {
                v_std_string_set(sstr, "v.internal.fake_utility.");

                v_std_string_append(sstr, v_quark_to_string(q));

                q_fake = v_quark_from_string(v_std_string_get(sstr));

                v_util_function_dict_set(q, t, q_fake);
            }

            v_break();
        }

        //- ?!? ...
    }

    v_add_overload_q(q_checked, t, q_checked);          //- ?!?!?
}


//---------------------------------------------------------------------
export
v_type_is_special: (t: *v_type_t, q: v_quark_t) ~> bool
{
    switch(v_kind(t))
    {
    case v_type_kind_array:
        v_return(v_type_is_special(v_type_array_get_element_type(t), q));

    case v_type_kind_struct:
        v_break();

    default:
        v_return(false);        //- Sic!!!
    }

    v_type_check_special(t, q);

    v_return(v_get_overload_q(q, t) != 0);
}


//=====================================================================
private
v_type_function_obtain_llvm_type_hook: (*void, ft: *v_type_t) ~> LLVMTypeRef
{
    par_count = v_type_function_get_param_count(ft);
    par_types = v_type_function_get_param_types(ft);

    n: &unsigned := par_count;

    rt = v_type_function_get_return_type(ft);

    rt_initializable = v_type_is_special(rt, q_initialize);

    if (rt_initializable) ++n;

    par = v_malloc(LLVMTypeRef, n);
    defer v_free(par);

    llvm_ctx = v_target_get_llvm_ctx();

    llvm_ptr = LLVMPointerTypeInContext(llvm_ctx, 0);

    ppar: &*LLVMTypeRef := par;

    if (rt_initializable)
    {
        par[0] := llvm_ptr;

        ++ppar;
    }

    for(i: &unsigned := 0; i < par_count; ++i, ++ppar)
    {
        pt = par_types[i];

        if (v_type_is_special(pt, q_initialize))  *ppar := llvm_ptr;
        else                                      *ppar := v_type_get_llvm_type(pt);
    }

    ret: &LLVMTypeRef := v_undef();

    if (rt_initializable)   ret := LLVMVoidTypeInContext(llvm_ctx);
    else                    ret := v_type_get_llvm_type(rt);

    var_arg = v_type_function_is_var_arg(ft);

    ret = LLVMFunctionType(ret, par, n, var_arg);

    v_type_set_cached_llvm_type(ft, ret);

    v_return(ret);
}


//=====================================================================
private
my_prepare_function_parameters: (aux: *void, fun: LLVMValueRef,
                                 qualif: intptr_t,
                                 fun_name: *const char,
                                 fun_type: *v_type_t,
                                 fun_args: *v_ast_generic_list_t
                                ) ~> void
{
    tr = v_type_function_get_return_type(fun_type);

    if (!v_type_is_special(tr, q_initialize))
    {
        ctx = *(aux: *local_objects_ctx_t);

        ctx.fun_params(fun, qualif, fun_name, fun_type, fun_args);

        v_return();
    }

    vr = LLVMGetParam(fun, 0);

    v_add_variable_q(voidc_internal_return_value_q, tr, vr);         //- Sic!

    count = v_type_function_get_param_count(fun_type);
    types = v_type_function_get_param_types(fun_type);

    for (i: &int := 0; i < count; ++i)
    {
        item = (v_list_get_item(fun_args, i) : *v_ast_generic_list_t);

        etmp = (v_list_get_item(item, 0) : *v_ast_expr_t);

        if (!v_empty(etmp))
        {
            pname = v_ast_expr_identifier_get_name(etmp);

            v_add_parameter_name(fun, i+1, pname, types[i]);
        }
    }
}


//=====================================================================
//- ...
//=====================================================================
export
voidc_make_special_intrinsic_call: (stmt: *v_ast_stmt_t, q: v_quark_t,
                                    t: *v_type_t, v0: LLVMValueRef, v1: LLVMValueRef
                                    ) ~> void
{
    //- assert(q == q_initialize  ||  q == q_terminate  ||  q == q_copy);       //- Sic!

    expr = v_alloca(v_ast_expr_t, 3);
    v_initialize(expr, 3);
    defer v_terminate(expr, 3);

    expr_list = v_alloca(v_ast_expr_list_t, 2);
    v_initialize(expr_list, 2);
    defer v_terminate(expr_list, 2);

    t_ptr = v_pointer_type(t, 0);

    v_ast_make_expr_compiled(expr+0, t_ptr, v0);

    is_copy = q == q_copy;

    if (is_copy) v_ast_make_expr_compiled(expr+1, t_ptr, v1);

    length: &uint64_t := 1;

    et: &v_type_ptr := t;

    if (v_type_is_array(t))
    {
        v_ast_make_expr_integer(expr+2, 0);

        v_make_list(expr_list+0, expr+0, 1);

        v_list_append(expr_list+0, expr_list+0, expr+2, 1);

        if (is_copy) v_make_list(expr_list+1, expr+1, 2);

        loop
        {
            length *= v_type_array_get_length(et);

            v_list_append(expr_list+0, expr_list+0, expr+2, 1);

            if (is_copy) v_list_append(expr_list+1, expr_list+1, expr+2, 1);

            et := v_type_array_get_element_type(et);

            if (!v_type_is_array(et))   v_break();
        }

        //- assert(length != 0);            //- WTF ?..

        v_ast_make_expr_identifier_q(expr+2, q_getelementptr);

        v_ast_make_expr_call(expr+0, expr+2, expr_list+0);

        if (is_copy) v_ast_make_expr_call(expr+1, expr+2, expr_list+1);
    }

    if (is_copy)
    {
        v_ast_make_expr_integer(expr+2, (length: intptr_t));

        v_ast_make_stmt_call(stmt, 0, q, expr+0, 3);
    }
    else
    {
        v_ast_make_expr_integer(expr+1, (length: intptr_t));

        v_ast_make_stmt_call(stmt, 0, q, expr+0, 2);
    }
}

//---------------------------------------------------------------------
private
my_temporary_cleaner_ctx_t = struct
{
    typ: *v_type_t;
    val: LLVMValueRef;
};

private
my_temporary_cleaner: (void_ctx: *void) ~> void
{
    ctx = *(void_ctx: *my_temporary_cleaner_ctx_t);
    defer v_free(&ctx);

    if (!v_type_is_special(ctx.typ, q_terminate))   v_return();     //- ?..

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);

    voidc_make_special_intrinsic_call(stmt, q_terminate, ctx.typ, ctx.val, 0);

    v_ast_accept_visitor((stmt: *v_ast_base_t), v_get_compiler());
}


//---------------------------------------------------------------------
private
obtain_special_result_value_temporary: (vis: *voidc_visitor_t, t: *v_type_t) ~> LLVMValueRef
{
    //- assert(v_type_is_special(t, q_initialize));

    builder = v_target_get_builder();

    v = v_make_temporary(t, 0);

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);

    voidc_make_special_intrinsic_call(stmt, q_initialize, t, v, 0);

    v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

    if (v_type_is_special(t, q_terminate))
    {
        ctx = *v_malloc(my_temporary_cleaner_ctx_t) := {t, v};

        v_add_temporary_cleaner(my_temporary_cleaner, &ctx);
    }

    v_return(v);
}

//---------------------------------------------------------------------
private
obtain_special_result_value_variable: (vis: *voidc_visitor_t, t: *v_type_t) ~> LLVMValueRef
{
    //- assert(v_type_is_special(t, q_initialize));

    builder = v_target_get_builder();

    t_front = v_get_temporaries_front();

    if (t_front)
    {
        v_save_builder_ip();

        LLVMPositionBuilderBefore(builder, t_front);
    }

    v = LLVMBuildAlloca(builder, v_type_get_llvm_type(t), "");

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);

    voidc_make_special_intrinsic_call(stmt, q_initialize, t, v, 0);

    v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

    if (v_type_is_special(t, q_terminate))
    {
        voidc_make_special_intrinsic_call(stmt, q_terminate, t, v, 0);

        v_ast_make_stmt_defer(stmt, stmt);

        v_ast_accept_visitor((stmt: *v_ast_base_t), vis);
    }

    if (t_front)  v_restore_builder_ip();

    v_return(v);
}


//---------------------------------------------------------------------
//- voidc_obtain_special_result_value ...
//---------------------------------------------------------------------
private
voidc_obtain_special_result_value_helper: (aux: *void, vis: *voidc_visitor_t, t: *v_type_t) ~> LLVMValueRef
{
    //- assert(v_type_is_special(t, q_initialize));

    *(aux: *bool) := true;                  //- Kinda, signal...

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    switch((vtag: intptr_t))
    {
    case 0:         //- TEMPORARY_VTAG

        v_return(obtain_special_result_value_temporary(vis, t));

    case -1:        //- VARIABLE_VTAG

        v_return(obtain_special_result_value_variable(vis, t));

    default:

        //- assert(INVIOLABLE_TAG != ttag != UNREFERENCE_TAG);

        if (ttag != t)
        {
            v_set_result_type(t);

            v_adopt_result(ttag, vtag);             //- ?...

            v_return(v_get_result_value());
        }

        v_return(vtag);         //- ?..
    }
}


//=====================================================================
export TEMPORARY_VTAG = (( 0: intptr_t) : LLVMValueRef);
export VARIABLE_VTAG  = ((-1: intptr_t) : LLVMValueRef);
export GLOBAL_VTAG    = ((-2: intptr_t) : LLVMValueRef);


//---------------------------------------------------------------------
private
my_compile_stmt: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    expr = v_ast_stmt_get_expr((self: *v_ast_stmt_t));
    if (v_empty(expr))  v_return();                             //- Sic!

    name = v_ast_stmt_get_name((self: *v_ast_stmt_t));

    if (name  &&  name[0])  v_set_result_value(VARIABLE_VTAG);      //- Sic!!!
    else                    v_set_result_value(TEMPORARY_VTAG);     //- Sic!!!

    ctx = *(aux: *local_objects_ctx_t);

    ctx.stmt_hook(vis, self);
}


//---------------------------------------------------------------------
//- llvm_build_call_helper ...
//---------------------------------------------------------------------
private
my_llvm_build_call_helper: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t,
                            ft: v_type_ptr, fv: LLVMValueRef,
                            arg_ptrs: **v_ast_expr_t, arg_count: unsigned
                           ) ~> void
{
    ctx = *(aux: *local_objects_ctx_t);

    par_count = v_type_function_get_param_count(ft);
    par_types = v_type_function_get_param_types(ft);

    par_count: &unsigned := par_count;
    arg_count: &unsigned := arg_count;

    tr = v_type_function_get_return_type(ft);

    tr_initializable = v_type_is_special(tr, q_initialize);

    if (tr_initializable)
    {
        ++par_count;
        ++arg_count;
    }

    values = v_malloc(LLVMValueRef, arg_count);
    defer v_free(values);

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    vr: &LLVMValueRef := v_undef();

    i: &unsigned := 0;

    if (tr_initializable)
    {
        values[0] := vr := ctx.obtain_spec(vis, tr);

        i := 1;
    }

    for (; i < arg_count; ++i)
    {
        j: &unsigned := i;

        if (tr_initializable)   --j;

        if (i < par_count)  v_set_result_type(par_types[j]);
        else                v_set_result_type(UNREFERENCE_TAG);

        v_set_result_value(TEMPORARY_VTAG);

        v_ast_accept_visitor((arg_ptrs[j]: v_ast_base_ptr), vis);

        values[i] := v_get_result_value();
    }

    builder = v_target_get_builder();

    ft_ = v_type_get_llvm_type(ft);

    _vr = LLVMBuildCall2(builder, ft_, fv, values, arg_count, "");

    if (!tr_initializable)  vr := _vr;

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    v_adopt_result(tr, vr);
}


//---------------------------------------------------------------------
//- adopt_result ...
//---------------------------------------------------------------------
private
my_adopt_result: (void_ctx: *void, type: *v_type_t, value: LLVMValueRef) ~> void
{
    ttag = v_get_result_type();
    vtag = v_get_result_value();

    if (ttag == UNREFERENCE_TAG  &&  type == v_static_type_t)
    {
        ctx = *(void_ctx: *local_objects_ctx_t);

        ctx.adopt_result(type, value);

        v_return();
    }

    value: &LLVMValueRef := value;

    src_ref = v_type_is_reference(type);

    builder = v_target_get_builder();

    switch((ttag: intptr_t))
    {
    case -1:        //- Unreference...

        if (src_ref)
        {
            et = v_type_refptr_get_element_type(type);

            if (v_type_is_array(et))
            {
                //- Special case for C-like array-to-pointer "promotion"...

                et = v_type_array_get_element_type(et);

                as = v_type_refptr_get_address_space(type);

                res_type = v_pointer_type(et, as);

                v_set_result_type(res_type);

                value := v_convert_to_type(type, value, res_type);

                v_break();
            }

            v_set_result_type(et);

            if (!v_type_is_special(et, q_initialize))
            {
                value := LLVMBuildLoad2(builder, v_type_get_llvm_type(et), value, "tmp");
            }

            v_break();
        }

        if (v_type_is_array(type))
        {
            //- Special case for C-like array-to-pointer "promotion"...

            et = v_type_array_get_element_type(type);

            res_type = v_pointer_type(et, 0);           //- 0?

            v_set_result_type(res_type);

            value := v_convert_to_type(type, value, res_type);

            v_break();
        }

        //- Fallthrough!

    case 0:         //- Get "as is"...

        v_set_result_type(type);

        v_break();

    default:        //- Adopt...

        if (ttag == type)
        {
            if (v_type_is_special(type, q_initialize))          //- Sic!
            block
            {
                if (vtag == TEMPORARY_VTAG) v_break();
                if (vtag == VARIABLE_VTAG)  v_break();
                if (vtag == GLOBAL_VTAG)    v_break();      //- ?..
                if (vtag == value)          v_break();

                stmt = v_alloca(v_ast_stmt_t);
                v_initialize(stmt);
                defer v_terminate(stmt);

                voidc_make_special_intrinsic_call(stmt, q_copy, ttag, vtag, value);     //- Sic!

                v_ast_accept_visitor((stmt: *v_ast_base_t), v_get_compiler());

                v_set_result_type(ttag);

                value := vtag;
            }

            //- ?!?!?!?!?!?

            v_break();
        }

        //- assert(ttag != type);

        dst_ref = v_type_is_reference(ttag);

        dst_typ: &*v_type_t := ttag;

        if (dst_ref)  dst_typ := v_type_refptr_get_element_type(dst_typ);

        src_typ: &*v_type_t := type;

        if (src_ref)
        {
            src_typ := v_type_refptr_get_element_type(src_typ);

            if (v_type_is_array(src_typ)  &&  v_type_is_pointer(dst_typ))
            {
                //- Special case for C-like array-to-pointer "promotion"...

                et = v_type_array_get_element_type(src_typ);

                as = v_type_refptr_get_address_space(dst_typ);

                src_typ := v_pointer_type(et, as);

                value := v_convert_to_type(type, value, src_typ);
            }
            else if (v_type_is_special(src_typ, q_initialize))
            {
                //- Kinda, NOP! ...
            }
            else
            {
                value := LLVMBuildLoad2(builder, v_type_get_llvm_type(src_typ), value, "tmp");
            }
        }

        //- Now value has type src_typ!

        //- assert(!v_type_is_reference(src_typ));
        //- assert(!v_type_is_reference(dst_typ));

        if (src_typ != dst_typ)
        {
            if (dst_typ == v_pointer_type(v_void_type(), 0)  &&  v_type_is_pointer(src_typ))
            {
                value := LLVMBuildPointerCast(builder, value, v_type_get_llvm_type(dst_typ), "");
            }
            else
            {
                v_set_result_type(dst_typ);                                 //- Sic!

                value := v_convert_to_type(src_typ, value, dst_typ);        //- "generic" ...

                dst_typ := v_get_result_type();                             //- Sic!!!
            }
        }

        //- Now value has type dst_typ!

        if (dst_ref)
        {
            if (v_type_is_special(dst_typ, q_initialize))
            {
                stmt = v_alloca(v_ast_stmt_t);
                v_initialize(stmt);
                defer v_terminate(stmt);

                v = v_make_temporary(dst_typ, 0);

                voidc_make_special_intrinsic_call(stmt, q_initialize, dst_typ, v, 0);

                vis = v_get_compiler();

                v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

                voidc_make_special_intrinsic_call(stmt, q_copy, dst_typ, v, value);         //- Sic!

                v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

                if (v_type_is_special(dst_typ, q_terminate))
                {
                    ctx = *v_malloc(my_temporary_cleaner_ctx_t) := {dst_typ, v};

                    v_add_temporary_cleaner(my_temporary_cleaner, &ctx);
                }

                value := v;
            }
            else
            {
                value := v_make_temporary(dst_typ, value);          //- Sic!!!
            }

            as = v_type_refptr_get_address_space(ttag);

            v_set_result_type(v_reference_type(dst_typ, as));
        }
        else if (v_type_is_special(dst_typ, q_initialize))          //- Sic!
        block
        {
            if (vtag == TEMPORARY_VTAG) v_break();      //- ?..
            if (vtag == VARIABLE_VTAG)  v_break();      //- ?..
            if (vtag == GLOBAL_VTAG)    v_break();      //- ?..
            if (vtag == value)          v_break();

            stmt = v_alloca(v_ast_stmt_t);
            v_initialize(stmt);
            defer v_terminate(stmt);

            voidc_make_special_intrinsic_call(stmt, q_copy, dst_typ, vtag, value);

            v_ast_accept_visitor((stmt: *v_ast_base_t), v_get_compiler());

            value := vtag;

            v_set_result_type(dst_typ);
        }

        //- ??!?!?!?!?!?!?!?

    }

    v_set_result_value(value);
}


//=====================================================================
private
my_return_intrinsic: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    call = (self: *v_ast_expr_t);

    arg_list = v_ast_expr_call_get_arg_list(call);

    builder = v_target_get_builder();

    args_count = v_list_get_size(arg_list);

    if (args_count)
    {
        ret_type = v_get_variable_type_q(voidc_internal_return_value_q);

        if (!v_type_is_special(ret_type, q_initialize))
        {
            ctx = *(aux: *local_objects_ctx_t);

            ctx.return(vis, self);

            v_return();
        }

        ret_value = v_get_variable_value_q(voidc_internal_return_value_q);

        v_set_result_type(ret_type);
        v_set_result_value(ret_value);

        arg0 = v_list_get_item(arg_list, 0);

        v_ast_accept_visitor((arg0: *v_ast_base_t), vis);

        t = v_get_result_type();
        v = v_get_result_value();

        if (t != ret_type  ||  v != ret_value)          //- WTF?
        {
            v_set_result_type(ret_type);
            v_set_result_value(ret_value);

            v_adopt_result(t, v);
        }
    }

    leave_bv = v_get_variable_value_q(voidc_internal_branch_target_leave_q);
    leave_b  = LLVMValueAsBasicBlock(leave_bv);

    LLVMBuildBr(builder, leave_b);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
private
compile_expr_stmt: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    ttag = v_get_result_type();
    vtag = v_get_result_value();

    is_special = v_type_is_special(ttag, q_initialize);

    tr = ttag;                          //- Sic !!!

    vr: &LLVMValueRef := v_undef();

    if (is_special)
    {
        hnd = *(aux: *voidc_obtain_special_result_value_helper_t);

        vr := hnd(vis, tr);
    }
    else
    {
        vr := v_make_temporary(tr, 0);
    }

    void_obj = v_ast_generic_get_object((self: *v_ast_expr_t));

    obj = *(void_obj: *v_ast_expr_stmt_t);

    v_save_variables();

    v_add_variable_q(voidc_internal_break_value_q, tr, vr);

    v_ast_accept_visitor((&obj.stmt: *v_ast_base_t), vis);

    v_restore_variables();

    if (!is_special)
    {
        builder = v_target_get_builder();

        tr_ = v_type_get_llvm_type(tr);

        vr := LLVMBuildLoad2(builder, tr_, vr, "vr");
    }

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    v_adopt_result(tr, vr);         //- ?
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
private
my_break_intrinsic: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
//printf("my_break_intrinsic start\n");
//defer printf("my_break_intrinsic stop\n");

    call = (self: *v_ast_expr_t);

    arg_list = v_ast_expr_call_get_arg_list(call);

    builder = v_target_get_builder();

    args_count = v_list_get_size(arg_list);

    if (args_count)
    block
    {
        arg0 = v_list_get_item(arg_list, 0);

        brk_type  = v_get_variable_type_q(voidc_internal_break_value_q);
        brk_var_v = v_get_variable_value_q(voidc_internal_break_value_q);

        v_set_result_type(brk_type);

        if (!v_type_is_special(brk_type, q_initialize))
        {
            v_set_result_value(0);

            v_ast_accept_visitor((arg0: *v_ast_base_t), vis);

            vr = v_get_result_value();

            builder = v_target_get_builder();

            LLVMBuildStore(builder, vr, brk_var_v);

            v_break();
        }

        v_set_result_value(brk_var_v);

        v_ast_accept_visitor((arg0: *v_ast_base_t), vis);

        t = v_get_result_type();
        v = v_get_result_value();

        if (t != brk_type  ||  v != brk_var_v)          //- WTF?
        {
            v_set_result_type(brk_type);
            v_set_result_value(brk_var_v);

            v_adopt_result(t, v);
        }
    }

    break_var  = v_get_variable_value_q(voidc_internal_branch_target_break_variable_q);
    break_addr = v_get_variable_value_q(voidc_internal_branch_target_break_q);

    voidc_intrinsic_break_helper(break_var, break_addr);
}


//=====================================================================
private
v_get_return_value_intrinsic: (*void, *voidc_visitor_t, *v_ast_base_t) ~> void
{
    ret_type  = v_get_variable_type_q(voidc_internal_return_value_q);
    ret_value = v_get_variable_value_q(voidc_internal_return_value_q);

    v_set_result_type(v_reference_type(ret_type, 0));
    v_set_result_value(ret_value);
}

//---------------------------------------------------------------------
private
v_get_object_pointer_intrinsic: (*void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
//printf("v_get_object_pointer_intrinsic: start\n");
//defer printf("v_get_object_pointer_intrinsic: finish\n");

    arg_list = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(TEMPORARY_VTAG);

    v_ast_accept_visitor((v_list_get_item(arg_list, 0) : *v_ast_base_t), vis);

    ret_type  = v_get_result_type();
    ret_value = v_get_result_value();

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    v_adopt_result(v_pointer_type(ret_type, 0), ret_value);
}


//=====================================================================
private
my_internal_var_defn_intrinsic: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
//printf("my_internal_var_defn_intrinsic\n");
//defer printf("my_internal_var_defn_intrinsic leave\n");

    ctx = *(aux: *local_objects_ctx_t);

    arg_list = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    arg0 = v_list_get_item(arg_list, 0);
    arg1 = v_list_get_item(arg_list, 1);

//  ttag = v_get_result_type();         //- assert(ttag == INVIOLABLE_TAG);
    vtag = v_get_result_value();        //- assert(vtag == VARIABLE_VTAG);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor((arg0: *v_ast_base_t), vis);               //- Type

    var_type = (v_get_result_value() : *v_type_t);

    //- assert(v_type_is_reference(var_type));

    t = v_type_refptr_get_element_type(var_type);       //- Sic!
    a = v_type_refptr_get_address_space(var_type);      //- Sic!

    v_set_result_type(t);
    v_set_result_value(vtag);

    ctx.obtain_spec_flag := false;

    v_ast_accept_visitor((arg1: *v_ast_base_t), vis);               //- Value

    t = v_get_result_type();
    v = v_get_result_value();

    if (v_type_is_special(t, q_initialize))
    block
    {
        if (LLVMIsUndef(v)) v_break();

        if (v == LLVMConstNull(v_type_get_llvm_type(t)))  v_break();

        if (!ctx.obtain_spec_flag)
        {
           vv = obtain_special_result_value_variable(vis, t);       //- Sic!!!

           stmt = v_alloca(v_ast_stmt_t);
           v_initialize(stmt);
           defer v_terminate(stmt);

           voidc_make_special_intrinsic_call(stmt, q_copy, t, vv, v);

           v_ast_accept_visitor((stmt: *v_ast_base_t), vis);

           v_set_result_value(vv);
        }

        v_set_result_type(v_reference_type(t, a));

        v_return();
    }

    builder = v_target_get_builder();

    t_ = v_type_get_llvm_type(t);

    var_value = LLVMBuildAlloca(builder, t_, "");

    LLVMBuildStore(builder, v, var_value);

    v_set_result_type(v_reference_type(t, a));
    v_set_result_value(var_value);
}

//---------------------------------------------------------------------
private
my_internal_val_defn_intrinsic: (*void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    arg_list = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    arg0 = v_list_get_item(arg_list, 0);
    arg1 = v_list_get_item(arg_list, 1);

//  ttag = v_get_result_type();
    vtag = v_get_result_value();

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor((arg1: *v_ast_base_t), vis);               //- Type

    t = (v_get_result_value() : *v_type_t);

    is_ref = v_type_is_reference(t);

    if (is_ref)  v_set_result_type(INVIOLABLE_TAG);
    else         v_set_result_type(t);

    v_set_result_value(vtag);

    v_ast_accept_visitor((arg0: *v_ast_base_t), vis);               //- Value

    if (is_ref)
    {
        tr = v_get_result_type();

        abort: () ~> void;

        if (!v_type_is_reference(tr))  abort();         //- !?!?!?!?!?!

        vr = v_get_result_value();

        v_set_result_type(t);

        v_adopt_result(tr, vr);
    }
}


//=====================================================================
private
my_op_braces_intrinsic: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
//printf("my_op_braces_intrinsic\n");
//defer printf("my_op_braces_intrinsic leave\n");

    ctx = *(aux: *local_objects_ctx_t);

    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    N = v_list_get_size(args);


    tr: &v_type_ptr := v_get_result_type();

    is_reference = v_type_is_reference(tr);

    addr_sp: &unsigned := v_undef();

    if (is_reference)
    {
        addr_sp := v_type_refptr_get_address_space(tr);         //- Sic!
        tr      := v_type_refptr_get_element_type(tr);          //- Sic!
    }

    block
    {
        if (!v_type_is_struct(tr))  v_break();

        typs = v_type_struct_get_element_types(tr);

        if (!v_type_is_struct(typs[0]))  v_break();

        if (v_type_struct_get_name_q(typs[0]) != voidc_incomplete_array_type_tag)  v_break();

        tr := v_array_type(typs[1], N);
    }

    if (!v_type_is_special(tr, q_initialize))
    {
        if (is_reference)   tr := v_reference_type(tr, addr_sp);

        v_set_result_type(tr);

        ctx.op_braces(vis, self);

        v_return();
    }

    vr = ctx.obtain_spec(vis, tr);

    builder = v_target_get_builder();

    {   ets: &*v_type_ptr := 0;

        et: &v_type_ptr := v_undef();

        if (v_type_is_struct(tr)) ets := v_type_struct_get_element_types(tr);
        if (v_type_is_array(tr))  et  := v_type_array_get_element_type(tr);

        int_ = v_type_get_llvm_type(v_find_type("int"));

        val: &LLVMValueRef[2] := { LLVMConstInt(int_, 0, 0) };

        tr_ = v_type_get_llvm_type(tr);

        for (i: &int := 0; i < N; ++i)
        {
            expr = v_list_get_item(args, i);

            if (ets)  et := ets[i];

            v_set_result_type(et);

            val[1] := LLVMConstInt(int_, i, 0);

            vr_i = LLVMBuildGEP2(builder, tr_, vr, val, 2, "");

            v_set_result_value(vr_i);

            v_ast_accept_visitor((expr: *v_ast_base_t), vis);

            if (!v_type_is_special(et, q_initialize))
            {
                LLVMBuildStore(builder, v_get_result_value(), vr_i);
            }
        }
    }

    if (is_reference) v_set_result_type(v_reference_type(tr, addr_sp));
    else              v_set_result_type(tr);

    v_set_result_value(vr);
}


//=====================================================================
//- Enable local objects
//---------------------------------------------------------------------
export
voidc_enable_local_objects_compiler: () ~> void
{
    v_return_if(v_find_constant_q(enabled_q, 0, 0));

    v_add_constant_q(enabled_q, void, 0);

    //-----------------------------------------------------------------
    vis = v_get_compiler();

    v_type_set_obtain_llvm_type_fun(v_type_kind_function, v_type_function_obtain_llvm_type_hook, 0);

    //-----------------------------------------------------------------
    ctx = *v_malloc(local_objects_ctx_t);

    add_local_objects_context(&ctx);

    //-----------------------------------------------------------------
    fun_params = voidc_definitions_context_get_fun_params();

    ctx.fun_params := fun_params;

    fun_params := { my_prepare_function_parameters, &ctx };

    //-----------------------------------------------------------------
    ctx.obtain_spec := {voidc_obtain_special_result_value_helper, &ctx.obtain_spec_flag};

    //-----------------------------------------------------------------
    q = v_quark_from_string("stmt");

    void_fun = voidc_visitor_get_void_method(vis, q, &ctx.stmt_hook.aux);

    ctx.stmt_hook.fun := (void_fun: *voidc_visitor_method_t);

    voidc_visitor_set_void_method(vis, vis, q, my_compile_stmt, &ctx);

    //-----------------------------------------------------------------
    hnd = voidc_overloading_context_get_llvm_build_call_helper();

    hnd := {my_llvm_build_call_helper, &ctx};

    ctx.adopt_result.fun := v_get_adopt_result(&ctx.adopt_result.ctx);

    v_set_adopt_result(my_adopt_result, &ctx);

    //-----------------------------------------------------------------
    q = v_quark_from_string("v_return");

    ctx.return.fun := (v_get_intrinsic_q(q, &ctx.return.aux) : *voidc_intrinsic_t);

    v_add_intrinsic_q(q, my_return_intrinsic, &ctx);

    v_add_intrinsic("v_get_return_value",   v_get_return_value_intrinsic,   0);
    v_add_intrinsic("v_get_object_pointer", v_get_object_pointer_intrinsic, 0);

    //-----------------------------------------------------------------
    voidc_visitor_set_void_method(vis, vis, expr_stmt_q, compile_expr_stmt, &ctx.obtain_spec);

    v_add_intrinsic("v_break", my_break_intrinsic, 0);

    //-----------------------------------------------------------------
    q = v_quark_from_string;

    v_add_intrinsic_q(q("v.internal.var_defn"), my_internal_var_defn_intrinsic, &ctx);
    v_add_intrinsic_q(q("v.internal.val_defn"), my_internal_val_defn_intrinsic, 0);     //- ?

    //-----------------------------------------------------------------
    q = v_quark_from_string("v.op_braces");

    ctx.op_braces.fun := (v_get_intrinsic_q(q, &ctx.op_braces.aux) : *voidc_intrinsic_t);

    v_add_intrinsic_q(q, my_op_braces_intrinsic, &ctx);

    //-----------------------------------------------------------------
    free: (*void) ~> void;

    v_add_local_cleaner(free, &ctx);

    //-----------------------------------------------------------------
    gctx = v_target_get_global_ctx();
    vctx = v_target_get_voidc_global_ctx();

    if (gctx == vctx)
    {
        v_enable_handler(voidc_obtain_special_result_value_helper_t);
    }
}


//---------------------------------------------------------------------
//- Enable local objects
//---------------------------------------------------------------------
export
voidc_enable_local_objects: () ~> void
{
    voidc_enable_local_objects_compiler();

    v_return_if_not(voidc_has_grammar());
    v_return_if(voidc_grammar_has_parser("expr_stmt"));

    gr0 = v_alloca(v_peg_grammar_t);
    v_initialize(gr0);
    defer v_terminate(gr0);

    v_peg_get_grammar(gr0);

    grammar gr0
    {
    actions:
        mk_expr_stmt = mk_expr_stmt_grammar_action;

    parsers:
        stmt_big_block = "block" _'{'_ l:stmt_list _'}'     { mk_stmt_block(l, 1) };    //- Sic!

        expr_stmt = stmt_big_block
                  / stmt_loop
                  / stmt_switch
                  / stmt_while
                  / stmt_for
                  ;

        prim += s:expr_stmt         { mk_expr_stmt(s) };
    }

    v_peg_set_grammar(gr0);
}


//=====================================================================
{   voidc_unit_end_module(); }


//---------------------------------------------------------------------
{   my_fake_utility_intrinsic_ctor();

    ast_expr_stmt_vtable[2] := expr_stmt_q;
}


