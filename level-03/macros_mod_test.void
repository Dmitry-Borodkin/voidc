{   v_import("level-00");
    v_import("level-01");
    v_import("level-02");

    v_import("intrinsics_derive.void");
    v_import("local_objects.void");
    v_import("heap_objects.void");
    v_import("global_objects.void");
    v_import("coercions.void");
    v_import("namespaces.void");
    v_import("generics_etc.void");
    v_import("generating_ast.void");
    v_import("macros.void");

    v_import("printf.void");
}

{   v_enable_level_01();
    v_enable_level_02();

    voidc_enable_intrinsics_derive();
    voidc_enable_local_objects();
    voidc_enable_heap_objects();
    voidc_enable_global_objects();
    voidc_enable_coercions();
    voidc_enable_namespaces();
    voidc_enable_generics_etc();
    voidc_enable_generating_ast();
    voidc_enable_macros();
}

//---------------------------------------------------------------------
{   q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("list_q", q_ref, q("my.list"));
}


//=====================================================================
{   voidc_unit_begin_module("macros_mod_test_module"); }


//---------------------------------------------------------------------
export
namespace my {


//---------------------------------------------------------------------
list = v_object_intrinsic("my.list");

//---------------------------------------------------------------------
private
list_intrinsic: (*void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    args = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    arg0 = v_list_get_item(args, 0);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(arg0, vis);

    elt = (v_get_result_value() : *v_type_t);

    arg = v_type_generic_type_arg(elt);

    typ = v_generic_type(list_q, &arg, 1);

    v_set_result_type(v_find_type("v_static_type_t"));
    v_set_result_value((typ: LLVMValueRef));
}


//---------------------------------------------------------------------
private
set_implementation_type_intrinsic: (*void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    args = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    arg0 = v_list_get_item(args, 0);
    arg1 = v_list_get_item(args, 1);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(arg0, vis);

    type = (v_get_result_value() : *v_type_t);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(arg1, vis);

    impl = (v_get_result_value() : *v_type_t);

    v_type_generic_set_implementation_type(type, impl);
}


//---------------------------------------------------------------------
private
list_op_braces_intrinsic: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t,
                           arg_ptrs: **v_ast_expr_t, arg_count: unsigned
                          ) ~> void
{
//printf("list_op_braces_intrinsic: start\n");
//defer printf("list_op_braces_intrinsic: stop\n");

    tr: &*v_type_t := v_get_result_type();

    is_reference = v_type_is_reference(tr);

    addr_sp: &unsigned := v_undef();

    if (is_reference)
    {
        addr_sp := v_type_refptr_get_address_space(tr);         //- Sic!
        tr      := v_type_refptr_get_element_type(tr);          //- Sic!
    }

    vr = v_obtain_special_result_value(vis, tr);

    list: &v_ast_stmt_list_t := {};

    {   stmt: &v_ast_stmt_t := {'stmt'  my_any: &v_std_any_t := {};  'stmt'};

        v_make_list(&list, &stmt);
    }

    {   stmt: &v_ast_generic_list_t :=          //- WTF !?!?!?!?!?!?!
        {'stmt'

            #define my_step: (lst, v)
            {'stmt_list'

                v_std_any_set_value(&my_any, v);

                v_list_append(lst, lst, &my_any);

            'stmt_list'}

        'stmt'};

        v_list_append(&list, &list, (&stmt: *v_ast_stmt_t));
    }

    expr: &v_ast_expr_t[4] := {};

    v_ast_make_expr_compiled(expr+0, v_pointer_type(v_util_list_t, 0), vr);

    stmt: &v_ast_stmt_t := {};

    my_step_q = v_quark_from_string("my_step");

    v_ast_make_expr_compiled(expr+2, v_find_type("v_static_type_t"), (aux: LLVMValueRef));      //- Sic !!!

    v_ast_make_expr_identifier(expr+3, "v_typed");

    elst: &v_ast_expr_list_t := {};

    for (i: &int := 0; i < arg_count; ++i)
    {
        v_make_list(&elst, expr+2);

        v_list_append(&elst, &elst, arg_ptrs[i]);

        v_ast_make_expr_call(expr+1, expr+3, &elst);

        v_ast_make_stmt_call(&stmt, 0, my_step_q, expr, 2);

        v_list_append(&list, &list, &stmt);
    }

    v_ast_make_stmt_block(&stmt, &list, false);

    v_ast_accept_visitor(&stmt, vis);

    if (is_reference) v_set_result_type(v_reference_type(tr, addr_sp));
    else              v_set_result_type(tr);

    v_set_result_value(vr);
}

//---------------------------------------------------------------------
private
register_list_op_braces_intrinsic: (*void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    args = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    arg0 = v_list_get_item(args, 0);        //- Type

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(arg0, vis);

    elt = (v_get_result_value() : *v_type_t);

    sstr: &v_std_string_t := {};

    v_std_string_set(&sstr, "my.list_op_braces-");

    voidc_internal_std_string_append_type(&sstr, elt);

    iname = v_std_string_get(&sstr);

    arg = v_type_generic_type_arg(elt);

    typ = v_generic_type(list_q, &arg, 1);

    v_add_overload("v.op_braces", typ, iname);

    v_add_intrinsic(iname, list_op_braces_intrinsic, elt);      //- Sic!
}


//---------------------------------------------------------------------
list_ns = v_object_intrinsic("list.namespace");

//---------------------------------------------------------------------
private
list_ns_intrinsic: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    args = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));

    arg0 = v_list_get_item(args, 0);        //- Type
    arg1 = v_list_get_item(args, 1);        //- Tag

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(arg0, vis);

    elt = (v_get_result_value() : *v_type_t);

    tag = v_ast_expr_identifier_get_name(arg1);

    sstr: &v_std_string_t := {};

    v_std_string_set(&sstr, "list_ns-");

    v_std_string_append(&sstr, tag);
    v_std_string_append(&sstr, "-");

    voidc_internal_std_string_append_type(&sstr, elt);

    ns_name = v_quark_from_string(v_std_string_get(&sstr));

    ns = (aux: *v_namespace_t);

    if (a = v_map_find(&ns->map, (ns_name: intptr_t)))
    {
        q = v_std_any_get_value(v_quark_t, a);

        t: &*v_type_t    := v_undef();
        v: &LLVMValueRef := v_undef();

        v_find_constant_q(q, &t, &v);

        v_set_result_type(t);
        v_set_result_value(v);
    }
    else
    {
        v_set_result_type(v_void_type());                   //- Sic !?!
        v_set_result_value((ns_name: LLVMValueRef));        //- Sic !?!
    }
}


//---------------------------------------------------------------------
#define instantiate_list: (T)
{'unit_defn_list'

  namespace my
  {
    private
    namespace list_ns(T, detail)
    {
        alwaysinline
        (_.impl): (s: &list(T)) ~> &v_util_list_t  =  *(&s : *v_util_list_t);
    }

    #do (v_set_implementation_type(list(T), v_util_list_t))

    //-------------------------------------------------------------
    inlinehint
    (v_initialize(_)): (sp: *list(T), N: size_t) ~> void
    {
        for (i: &int := 0; i < N; ++i)
        {
            lst = &sp[i].impl;

            v_initialize(lst);

            v_make_list_nil(lst);
        }
    }

    alwaysinline
    (v_terminate(_)): (sp: *list(T), N: size_t) ~> void
    {
        v_terminate(&sp->impl, N);
    }

    alwaysinline
    (v_copy(_)): (dst: *list(T), src: *const list(T), N: size_t) ~> void
    {
        v_copy(&dst->impl, &src->impl, N);
    }

    #do (register_list_op_braces(T))

    //-------------------------------------------------------------
    inlinehint
    (_[]): (sp: &list(T), i: size_t) ~> T
    {
        a = v_list_get_item(&sp.impl, i);
        v_assert(a);

        v_return(v_std_any_get_value(T, a));
    }

    alwaysinline
    (_[]): (sp: list(T), i: size_t) ~> T  =  (*&sp)[i];

    inlinehint
    (_<<_): (sp: &list(T), v: T) ~> &list(T)  =
    {
        a: &v_std_any_t := {};

        v_std_any_set_value(&a, v);

        lst = &sp.impl;

        v_list_append(lst, lst, &a);

        sp
    };

    inlinehint
    (_<<_): (sp: list(T), v: T) ~> list(T)
    {
        a: &v_std_any_t := {};

        v_std_any_set_value(&a, v);

        v_list_append(&v_get_return_value().impl, &sp.impl, &a);
    }

    alwaysinline
    (_.size): (sp: &list(T)) ~> size_t  =  v_list_get_size(&sp.impl);

    alwaysinline
    (_.size): (sp: list(T)) ~> size_t  =  (&sp)->size;

  }   //- namespace my

'unit_defn_list'}


//---------------------------------------------------------------------
enable_list_effort: (*void) ~> void
{
    v_add_intrinsic("my.list", list_intrinsic, 0);

    v_add_intrinsic("v_set_implementation_type", set_implementation_type_intrinsic, 0);

    v_add_intrinsic("register_list_op_braces", register_list_op_braces_intrinsic, 0);

    v_add_intrinsic("list.namespace", list_ns_intrinsic, v_find_constant_value("my"));
}


//---------------------------------------------------------------------
}   //- namespace my


//=====================================================================
{   voidc_unit_end_module(); }


//---------------------------------------------------------------------
{   v_export_effort(my.enable_list_effort, 0); }


