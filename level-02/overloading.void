//---------------------------------------------------------------------
//- Copyright (C) 2020-2024 Dmitry Borodkin <borodkin.dn@gmail.com>
//- SDPX-License-Identifier: LGPL-3.0-or-later
//---------------------------------------------------------------------
{   voidc_guard_target("overloading.void  must be imported into the voidc target only!");

    v_import("level-00");
    v_import("level-01");

    v_import("llvm-c/Core.void");

    v_import("unit_module.void");
    v_import("loops_etc.void");
    v_import("aggregates.void");

//  v_import("printf.void");
}

{   v_enable_level_01();

    voidc_enable_loops_etc();
    voidc_enable_aggregates();
}


//---------------------------------------------------------------------
{   q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("expr_call_q",       q_ref, q("expr_call"));
    v_add_symbol("expr_identifier_q", q_ref, q("expr_identifier"));

    v_add_symbol("q_op_postfix_call",  q_ref, q("v.op_postfix_call"));
    v_add_symbol("q_op_postfix_index", q_ref, q("v.op_postfix_index"));

    v_add_symbol("expr_compiled_q",     q_ref, q("expr_compiled"));
    v_add_symbol("expr_compile_hook_q", q_ref, q("expr_compile_hook"));

    v_add_symbol("voidc_overloading_context_q", q_ref, q("voidc.overloading_context"));

    v_add_symbol("q_op_infix_lt", q_ref, q("v.op_infix_lt"));
    v_add_symbol("q_op_infix_le", q_ref, q("v.op_infix_le"));
    v_add_symbol("q_op_infix_gt", q_ref, q("v.op_infix_gt"));
    v_add_symbol("q_op_infix_ge", q_ref, q("v.op_infix_ge"));
    v_add_symbol("q_op_infix_eq", q_ref, q("v.op_infix_eq"));
    v_add_symbol("q_op_infix_ne", q_ref, q("v.op_infix_ne"));

    v_add_symbol("voidc_incomplete_array_type_tag", q_ref, q("voidc.incomplete_array_type_tag"));
}


//=====================================================================
{   voidc_unit_begin_module("op_table_module"); }


//---------------------------------------------------------------------
opk_assign   = 0;
opk_logical  = 1;
opk_relation = 2;
opk_binary   = 3;
opk_unary    = 4;

op_table_item_t = v_struct("struct.v_op_table_item",
{
    *const char,    //- 0 - Name
    int,            //- 1 - Kind
    v_quark_t,      //- 2 - Quark (left)
    v_quark_t,      //- 3 - Quark (right)

    *void,          //- 4 - helper function (if any)
    *void           //- 5 - aux for helper  (if any)
});

op_table: &op_table_item_t[] :=
{
    {"v.op_infix_assign",      opk_assign,   0,0, 0,                                 (false: *void) },
    {"v.op_infix_add_assign",  opk_assign,   0,0, voidc_internal_compile_add_helper, (true:  *void) },
    {"v.op_infix_sub_assign",  opk_assign,   0,0, voidc_internal_compile_sub_helper, (true:  *void) },
    {"v.op_infix_mul_assign",  opk_assign,   0,0, voidc_internal_compile_mul_helper, (false: *void) },
    {"v.op_infix_div_assign",  opk_assign,   0,0, voidc_internal_compile_div_helper, (false: *void) },
    {"v.op_infix_rem_assign",  opk_assign,   0,0, voidc_internal_compile_rem_helper, (false: *void) },
    {"v.op_infix_shl_assign",  opk_assign,   0,0, voidc_internal_compile_shl_helper, (false: *void) },
    {"v.op_infix_shr_assign",  opk_assign,   0,0, voidc_internal_compile_shr_helper, (false: *void) },
    {"v.op_infix_and_assign",  opk_assign,   0,0, voidc_internal_compile_and_helper, (false: *void) },
    {"v.op_infix_xor_assign",  opk_assign,   0,0, voidc_internal_compile_xor_helper, (false: *void) },
    {"v.op_infix_or_assign",   opk_assign,   0,0, voidc_internal_compile_or_helper,  (false: *void) },

//  {"v.op_infix_to",          opk_binary    },          //- ?!?!?!?!?!?!?!?

    {"v.op_infix_logical_or",  opk_logical   },
    {"v.op_infix_logical_and", opk_logical   },

    {"v.op_infix_lt",          opk_relation, 0,0, voidc_internal_compile_op_relation_helper, voidc_internal_compile_lt_helper },
    {"v.op_infix_le",          opk_relation, 0,0, voidc_internal_compile_op_relation_helper, voidc_internal_compile_le_helper },
    {"v.op_infix_gt",          opk_relation, 0,0, voidc_internal_compile_op_relation_helper, voidc_internal_compile_gt_helper },
    {"v.op_infix_ge",          opk_relation, 0,0, voidc_internal_compile_op_relation_helper, voidc_internal_compile_ge_helper },
    {"v.op_infix_eq",          opk_relation, 0,0, voidc_internal_compile_op_relation_helper, voidc_internal_compile_eq_helper },
    {"v.op_infix_ne",          opk_relation, 0,0, voidc_internal_compile_op_relation_helper, voidc_internal_compile_ne_helper },

    {"v.op_infix_or",          opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_or_helper },
    {"v.op_infix_xor",         opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_xor_helper },
    {"v.op_infix_and",         opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_and_helper },

    {"v.op_infix_shl",         opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_shl_helper },
    {"v.op_infix_shr",         opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_shr_helper },
    {"v.op_infix_add",         opk_binary,   0,0, voidc_internal_compile_op_binary_addsub_helper, voidc_internal_compile_infix_add_helper },
    {"v.op_infix_sub",         opk_binary,   0,0, voidc_internal_compile_op_binary_addsub_helper, voidc_internal_compile_infix_sub_helper },
    {"v.op_infix_mul",         opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_mul_helper },
    {"v.op_infix_div",         opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_div_helper },
    {"v.op_infix_rem",         opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_rem_helper },

    {"v.op_prefix_inc",        opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_inc },
    {"v.op_prefix_dec",        opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_dec },
    {"v.op_prefix_plus",       opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_plus },
    {"v.op_prefix_minus",      opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_minus },
    {"v.op_prefix_star",       opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_star },
    {"v.op_prefix_amp",        opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_amp },
    {"v.op_prefix_bang",       opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_bang },
    {"v.op_prefix_tilde",      opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_tilde},

    {"v.op_prefix_const",      opk_unary,    0,0, 0 },          //- ...
    {"v.op_prefix_volatile",   opk_unary,    0,0, 0 },          //- ...

    {"v.op_postfix_inc",       opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_postfix_inc },
    {"v.op_postfix_dec",       opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_postfix_dec },
};

//---------------------------------------------------------------------
{   t = v_find_symbol_type("op_table");

    n = v_type_array_get_length(v_type_refptr_get_element_type(t));

    int_ = v_type_get_llvm_type(v_find_type("int"));

    v_add_constant("op_table_length", int, LLVMConstInt(int_, n, 0));
}

//---------------------------------------------------------------------
op_table_ctor: () ~> void
{
    sstr = v_alloca(v_std_string_t);
    v_initialize(sstr);
    defer v_terminate(sstr);

    int_ = v_type_get_llvm_type(int);

    for (i: &int := 0; i < op_table_length; ++i)
    {
        name = op_table[i][0];

        op_table[i][2] := v_quark_from_string(name);

        if (k = op_table[i][1],  k == opk_binary  ||  k == opk_relation)
        {
            v_std_string_set(sstr, name);

            v_std_string_append(sstr, ".right");

            op_table[i][3] := v_quark_from_string(v_std_string_get(sstr));
        }

        v_std_string_set(sstr, "id");

        v_std_string_append(sstr, name+4);          //- Skip "v.op"

        v_add_constant(v_std_string_get(sstr), int, LLVMConstInt(int_, i, 0));
    }
}


//=====================================================================
{   voidc_unit_end_module(); }


//---------------------------------------------------------------------
{   op_table_ctor();
}


//=====================================================================
{   voidc_unit_begin_module("overloading_module"); }


//---------------------------------------------------------------------
//- ast_expr_compiled_t ...
//---------------------------------------------------------------------
private
ast_expr_compiled_t = v_struct("struct.v_ast_expr_compiled",
{
    *v_type_t,          //- 0 - compiled type
    LLVMValueRef,       //- 1 - compiled value
});

{   sz_v = LLVMSizeOf(v_type_get_llvm_type(ast_expr_compiled_t));

    v_add_constant("ast_expr_compiled_size", size_t, sz_v);
}

ast_expr_compiled_vtable: &v_ast_generic_vtable := {0, 0};

//---------------------------------------------------------------------
export
v_ast_make_expr_compiled: (expr: *v_ast_expr_t, t: *v_type_t, v: LLVMValueRef) ~> void
{
    v_ast_make_generic(expr, &ast_expr_compiled_vtable, ast_expr_compiled_size);

    void_obj = v_ast_generic_get_object(expr);

    obj = *(void_obj: *ast_expr_compiled_t);

    obj[0] := t;
    obj[1] := v;
}

//---------------------------------------------------------------------
private
compile_expr_compiled: (*void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    void_obj = v_ast_generic_get_object((self: *v_ast_expr_t));

    obj = *(void_obj: *ast_expr_compiled_t);

    v_adopt_result(obj[0], obj[1]);
}


//---------------------------------------------------------------------
//- ast_expr_compile_hook_t ...
//---------------------------------------------------------------------
private
ast_expr_compile_hook_t = v_struct("struct.v_ast_expr_compile_hook",
{
    v_ast_expr_t,       //- 0 - expr  to compile

    **v_type_t,         //- 1 - type  to "hook"
    *LLVMValueRef,      //- 2 - value to "hook"
});

{   sz_v = LLVMSizeOf(v_type_get_llvm_type(ast_expr_compile_hook_t));

    v_add_constant("ast_expr_compile_hook_size", size_t, sz_v);
}

private
ast_expr_compile_hook_init: (void_obj: *void) ~> void
{
    obj = *(void_obj: *ast_expr_compile_hook_t);

    v_initialize(&obj[0]);
}

private
ast_expr_compile_hook_term: (void_obj: *void) ~> void
{
    obj = *(void_obj: *ast_expr_compile_hook_t);

    v_terminate(&obj[0]);
}

ast_expr_compile_hook_vtable: &v_ast_generic_vtable :=
{
    ast_expr_compile_hook_init,
    ast_expr_compile_hook_term,
};

//---------------------------------------------------------------------
export
v_ast_make_expr_compile_hook: (ret: *v_ast_expr_t, expr: *v_ast_expr_t, t: &*v_type_t, v: &LLVMValueRef) ~> void
{
    etmp = v_alloca(v_ast_expr_t);
    v_initialize(etmp);
    defer v_terminate(etmp);

    v_ast_make_generic(etmp, &ast_expr_compile_hook_vtable, ast_expr_compile_hook_size);

    void_obj = v_ast_generic_get_object(etmp);

    obj = *(void_obj: *ast_expr_compile_hook_t);

    v_copy(&obj[0], expr);

    obj[1] := &t;
    obj[2] := &v;

    v_copy(ret, etmp);
}

//---------------------------------------------------------------------
private
compile_expr_compile_hook: (*void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~> void
{
    void_obj = v_ast_generic_get_object((self: *v_ast_expr_t));

    obj = *(void_obj: *ast_expr_compile_hook_t);

    expr  = &obj[0];
    type  = *obj[1];
    value = *obj[2];

    v_ast_accept_visitor((expr : v_ast_base_ptr), vis);

    type  := v_get_result_type();
    value := v_get_result_value();
}


//---------------------------------------------------------------------
//- overloading_ctx_t ...
//---------------------------------------------------------------------
export
voidc_llvm_build_call_helper_t = v_struct(
{
    *((*void, *voidc_visitor_t, *v_ast_base_t, *v_type_t, LLVMValueRef, **v_ast_expr_t, unsigned) ~> void),
    *void
});

export
voidc_compile_expr_call_helper_t = v_struct(
{
    *((*void, *voidc_visitor_t, *v_ast_base_t, *v_ast_expr_list_t, *v_type_t, LLVMValueRef) ~> void),
    *void
});

export
voidc_compile_op_assign_helper_t = v_struct(
{
    *((*void, *voidc_visitor_t, *v_ast_base_t, *v_type_t, LLVMValueRef, int, v_quark_t, *v_ast_expr_t) ~> void),
    *void
});

export
voidc_compile_op_binary_helper_t = v_struct(
{
    *((*void, *voidc_visitor_t, *v_ast_base_t, *v_type_t, LLVMValueRef, int, v_quark_t, v_quark_t, *v_ast_expr_t) ~> void),
    *void
});

export
voidc_compile_op_relation_helper_t = v_struct(
{
    *((*void, *voidc_visitor_t, **v_ast_expr_t, int, v_quark_t, v_quark_t,
       *v_type_t, LLVMValueRef, &*v_type_t, &LLVMValueRef) ~> LLVMValueRef),

    *void
});

export
voidc_compile_op_unary_helper_t = v_struct(
{
    *((*void, *voidc_visitor_t, *v_ast_base_t, *v_type_t, LLVMValueRef, int, v_quark_t) ~> void),
    *void
});

export
voidc_compile_op_postfix_index_helper_t = v_struct(
{
    *((*void, *voidc_visitor_t, *v_ast_base_t, &*v_type_t, &LLVMValueRef, **v_ast_expr_list_t, int) ~> bool),
    *void
});


//---------------------------------------------------------------------
private
overloading_ctx_t = v_struct("struct.v_overloading_ctx",
{
    v_struct({*v_struct("struct.v_overloading_ctx"), int})[op_table_length],        //- 0

    voidc_llvm_build_call_helper_t,                     //- 1
    voidc_compile_expr_call_helper_t,                   //- 2
    voidc_compile_op_assign_helper_t,                   //- 3
    voidc_compile_op_binary_helper_t,                   //- 4
    voidc_compile_op_relation_helper_t,                 //- 5
    voidc_compile_op_unary_helper_t,                    //- 6
    voidc_compile_op_postfix_index_helper_t,            //- 7

});


//---------------------------------------------------------------------
private
add_overloading_context: (ctx: *overloading_ctx_t) ~> void
{
    any = v_alloca(v_std_any_t);
    v_initialize(any);
    defer v_terminate(any);

    v_std_any_set_value(any, v_cast(ctx, intptr_t));

    v_add_property_q(voidc_overloading_context_q, any);
}

//---------------------------------------------------------------------
private
get_overloading_context: () ~> *overloading_ctx_t
{
    any = v_get_property_q(voidc_overloading_context_q);

    ctx = (v_std_any_get_value(intptr_t, any) : *overloading_ctx_t);

    v_return(ctx);
}


//---------------------------------------------------------------------
export
voidc_overloading_context_get_llvm_build_call_helper: () ~> &voidc_llvm_build_call_helper_t
{
    ctx = *get_overloading_context();

    v_return(ctx[1]);
}

//---------------------------------------------------------------------
export
voidc_overloading_context_get_compile_expr_call_helper: () ~> &voidc_compile_expr_call_helper_t
{
    ctx = *get_overloading_context();

    v_return(ctx[2]);
}

//---------------------------------------------------------------------
export
voidc_overloading_context_get_compile_op_assign_helper: () ~> &voidc_compile_op_assign_helper_t
{
    ctx = *get_overloading_context();

    v_return(ctx[3]);
}

//---------------------------------------------------------------------
export
voidc_overloading_context_get_compile_op_binary_helper: () ~> &voidc_compile_op_binary_helper_t
{
    ctx = *get_overloading_context();

    v_return(ctx[4]);
}

//---------------------------------------------------------------------
export
voidc_overloading_context_get_compile_op_relation_helper: () ~> &voidc_compile_op_relation_helper_t
{
    ctx = *get_overloading_context();

    v_return(ctx[5]);
}

//---------------------------------------------------------------------
export
voidc_overloading_context_get_compile_op_unary_helper: () ~> &voidc_compile_op_unary_helper_t
{
    ctx = *get_overloading_context();

    v_return(ctx[6]);
}

//---------------------------------------------------------------------
export
voidc_overloading_context_get_compile_op_postfix_index_helper: () ~> &voidc_compile_op_postfix_index_helper_t
{
    ctx = *get_overloading_context();

    v_return(ctx[7]);
}



//---------------------------------------------------------------------
//- llvm_build_call_helper ...
//---------------------------------------------------------------------
private
llvm_build_call_helper: (*void, vis: *voidc_visitor_t, self: *v_ast_base_t,
                         ft: *v_type_t, fv: LLVMValueRef,
                         arg_ptrs: **v_ast_expr_t, arg_count: unsigned
                        ) ~> void
{
    par_count = v_type_function_get_param_count(ft);
    par_types = v_type_function_get_param_types(ft);

    values = v_malloc(LLVMValueRef, arg_count);
    defer v_free(values);

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    for (i: &unsigned := 0; i < arg_count; ++i)
    {
        if (i < par_count)  v_set_result_type(par_types[i]);
        else                v_set_result_type(UNREFERENCE_TAG);

        v_set_result_value(0);

        v_ast_accept_visitor((arg_ptrs[i]: v_ast_base_ptr), vis);

        values[i] := v_get_result_value();
    }

    builder = v_target_get_builder();

    ft_ = v_type_get_llvm_type(ft);

    vr = LLVMBuildCall2(builder, ft_, fv, values, arg_count, "");

    tr = v_type_function_get_return_type(ft);

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    v_adopt_result(tr, vr);
}


//---------------------------------------------------------------------
intrinsic_p1_t = (aux: *void, vis: voidc_visitor_ptr,
                  self: v_ast_base_ptr,
                  t0: v_type_ptr, v0: LLVMValueRef
                 ) ~> void;

intrinsic_p2_t = (aux: *void, vis: voidc_visitor_ptr,
                  self: v_ast_base_ptr,
                  t0: v_type_ptr, v0: LLVMValueRef,
                  t1: v_type_ptr, v1: LLVMValueRef
                 ) ~> void;


//---------------------------------------------------------------------
private
op_assign_helper: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t,
                   t0: *v_type_t, v0: LLVMValueRef, id: int, q: v_quark_t,
                   rhs: *v_ast_expr_t) ~> void
{
    ttag = v_get_result_type();
    vtag = v_get_result_value();

    ctx = *(aux: *overloading_ctx_t);

    op_data = op_table[id];

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    if (v_util_lookup_function_dict(t0, q, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        if (fun = (void_fun: *intrinsic_p1_t))
        {
            v_set_result_type(ttag);
            v_set_result_value(vtag);

            fun(void_aux, vis, self, t0, v0);
        }
        else
        {
            expr = v_alloca(v_ast_expr_t);
            v_initialize(expr);
            defer v_terminate(expr);

            v_ast_make_expr_compiled(expr, t0, v0);

            arg_ptrs = v_alloca(v_ast_expr_ptr, 2);

            arg_ptrs[0] := expr;            //- "Place", compiled
            arg_ptrs[1] := rhs;             //- "Value"

            v_set_result_type(ttag);
            v_set_result_value(vtag);

            v_handle(&ctx[1], vis, self, ft, fv, arg_ptrs, 2);          //- llvm_build_call...
        }

        v_return();
    }

    //- Default treatment...

    expr = v_alloca(v_ast_expr_t);
    v_initialize(expr);
    defer v_terminate(expr);

    v_ast_make_expr_compiled(expr, t0, v0);

    ast0 = expr;                //- "Place", compiled
    ast1 = rhs;                 //- "Value"

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    compile = (op_data[4] : *((v_type_ptr, LLVMValueRef, LLVMValueRef) ~> LLVMValueRef));

    flag = (op_data[5] : bool);

    voidc_internal_compile_op_assign_helper(vis, ast0, ast1, compile, flag);
}

//---------------------------------------------------------------------
private
op_assign_intrinsic: (aux: *void, vis: voidc_visitor_ptr,
                      self: v_ast_base_ptr) ~> void
{
    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    lhs = v_list_get_item(args, 1);             //- "Place"

    v_ast_accept_visitor((lhs : v_ast_base_ptr), vis);

    t0 = v_get_result_type();
    v0 = v_get_result_value();

    aux = *(aux: *v_struct({ *overloading_ctx_t, int }));

    ctx = *aux[0];

    id = aux[1];

    op_data = op_table[id];

    q = op_data[2];     //- Quark

    rhs = v_list_get_item(args, 2);             //- "Value"

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    v_handle(&ctx[3], vis, self, t0, v0, id, q, rhs);               //- compile_op_assign...
}


//---------------------------------------------------------------------
private
op_binary_helper: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t,
                   t0: *v_type_t, v0: LLVMValueRef, id: int, q0: v_quark_t, q1: v_quark_t,
                   rhs: *v_ast_expr_t) ~> void
{
    ttag = v_get_result_type();
    vtag = v_get_result_value();

    ctx = *(aux: *overloading_ctx_t);

    op_data = op_table[id];

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    if (v_util_lookup_function_dict(t0, q0, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        if (fun = (void_fun: *intrinsic_p1_t))
        {
            v_set_result_type(ttag);
            v_set_result_value(vtag);

            fun(void_aux, vis, self, t0, v0);
        }
        else
        {
            expr = v_alloca(v_ast_expr_t);
            v_initialize(expr);
            defer v_terminate(expr);

            v_ast_make_expr_compiled(expr, t0, v0);

            arg_ptrs = v_alloca(v_ast_expr_ptr, 2);

            arg_ptrs[0] := expr;                //- "LHS", compiled
            arg_ptrs[1] := rhs;                 //- "RHS"

            v_set_result_type(ttag);
            v_set_result_value(vtag);

            v_handle(&ctx[1], vis, self, ft, fv, arg_ptrs, 2);          //- llvm_build_call...
        }

        v_return();
    }

    //- Second argument

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor((rhs : v_ast_base_ptr), vis);

    t1 = v_get_result_type();
    v1 = v_get_result_value();

    if (v_util_lookup_function_dict(t1, q1, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        if (fun = (void_fun: *intrinsic_p2_t))
        {
            v_set_result_type(ttag);
            v_set_result_value(vtag);

            fun(void_aux, vis, self, t0, v0, t1, v1);
        }
        else
        {
            expr = v_alloca(v_ast_expr_t, 2);
            v_initialize(expr, 2);
            defer v_terminate(expr, 2);

            v_ast_make_expr_compiled(expr+0, t0, v0);
            v_ast_make_expr_compiled(expr+1, t1, v1);

            arg_ptrs = v_alloca(v_ast_expr_ptr, 2);

            arg_ptrs[0] := expr+0;                          //- "LHS", compiled
            arg_ptrs[1] := expr+1;                          //- "RHS", compiled

            v_set_result_type(ttag);
            v_set_result_value(vtag);

            v_handle(&ctx[1], vis, self, ft, fv, arg_ptrs, 2);          //- llvm_build_call...
        }

        v_return();
    }

    //- Default treatment...

    expr = v_alloca(v_ast_expr_t, 2);
    v_initialize(expr, 2);
    defer v_terminate(expr, 2);

    v_ast_make_expr_compiled(expr+0, t0, v0);
    v_ast_make_expr_compiled(expr+1, t1, v1);

    v_set_result_type(ttag);
    v_set_result_value(vtag);


    helper = (op_data[4] : *((*voidc_visitor_t, *v_ast_expr_t, *v_ast_expr_t, *void) ~> void));

    compile = op_data[5];

    helper(vis, expr+0, expr+1, compile);
}

//---------------------------------------------------------------------
private
op_binary_intrinsic: (aux: *void, vis: voidc_visitor_ptr,
                      self: v_ast_base_ptr) ~> void
{
    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    //- First argument

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    lhs = v_list_get_item(args, 1);

    v_ast_accept_visitor((lhs : v_ast_base_ptr), vis);

    t0 = v_get_result_type();
    v0 = v_get_result_value();

    aux = *(aux: *v_struct({ *overloading_ctx_t, int }));

    ctx = *aux[0];

    id = aux[1];

    op_data = op_table[id];

    q0 = op_data[2];        //- Quark (left)
    q1 = op_data[3];        //- Quark (right)

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    rhs = v_list_get_item(args, 2);

    v_handle(&ctx[4], vis, self, t0, v0, id, q0, q1, rhs);          //- compile_op_binary...
}


//---------------------------------------------------------------------
private
op_relation_helper: (aux: *void, vis: *voidc_visitor_t,
                     ast: **v_ast_expr_t,
                     id: int, q0: v_quark_t, q1: v_quark_t,
                     t0:  *v_type_t, v0:  LLVMValueRef,
                     t1: &*v_type_t, v1: &LLVMValueRef
                    ) ~> LLVMValueRef
{
    ttag = v_get_result_type();
    vtag = v_get_result_value();

    ctx = *(aux: *overloading_ctx_t);

    op_data = op_table[id];

    r: &LLVMValueRef := 0;

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    if (v_util_lookup_function_dict(t0, q0, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        intrinsic_p12_t = (aux: *void, vis: *voidc_visitor_t,
                           ast: **v_ast_expr_t,
                           t0:  *v_type_t, v0:  LLVMValueRef,
                           t1: &*v_type_t, v1: &LLVMValueRef
                          ) ~> void;

        if (fun = (void_fun: *intrinsic_p12_t))
        {
            v_set_result_type(ttag);        //- Sic !?!
            v_set_result_value(vtag);       //- Sic !?!

            fun(void_aux, vis, ast, t0, v0, t1, v1);                        //- Without "self" !?!?!?!?!
        }
        else
        {
            expr = v_alloca(v_ast_expr_t, 2);
            v_initialize(expr, 2);
            defer v_terminate(expr, 2);

            v_ast_make_expr_compiled(expr+0, t0, v0);

            v_ast_make_expr_compile_hook(expr+1, ast[1], t1, v1);

            arg_ptrs = v_alloca(v_ast_expr_ptr, 2);

            arg_ptrs[0] := expr+0;                          //- "LHS", compiled
            arg_ptrs[1] := expr+1;                          //- "RHS", compile hook

            v_set_result_type(ttag);
            v_set_result_value(vtag);

            v_handle(&ctx[1], vis, 0, ft, fv, arg_ptrs, 2);                 //- llvm_build_call... (without "self" !?)
        }

        r := v_get_result_value();
    }
    else
    {
        //- Second argument

        v_set_result_type(INVIOLABLE_TAG);
        v_set_result_value(0);

        v_ast_accept_visitor((ast[1] : v_ast_base_ptr), vis);

        t1 := v_get_result_type();
        v1 := v_get_result_value();

        if (v_util_lookup_function_dict(t1, q1, void_fun, void_aux, ft, fv))
        {
            //- Got overloading!

            intrinsic_p22_t = (aux: *void, vis: *voidc_visitor_t,
                               ast: **v_ast_expr_t,
                               t0: *v_type_t, v0: LLVMValueRef,
                               t1: *v_type_t, v1: LLVMValueRef
                              ) ~> void;

            if (fun = (void_fun: *intrinsic_p22_t))
            {
                v_set_result_type(ttag);        //- Sic !?!
                v_set_result_value(vtag);       //- Sic !?!

                fun(void_aux, vis, ast, t0, v0, t1, v1);                        //- Without "self" !?!?!?!?!
            }
            else
            {
                expr = v_alloca(v_ast_expr_t, 2);
                v_initialize(expr, 2);
                defer v_terminate(expr, 2);

                v_ast_make_expr_compiled(expr+0, t0, v0);
                v_ast_make_expr_compiled(expr+1, t1, v1);

                arg_ptrs = v_alloca(v_ast_expr_ptr, 2);

                arg_ptrs[0] := expr+0;                          //- "LHS", compiled
                arg_ptrs[1] := expr+1;                          //- "RHS", compiled

                v_set_result_type(ttag);
                v_set_result_value(vtag);

                v_handle(&ctx[1], vis, 0, ft, fv, arg_ptrs, 2);                 //- llvm_build_call... (without "self" !?)
            }

            r := v_get_result_value();
        }
    }

    if (!r)
    {
        //- Default treatment...

        expr = v_alloca(v_ast_expr_t);
        v_initialize(expr);
        defer v_terminate(expr);

        v_ast_make_expr_compiled(expr, t1, v1);

        helper = (op_data[4] : *((*voidc_visitor_t, *void, *v_type_t, LLVMValueRef,
                                  *v_ast_expr_t, &*v_type_t, &LLVMValueRef) ~> LLVMValueRef));

        compile = op_data[5];

        typ: &v_type_ptr   := t1;
        val: &LLVMValueRef := v1;

        r := helper(vis, compile, t0, v0, expr, typ, val);
    }

    v_return(r);
}

//---------------------------------------------------------------------
private
check_relation: (arg: v_ast_expr_ptr, lhs: *v_ast_expr_ptr, rhs: *v_ast_expr_ptr) ~> int
{
    get_tag = v_ast_base_get_visitor_method_tag;

    if (get_tag((arg: v_ast_base_ptr)) != expr_call_q)  v_return(0);

    etmp = v_ast_expr_call_get_fun_expr(arg);

    if (get_tag((etmp: v_ast_base_ptr)) != expr_identifier_q)  v_return(0);

    qname = v_ast_expr_identifier_get_name_q(etmp);

    rk: &int := v_undef();

    block
    {
        if (qname == q_op_infix_eq)  { rk := id_infix_eq; v_break(); }
        if (qname == q_op_infix_ne)  { rk := id_infix_ne; v_break(); }
        if (qname == q_op_infix_lt)  { rk := id_infix_lt; v_break(); }
        if (qname == q_op_infix_le)  { rk := id_infix_le; v_break(); }
        if (qname == q_op_infix_gt)  { rk := id_infix_gt; v_break(); }
        if (qname == q_op_infix_ge)  { rk := id_infix_ge; v_break(); }

        v_return(0);
    }

    if (lhs) ;
    else if (rhs) ;
    else
    {
        v_return(rk);
    }

    lst = v_ast_expr_call_get_arg_list(arg);

    if (lhs)  *lhs := v_list_get_item(lst, 1);
    if (rhs)  *rhs := v_list_get_item(lst, 2);

    v_return(rk);
}

//---------------------------------------------------------------------
private
op_relation_intrinsic: (aux: *void, vis: voidc_visitor_ptr,
                        self: v_ast_base_ptr) ~> void
{
    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    N: &int := 2;

    {   ast: &v_ast_expr_ptr := v_list_get_item(args, 1);

        while(check_relation(ast, &ast, 0)) ++N;
    }

    ast = v_malloc(v_ast_expr_ptr, N);
    defer v_free(ast);

    Nm1 = N - 1;

    rel = v_malloc(int, Nm1);
    defer v_free(rel);

    aux = *(aux: *v_struct({ *overloading_ctx_t, int }));

    ctx = *aux[0];

    id = aux[1];

    {   i = N - 2;

        ast_i: &*v_ast_expr_ptr := ast + i;
        rel_i: &*int            := rel + i;

        ast_i[0] := v_list_get_item(args, 1);
        ast_i[1] := v_list_get_item(args, 2);

        *rel_i := id;

        while(ast_i1 = ast_i-1, rk = check_relation(*ast_i, ast_i1, ast_i))
        {
            ast_i := ast_i1;
            rel_i := rel_i - 1;

            *rel_i := rk;
        }
    }


    ttag = v_get_result_type();
    vtag = v_get_result_value();

    builder = v_target_get_builder();

    cur_b = LLVMGetInsertBlock(builder);

    cur_f = LLVMGetBasicBlockParent(cur_b);

    cmp_result_v: &LLVMValueRef := 0;

    branch_if_false_b: &LLVMBasicBlockRef := 0;

    _bool = v_find_type("bool");

    bool_ = v_type_get_llvm_type(_bool);

    llvm_ctx = v_target_get_llvm_ctx();

    if (N != 2)
    {
        cmp_result_v := LLVMBuildAlloca(builder, bool_, "");

        LLVMBuildStore(builder, LLVMConstNull(bool_), cmp_result_v);

        branch_if_false_b := LLVMAppendBasicBlockInContext(llvm_ctx, cur_f, "branch_if_false_b");
    }


    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor((ast[0] : v_ast_base_ptr), vis);

    typ: &v_type_ptr   := v_get_result_type();
    val: &LLVMValueRef := v_get_result_value();

    t0: &v_type_ptr   := v_undef();
    v0: &LLVMValueRef := v_undef();
    t1: &v_type_ptr   := v_undef();
    v1: &LLVMValueRef := v_undef();

    r: &LLVMValueRef := v_undef();

    for (i: &int := 0; i < Nm1; ++i)
    {
        rel_i = rel[i];

        //- First argument

        t0 := typ;
        v0 := val;

        op_data = op_table[rel_i];

        q0 = op_data[2];                    //- Quark (left)
        q1 = op_data[3];                    //- Quark (right)

        v_set_result_type(ttag);
        v_set_result_value(vtag);

        r := v_handle(&ctx[5], vis, ast+i, rel_i, q0, q1, t0, v0, t1, v1);          //- compile_op_relation...

        typ := t1;
        val := v1;

        if (branch_if_false_b)
        {
            if (i < N-2)
            {
                branch_if_true_b = LLVMAppendBasicBlockInContext(llvm_ctx, cur_f, "branch_if_true_b");

                LLVMBuildCondBr(builder, r, branch_if_true_b, branch_if_false_b);

                LLVMPositionBuilderAtEnd(builder, branch_if_true_b);
            }
            else        //- Last ...
            {
                LLVMBuildStore(builder, r, cmp_result_v);

                LLVMBuildBr(builder, branch_if_false_b);

                cur_b = LLVMGetInsertBlock(builder);

                LLVMMoveBasicBlockAfter(branch_if_false_b, cur_b);

                LLVMPositionBuilderAtEnd(builder, branch_if_false_b);

                r := LLVMBuildLoad2(builder, bool_, cmp_result_v, "");
            }
        }
    }


    if (v_type_is_vector(t0))                   //- ?!?!?!?!?!?
    {
        sz = v_type_vector_get_size(t0);

        if (v_type_vector_is_scalable(t0))
        {
            t0 := v_svector_type(_bool, sz);
        }
        else
        {
            t0 := v_vector_type(_bool, sz);
        }
    }
    else
    {
        t0 := _bool;
    }


    v_set_result_type(ttag);
    v_set_result_value(vtag);

    v_adopt_result(t0, r);
}


//---------------------------------------------------------------------
private
op_unary_helper: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t,
                  t0: *v_type_t, v0: LLVMValueRef, id: int, q: v_quark_t
                 ) ~> void
{
    ttag = v_get_result_type();
    vtag = v_get_result_value();

    ctx = *(aux: *overloading_ctx_t);

    op_data = op_table[id];

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    if (v_util_lookup_function_dict(t0, q, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        v_set_result_type(ttag);
        v_set_result_value(vtag);

        if (fun = (void_fun: *intrinsic_p1_t))
        {
            fun(void_aux, vis, self, t0, v0);
        }
        else
        {
            expr = v_alloca(v_ast_expr_t);
            v_initialize(expr);
            defer v_terminate(expr);

            v_ast_make_expr_compiled(expr, t0, v0);

            arg_ptr: &v_ast_expr_ptr := expr;               //- Value, compiled

            v_handle(&ctx[1], vis, self, ft, fv, &arg_ptr, 1);              //- llvm_build_call...
        }

        v_return();
    }

    //- Default treatment...

    expr = v_alloca(v_ast_expr_t);
    v_initialize(expr);
    defer v_terminate(expr);

    v_ast_make_expr_compiled(expr, t0, v0);

    helper = (op_data[4] : *((*voidc_visitor_t, *v_ast_expr_t, *void) ~> void));

    compile = op_data[5];

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    if (helper) helper(vis, expr, compile);
}

//---------------------------------------------------------------------
private
op_unary_intrinsic: (aux: *void, vis: voidc_visitor_ptr,
                     self: v_ast_base_ptr) ~> void
{
    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    arg = v_list_get_item(args, 1);

    v_ast_accept_visitor((arg: v_ast_base_ptr), vis);

    t0 = v_get_result_type();
    v0 = v_get_result_value();

    aux = *(aux: *v_struct({ *overloading_ctx_t, int }));

    ctx = *aux[0];

    id = aux[1];

    op_data = op_table[id];

    q = op_data[2];             //- Quark

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    v_handle(&ctx[6], vis, self, t0, v0, id, q);            //- compile_op_unary...
}


//---------------------------------------------------------------------
private
static_type_prefix_star_intrinsic: (aux: *void, vis: voidc_visitor_ptr,
                                    self: v_ast_base_ptr,
                                    t0: v_type_ptr, v0: LLVMValueRef
                                   ) ~> void
{
    //- assert(t0 == v_static_type_t);

    typ = (v0: v_type_ptr);

    typ = v_pointer_type(typ, 0);           //- ...

    v_set_result_type(v_static_type_t);
    v_set_result_value((typ: LLVMValueRef));
}

//---------------------------------------------------------------------
private
static_type_prefix_amp_intrinsic: (aux: *void, vis: voidc_visitor_ptr,
                                   self: v_ast_base_ptr,
                                   t0: v_type_ptr, v0: LLVMValueRef
                                  ) ~> void
{
    //- assert(t0 == v_static_type_t);

    typ = (v0: v_type_ptr);

    typ = v_reference_type(typ, 0);         //- ...

    v_set_result_type(v_static_type_t);
    v_set_result_value((typ: LLVMValueRef));
}

//---------------------------------------------------------------------
private
static_type_prefix_cv_intrinsic: (aux: *void, vis: voidc_visitor_ptr,
                                  self: v_ast_base_ptr,
                                  t0: v_type_ptr, v0: LLVMValueRef
                                 ) ~> void
{
    //- assert(t0 == v_static_type_t);

    typ = (v0: v_type_ptr);

    //-----------------------------------------------------------------
    //- Just "ignore" it...
    //-----------------------------------------------------------------

    v_set_result_type(v_static_type_t);
    v_set_result_value((typ: LLVMValueRef));
}


//---------------------------------------------------------------------
private
compile_expr_call_helper: (aux: *void, vis: voidc_visitor_ptr,
                           self: v_ast_base_ptr,
                           args: v_ast_expr_list_ptr,
                           t: v_type_ptr, v: LLVMValueRef
                          ) ~> void
{
    ttag = v_get_result_type();
    vtag = v_get_result_value();

    void_fun: &*void := 0;
    void_aux: &*void := v_undef();

    q = q_op_postfix_call;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    if (v_util_lookup_function_dict(t, q, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        intrinsic_t = (aux: *void, vis: voidc_visitor_ptr,
                       self: v_ast_base_ptr,
                       args: v_ast_expr_list_ptr,
                       t0: v_type_ptr, v0: LLVMValueRef
                      ) ~> void;

        if (fun = (void_fun: *intrinsic_t))
        {
            v_set_result_type(ttag);
            v_set_result_value(vtag);

            fun(void_aux, vis, self, args, t, v);

            v_return();
        }
    }

    i0: &int := 0;

    if (ft)     //- Overloaded...
    {
        i0 := 1;
    }
    else        //- "Normal"...
    {
        v_set_result_type(UNREFERENCE_TAG);
        v_set_result_value(0);

        v_adopt_result(t, v);

        ft := v_get_result_type();
        fv := v_get_result_value();
    }

    i0 = v_load(&i0);       //- Sic!

    if (v_type_is_pointer(ft))  ft := v_type_refptr_get_element_type(ft);

    expr = v_alloca(v_ast_expr_t);
    if (i0) v_initialize(expr);
    defer if (i0) v_terminate(expr);

    arg_count = i0 + v_list_get_size(args);

    arg_ptrs = v_malloc(v_ast_expr_ptr, arg_count);
    defer v_free(arg_ptrs);

    for (i: &int := 0; i < arg_count; ++i)
    {
        if (i == 0  &&  i0 == 1)
        {
            v_ast_make_expr_compiled(expr, t, v);

            arg_ptrs[0] := expr;
        }
        else
        {
            arg_ptrs[i] := v_list_get_item(args, i-i0);
        }
    }

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    ctx = *(aux: *overloading_ctx_t);

    v_handle(&ctx[1], vis, self, ft, fv, arg_ptrs, (arg_count: unsigned));      //- llvm_build_call...
}

//---------------------------------------------------------------------
private
compile_expr_call: (aux: *void, vis: voidc_visitor_ptr,
                    self: v_ast_base_ptr) ~> void
{
    fexpr = v_ast_expr_call_get_fun_expr((self: v_ast_expr_ptr));
    args  = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    void_fun: &*void := 0;
    void_aux: &*void := v_undef();

    if (v_ast_base_get_visitor_method_tag((fexpr: v_ast_base_ptr)) == v_ast_expr_identifier_visitor_method_tag)
    {
        fname_q = v_ast_expr_identifier_get_name_q(fexpr);

        void_fun := v_get_intrinsic_q(fname_q, &void_aux);
    }

    if (fun = (void_fun: *voidc_intrinsic_t))       //- Compile-time intrinsic?
    {
        fun(void_aux, vis, self);

        v_return();
    }

    //- Function call (kinda...)

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);                  //- Sic!

    v_ast_accept_visitor((fexpr: v_ast_base_ptr), vis);

    t = v_get_result_type();
    v = v_get_result_value();

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    ctx = *(aux: *overloading_ctx_t);

    v_handle(&ctx[2], vis, self, args, t, v);               //- compile_expr_call...
}


//---------------------------------------------------------------------
private
op_postfix_index_helper: (aux: *void, vis: *voidc_visitor_t,
                          self: *v_ast_base_t,
                          agg_t: &*v_type_t, agg_v: &LLVMValueRef,
                          idx: **v_ast_expr_list_t, count: int
                         ) ~> bool
{
    ttag = v_get_result_type();
    vtag = v_get_result_value();

    ctx = *(aux: *overloading_ctx_t);

    q = q_op_postfix_index;

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    if (v_util_lookup_function_dict(agg_t, q, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        intrinsic_t = (aux: *void, vis: *voidc_visitor_t,
                       self: *v_ast_base_t,
                       agg_t: v_type_ptr, agg_v: LLVMValueRef,
                       idx: **v_ast_expr_list_t, count: int
                      ) ~> void;

        if (fun = (void_fun: *intrinsic_t))
        {
            v_set_result_type(ttag);
            v_set_result_value(vtag);

            fun(void_aux, vis, self, agg_t, agg_v, idx, count);

            v_return(true);     //- Sic!
        }
        else
        {
            expr = v_alloca(v_ast_expr_t);
            v_initialize(expr);
            defer v_terminate(expr);

            idx_list = *idx;

            arg_count = 1 + v_list_get_size(idx_list);

            arg_ptrs = v_malloc(v_ast_expr_ptr, arg_count);
            defer v_free(arg_ptrs);

            v_ast_make_expr_compiled(expr, agg_t, agg_v);

            arg_ptrs[0] := expr;

            for (j: &int := 1; j < arg_count; ++j)
            {
                arg_ptrs[j] := v_list_get_item(idx_list, j-1);
            }

            agg_t := v_type_function_get_return_type(ft);

            v_set_result_type(agg_t);
            v_set_result_value(0);

            v_handle(&ctx[1], vis, self, ft, fv, arg_ptrs, (arg_count: unsigned));      //- llvm_build_call...

            agg_v := v_get_result_value();
        }
    }
    else
    {
        //- Default treatment...

        eidx = v_list_get_item(*idx, 0);                //- Just one!

        v_set_result_type(INVIOLABLE_TAG);
        v_set_result_value(0);

        voidc_internal_op_postfix_index_helper(vis, eidx, agg_t, agg_v);

        agg_t := v_get_result_type();
        agg_v := v_get_result_value();
    }

    v_return(false);
}

//---------------------------------------------------------------------
private
check_index: (arg: *v_ast_expr_t, agg: **v_ast_expr_t, idx: **v_ast_expr_list_t) ~> bool
{
    tag = v_ast_base_get_visitor_method_tag((arg: v_ast_base_ptr));

    if (tag != expr_call_q)  v_return(false);

    etmp = v_ast_expr_call_get_fun_expr(arg);

    tag = v_ast_base_get_visitor_method_tag((etmp: v_ast_base_ptr));

    if (tag != expr_identifier_q)  v_return(false);

    qname = v_ast_expr_identifier_get_name_q(etmp);

    if (qname != q_op_postfix_index)  v_return(false);

    if (agg  ||  idx)
    {
        lst = v_ast_expr_call_get_arg_list(arg);

        if (agg)  *agg := v_list_get_item(lst, 1);

        if (idx)
        {
            op = v_list_get_item(lst, 0);

            void_obj = v_ast_generic_get_object(op);

            obj = *(void_obj: v_ast_operator_unary_ptr);

            *idx := (&obj[2] : v_ast_expr_list_ptr);
        }
    }

    v_return(true);
}

//---------------------------------------------------------------------
private
op_postfix_index_intrinsic: (aux: *void, vis: voidc_visitor_ptr,
                             self: v_ast_base_ptr) ~> void
{
    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    N: &int := 1;

    {   ast: &v_ast_expr_ptr := v_list_get_item(args, 1);

        while(check_index(ast, &ast, 0))  ++N;
    }

    agg: &v_ast_expr_ptr := v_list_get_item(args, 1);

    idx = v_malloc(v_ast_expr_list_ptr, N);
    defer v_free(idx);

    {   idx_i: &*v_ast_expr_list_ptr := idx + (N-1);

        op = v_list_get_item(args, 0);

        void_obj = v_ast_generic_get_object(op);

        obj = *(void_obj: v_ast_operator_unary_ptr);

        *idx_i := (&obj[2] : v_ast_expr_list_ptr);

        while(check_index(agg, &agg, --idx_i)) ;
    }


    ttag = v_get_result_type();
    vtag = v_get_result_value();


    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor((agg: v_ast_base_ptr), vis);

    agg_t: &v_type_ptr   := v_get_result_type();
    agg_v: &LLVMValueRef := v_get_result_value();


    ctx = *(aux: *overloading_ctx_t);

    for (i: &int := 0; i < N; ++i)
    {
        v_set_result_type(ttag);
        v_set_result_value(vtag);

        fin = v_handle(&ctx[7], vis, self, agg_t, agg_v, idx+i, N-i);           //- compile_op_postfix_index...

        if (fin)  v_return();       //- Sic!
    }

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    v_adopt_result(agg_t, agg_v);
}


//---------------------------------------------------------------------
private
static_type_postfix_index_intrinsic: (aux: *void, vis: voidc_visitor_ptr,
                                      self: v_ast_base_ptr,
                                      agg_t: v_type_ptr, agg_v: LLVMValueRef,
                                      idx: *v_ast_expr_list_ptr, count: int
                                     ) ~> void
{
    t: &v_type_ptr := (agg_v: *v_type_t);

    for (i: &int := count-1; i >= 0; --i)
    {
        idx_list = idx[i];

        idx_count = v_list_get_size(idx_list);

        if (idx_count)
        {
            expr = v_list_get_item(idx_list, 0);        //- Just one!

            v_set_result_type(UNREFERENCE_TAG);
            v_set_result_value(0);

            v_ast_accept_visitor((expr: v_ast_base_ptr), vis);

            idx_v = v_get_result_value();

            n = (LLVMConstIntGetZExtValue(idx_v) : uint64_t);

            t := v_array_type(t, n);
        }
        else    //- No indices!
        {
            typs = v_alloca(v_type_ptr, 2);

            incomplete_array_type_tag = v_struct_type_named_q(voidc_incomplete_array_type_tag);     //- Sic!

            typs[0] := incomplete_array_type_tag;
            typs[1] := t;

            t := v_struct_type(typs, 2, false);
        }
    }

    v_set_result_type(v_static_type_t);

    v_set_result_value((t: LLVMValueRef));
}


//---------------------------------------------------------------------
//- Make handlers callable...
//---------------------------------------------------------------------
private
compile_handler_call_intrinsic: (aux: *void, vis: *voidc_visitor_t,
                                 self: *v_ast_base_t,
                                 args: *v_ast_expr_list_t,
                                 t: *v_type_t, v: LLVMValueRef
                                ) ~> void
{
    expr = v_alloca(v_ast_expr_t);
    v_initialize(expr);
    defer v_terminate(expr);

    v_ast_make_expr_compiled(expr, t, v);

    alst = v_alloca(v_ast_expr_list_t);
    v_initialize(alst);
    defer v_terminate(alst);

    block
    {
        if (!v_type_is_reference(t))  v_break();

        et = v_type_refptr_get_element_type(t);

        if (!v_type_is_struct(et))  v_break();

        //- Got reference to handler, convert to pointer...

        v_make_list(alst, expr, 1);

        v_ast_make_expr_identifier(expr, "v_pointer");

        v_ast_make_expr_call(expr, expr, alst);
    }

    v_make_list(alst, expr, 1);

    n = v_list_get_size(args);

    for (i: &int := 0; i < n; ++i)
    {
        v_list_append(alst, alst, v_list_get_item(args, i));
    }

    v_ast_make_expr_identifier(expr, "v_handle");

    v_ast_make_expr_call(expr, expr, alst);


    v_ast_accept_visitor((expr: *v_ast_base_t), vis);
}

//---------------------------------------------------------------------
export
v_enable_handler: (t: *v_type_t) ~> void
{
    rt = v_reference_type(t, 0);

    pt = v_pointer_type(t, 0);

    rpt = v_reference_type(pt, 0);

    q = v_quark_from_string;

    q_handler_type_ref    = q("v.handler_type_ref");
    q_handler_type_ptr    = q("v.handler_type_ptr");
    q_handler_type_refptr = q("v.handler_type_refprt");

    v_util_function_dict_set( rt, q_op_postfix_call, q_handler_type_ref);
    v_util_function_dict_set( pt, q_op_postfix_call, q_handler_type_ptr);
    v_util_function_dict_set(rpt, q_op_postfix_call, q_handler_type_refptr);

    v_add_intrinsic_q(q_handler_type_ref,    compile_handler_call_intrinsic, 0);
    v_add_intrinsic_q(q_handler_type_ptr,    compile_handler_call_intrinsic, 0);
    v_add_intrinsic_q(q_handler_type_refptr, compile_handler_call_intrinsic, 0);
}


//---------------------------------------------------------------------
//- Enable overloading
//---------------------------------------------------------------------
export
voidc_enable_overloading_compiler: () ~> void
{
    vis = v_get_compiler();

    q = v_quark_from_string;

    q_static_type_prefix_star = q("v.static_type_prefix_star");

    v_return_if(v_get_intrinsic_q(q_static_type_prefix_star, 0));

    voidc_visitor_set_void_method(vis, vis, expr_compiled_q,     compile_expr_compiled,     0);
    voidc_visitor_set_void_method(vis, vis, expr_compile_hook_q, compile_expr_compile_hook, 0);

    //-------------------------------------------------------------
    ctx = *v_malloc(overloading_ctx_t) := 0;

    free: (*void) ~> void;

    v_add_local_cleaner(free, &ctx);

    add_overloading_context(&ctx);

    //-------------------------------------------------------------
    for (id: &int := 0; id < op_table_length; ++id)
    {
        void_fun: & *void := v_undef();

        switch(op_table[id][1])
        {
        case opk_assign:    void_fun := op_assign_intrinsic;    v_break();
        case opk_logical:   void_fun := 0;                      v_break();
        case opk_relation:  void_fun := op_relation_intrinsic;  v_break();
        case opk_binary:    void_fun := op_binary_intrinsic;    v_break();
        case opk_unary:     void_fun := op_unary_intrinsic;     v_break();
        }

        if (!void_fun)  v_continue();

        ctx[0][id] := { &ctx, id };

        v_add_intrinsic_q(op_table[id][2], void_fun, ctx[0] + id);
    }

    //-------------------------------------------------------------
    ctx[1] := {llvm_build_call_helper, 0};
    ctx[2] := {compile_expr_call_helper, &ctx};
    ctx[3] := {op_assign_helper, &ctx};
    ctx[4] := {op_binary_helper, &ctx};
    ctx[5] := {op_relation_helper, &ctx};
    ctx[6] := {op_unary_helper, &ctx};
    ctx[7] := {op_postfix_index_helper, &ctx};

    //-------------------------------------------------------------
    q_static_type_prefix_amp      = q("v.static_type_prefix_amp");
    q_static_type_prefix_const    = q("v.static_type_prefix_const");
    q_static_type_prefix_volatile = q("v.static_type_prefix_volatile");
    q_static_type_postfix_index   = q("v.static_type_postfix_index");

    v_util_function_dict_set(v_static_type_t, q("v.op_prefix_star"), q_static_type_prefix_star);
    v_util_function_dict_set(v_static_type_t, q("v.op_prefix_amp"),  q_static_type_prefix_amp);

    v_add_intrinsic_q(q_static_type_prefix_star, static_type_prefix_star_intrinsic, 0);
    v_add_intrinsic_q(q_static_type_prefix_amp,  static_type_prefix_amp_intrinsic,  0);

    v_util_function_dict_set(v_static_type_t, q("v.op_prefix_const"),    q_static_type_prefix_const);
    v_util_function_dict_set(v_static_type_t, q("v.op_prefix_volatile"), q_static_type_prefix_volatile);

    v_add_intrinsic_q(q_static_type_prefix_const,    static_type_prefix_cv_intrinsic, 0);
    v_add_intrinsic_q(q_static_type_prefix_volatile, static_type_prefix_cv_intrinsic, 0);

    voidc_visitor_set_void_method(vis, vis, expr_call_q, compile_expr_call, &ctx);

    //-------------------------------------------------------------
    v_add_intrinsic_q(q_op_postfix_index, op_postfix_index_intrinsic, &ctx);

    v_util_function_dict_set(v_static_type_t, q_op_postfix_index, q_static_type_postfix_index);

    v_add_intrinsic_q(q_static_type_postfix_index, static_type_postfix_index_intrinsic, 0);

    //-------------------------------------------------------------
    gctx = v_target_get_global_ctx();
    vctx = v_target_get_voidc_global_ctx();

    if (gctx == vctx)
    {
        v_enable_handler(voidc_llvm_build_call_helper_t);
        v_enable_handler(voidc_compile_expr_call_helper_t);
        v_enable_handler(voidc_compile_op_assign_helper_t);
        v_enable_handler(voidc_compile_op_binary_helper_t);
        v_enable_handler(voidc_compile_op_relation_helper_t);
        v_enable_handler(voidc_compile_op_unary_helper_t);
        v_enable_handler(voidc_compile_op_postfix_index_helper_t);
    }
}


//---------------------------------------------------------------------
//- Enable overloading
//---------------------------------------------------------------------
export
voidc_enable_overloading: () ~> void
{
    voidc_enable_overloading_compiler();
}


//=====================================================================
{   voidc_unit_end_module(); }


//---------------------------------------------------------------------
{   ast_expr_compiled_vtable[2]     := expr_compiled_q;
    ast_expr_compile_hook_vtable[2] := expr_compile_hook_q;
}


