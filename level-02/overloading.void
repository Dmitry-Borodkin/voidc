//---------------------------------------------------------------------
//- Copyright (C) 2020-2023 Dmitry Borodkin <borodkin.dn@gmail.com>
//- SDPX-License-Identifier: LGPL-3.0-or-later
//---------------------------------------------------------------------
{   voidc_guard_target("overloading.void  must be imported into the voidc target only!");

    v_import("level-00");
    v_import("level-01");

    v_import("llvm-c/Core.void");

    v_import("unit_module.void");
    v_import("loops_etc.void");
    v_import("aggregates.void");

//  v_import("printf.void");
}

{   v_enable_level_01();

    voidc_enable_loops_etc();
    voidc_enable_aggregates();
}


//---------------------------------------------------------------------
{   q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("expr_call_q",       q_ref, q("expr_call"));
    v_add_symbol("expr_identifier_q", q_ref, q("expr_identifier"));

    v_add_symbol("q_op_postfix_call",  q_ref, q("v.op_postfix_call"));
    v_add_symbol("q_op_postfix_index", q_ref, q("v.op_postfix_index"));

    v_add_symbol("expr_compiled_q",     q_ref, q("expr_compiled"));
    v_add_symbol("expr_compile_hook_q", q_ref, q("expr_compile_hook"));

    v_add_symbol("voidc_llvm_build_call_helper_q", q_ref, q("voidc.llvm_build_call_helper"));

    v_add_symbol("q_op_infix_lt", q_ref, q("v.op_infix_lt"));
    v_add_symbol("q_op_infix_le", q_ref, q("v.op_infix_le"));
    v_add_symbol("q_op_infix_gt", q_ref, q("v.op_infix_gt"));
    v_add_symbol("q_op_infix_ge", q_ref, q("v.op_infix_ge"));
    v_add_symbol("q_op_infix_eq", q_ref, q("v.op_infix_eq"));
    v_add_symbol("q_op_infix_ne", q_ref, q("v.op_infix_ne"));

    v_add_symbol("voidc_incomplete_array_type_tag", q_ref, q("voidc.incomplete_array_type_tag"));
}


//=====================================================================
{   voidc_unit_begin_module("op_table_module"); }


//---------------------------------------------------------------------
opk_assign   = 0;
opk_logical  = 1;
opk_relation = 2;
opk_binary   = 3;
opk_unary    = 4;

op_table_item_t = v_struct("struct.op_table_item",
{
    *const char,    //- 0 - Name
    int,            //- 1 - Kind
    v_quark_t,      //- 2 - Quark (left)
    v_quark_t,      //- 3 - Quark (right)

    *void,          //- 4 - helper function (if any)
    *void           //- 5 - aux for helper  (if any)
});

op_table: &op_table_item_t[] :=
{
    {"v.op_infix_assign",      opk_assign,   0,0, 0 },
    {"v.op_infix_add_assign",  opk_assign,   0,0, voidc_internal_compile_add_helper, (true:  *void) },
    {"v.op_infix_sub_assign",  opk_assign,   0,0, voidc_internal_compile_sub_helper, (true:  *void) },
    {"v.op_infix_mul_assign",  opk_assign,   0,0, voidc_internal_compile_mul_helper, (false: *void) },
    {"v.op_infix_div_assign",  opk_assign,   0,0, voidc_internal_compile_div_helper, (false: *void) },
    {"v.op_infix_rem_assign",  opk_assign,   0,0, voidc_internal_compile_rem_helper, (false: *void) },
    {"v.op_infix_shl_assign",  opk_assign,   0,0, voidc_internal_compile_shl_helper, (false: *void) },
    {"v.op_infix_shr_assign",  opk_assign,   0,0, voidc_internal_compile_shr_helper, (false: *void) },
    {"v.op_infix_and_assign",  opk_assign,   0,0, voidc_internal_compile_and_helper, (false: *void) },
    {"v.op_infix_xor_assign",  opk_assign,   0,0, voidc_internal_compile_xor_helper, (false: *void) },
    {"v.op_infix_or_assign",   opk_assign,   0,0, voidc_internal_compile_or_helper,  (false: *void) },

//  {"v.op_infix_to",          opk_binary    },          //- ?!?!?!?!?!?!?!?

    {"v.op_infix_logical_or",  opk_logical   },
    {"v.op_infix_logical_and", opk_logical   },

    {"v.op_infix_lt",          opk_relation, 0,0, voidc_internal_compile_op_relation_helper, voidc_internal_compile_lt_helper },
    {"v.op_infix_le",          opk_relation, 0,0, voidc_internal_compile_op_relation_helper, voidc_internal_compile_le_helper },
    {"v.op_infix_gt",          opk_relation, 0,0, voidc_internal_compile_op_relation_helper, voidc_internal_compile_gt_helper },
    {"v.op_infix_ge",          opk_relation, 0,0, voidc_internal_compile_op_relation_helper, voidc_internal_compile_ge_helper },
    {"v.op_infix_eq",          opk_relation, 0,0, voidc_internal_compile_op_relation_helper, voidc_internal_compile_eq_helper },
    {"v.op_infix_ne",          opk_relation, 0,0, voidc_internal_compile_op_relation_helper, voidc_internal_compile_ne_helper },

    {"v.op_infix_or",          opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_or_helper },
    {"v.op_infix_xor",         opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_xor_helper },
    {"v.op_infix_and",         opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_and_helper },

    {"v.op_infix_shl",         opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_shl_helper },
    {"v.op_infix_shr",         opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_shr_helper },
    {"v.op_infix_add",         opk_binary,   0,0, voidc_internal_compile_op_binary_addsub_helper, voidc_internal_compile_infix_add_helper },
    {"v.op_infix_sub",         opk_binary,   0,0, voidc_internal_compile_op_binary_addsub_helper, voidc_internal_compile_infix_sub_helper },
    {"v.op_infix_mul",         opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_mul_helper },
    {"v.op_infix_div",         opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_div_helper },
    {"v.op_infix_rem",         opk_binary,   0,0, voidc_internal_compile_op_binary_helper,        voidc_internal_compile_rem_helper },

    {"v.op_prefix_inc",        opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_inc },
    {"v.op_prefix_dec",        opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_dec },
    {"v.op_prefix_plus",       opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_plus },
    {"v.op_prefix_minus",      opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_minus },
    {"v.op_prefix_star",       opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_star },
    {"v.op_prefix_amp",        opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_amp },
    {"v.op_prefix_bang",       opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_bang },
    {"v.op_prefix_tilda",      opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_prefix_tilda},

    {"v.op_prefix_const",      opk_unary,    0,0, 0 },          //- ...
    {"v.op_prefix_volatile",   opk_unary,    0,0, 0 },          //- ...

    {"v.op_postfix_inc",       opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_postfix_inc },
    {"v.op_postfix_dec",       opk_unary,    0,0, voidc_internal_compile_op_unary_helper, voidc_internal_compile_postfix_dec },

    {0}     //- Sic...
};


//---------------------------------------------------------------------
op_table_ctor: () -> void
{
    sstr = v_alloca(v_std_string_t);
    v_initialize(sstr);
    defer v_terminate(sstr);

    int_ = v_type_get_llvm_type(int);

    for (i: &int := 0; name = op_table[i][0]; ++i)
    {
        op_table[i][2] := v_quark_from_string(name);

        if (k = op_table[i][1],  k == opk_binary  ||  k == opk_relation)
        {
            v_std_string_set(sstr, name);

            v_std_string_append(sstr, ".right");

            op_table[i][3] := v_quark_from_string(v_std_string_get(sstr));
        }

        v_std_string_set(sstr, "id");

        v_std_string_append(sstr, name+4);          //- Skip "v.op"

        v_add_constant(v_std_string_get(sstr), int, LLVMConstInt(int_, i, 0));
    }
}


//=====================================================================
{   voidc_unit_end_module(); }


//---------------------------------------------------------------------
{   op_table_ctor();
}


//=====================================================================
{   voidc_unit_begin_module("overloading_module"); }


//---------------------------------------------------------------------
//- ast_expr_compiled_t ...
//---------------------------------------------------------------------
private
ast_expr_compiled_t = v_struct("struct.ast_expr_compiled_t",
{
    *v_type_t,          //- 0 - compiled type
    LLVMValueRef,       //- 1 - compiled value
});

{   sz_v = LLVMSizeOf(v_type_get_llvm_type(ast_expr_compiled_t));

    v_add_constant("ast_expr_compiled_size", size_t, sz_v);
}

ast_expr_compiled_vtable: &v_ast_generic_vtable := {0, 0};

//---------------------------------------------------------------------
export
v_ast_make_expr_compiled: (expr: *v_ast_expr_t, t: *v_type_t, v: LLVMValueRef) -> void
{
    v_ast_make_generic(expr, &ast_expr_compiled_vtable, ast_expr_compiled_size);

    void_obj = v_ast_generic_get_object(expr);

    obj = *(void_obj: *ast_expr_compiled_t);

    obj[0] := t;
    obj[1] := v;
}

//---------------------------------------------------------------------
private
compile_expr_compiled: (vis: *voidc_visitor_t, aux: *void, self: *v_ast_base_t) -> void
{
    void_obj = v_ast_generic_get_object((self: *v_ast_expr_t));

    obj = *(void_obj: *ast_expr_compiled_t);

    v_adopt_result(obj[0], obj[1]);
}


//---------------------------------------------------------------------
//- ast_expr_compile_hook_t ...
//---------------------------------------------------------------------
private
ast_expr_compile_hook_t = v_struct("struct.ast_expr_compile_hook_t",
{
    v_ast_expr_t,       //- 0 - expr  to compile

    **v_type_t,         //- 1 - type  to "hook"
    *LLVMValueRef,      //- 2 - value to "hook"
});

{   sz_v = LLVMSizeOf(v_type_get_llvm_type(ast_expr_compile_hook_t));

    v_add_constant("ast_expr_compile_hook_size", size_t, sz_v);
}

private
ast_expr_compile_hook_init: (void_obj: *void) -> void
{
    obj = *(void_obj: *ast_expr_compile_hook_t);

    v_initialize(&obj[0]);
}

private
ast_expr_compile_hook_term: (void_obj: *void) -> void
{
    obj = *(void_obj: *ast_expr_compile_hook_t);

    v_terminate(&obj[0]);
}

ast_expr_compile_hook_vtable: &v_ast_generic_vtable :=
{
    ast_expr_compile_hook_init,
    ast_expr_compile_hook_term,
};

//---------------------------------------------------------------------
export
v_ast_make_expr_compile_hook: (ret: *v_ast_expr_t, expr: *v_ast_expr_t, t: &*v_type_t, v: &LLVMValueRef) -> void
{
    etmp = v_alloca(v_ast_expr_t);
    v_initialize(etmp);
    defer v_terminate(etmp);

    v_ast_make_generic(etmp, &ast_expr_compile_hook_vtable, ast_expr_compile_hook_size);

    void_obj = v_ast_generic_get_object(etmp);

    obj = *(void_obj: *ast_expr_compile_hook_t);

    v_copy(&obj[0], expr);

    obj[1] := &t;
    obj[2] := &v;

    v_copy(ret, etmp);
}

//---------------------------------------------------------------------
private
compile_expr_compile_hook: (vis: *voidc_visitor_t, aux: *void, self: *v_ast_base_t) -> void
{
    void_obj = v_ast_generic_get_object((self: *v_ast_expr_t));

    obj = *(void_obj: *ast_expr_compile_hook_t);

    expr  = &obj[0];
    type  = *obj[1];
    value = *obj[2];

    v_ast_accept_visitor((expr : v_ast_base_ptr), vis);

    type  := v_get_result_type();
    value := v_get_result_value();
}


//---------------------------------------------------------------------
//- voidc_llvm_build_call_helper
//---------------------------------------------------------------------
private
voidc_llvm_build_call_helper_intrinsic: (vis: *voidc_visitor_t, aux: *void, self: *v_ast_base_t,
                                         ft: v_type_ptr, fv: LLVMValueRef,
                                         arg_ptrs: **v_ast_expr_t, arg_count: unsigned
                                        ) -> void
{
    par_count = v_type_function_get_param_count(ft);
    par_types = v_type_function_get_param_types(ft);

    values = v_malloc(LLVMValueRef, arg_count);
    defer v_free(values);

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    for (i: &unsigned := 0; i < arg_count; ++i)
    {
        if (i < par_count)  v_set_result_type(par_types[i]);
        else                v_set_result_type(UNREFERENCE_TAG);

        v_set_result_value(0);

        v_ast_accept_visitor((arg_ptrs[i]: v_ast_base_ptr), vis);

        values[i] := v_get_result_value();
    }

    builder = v_target_get_builder();

    ft_ = v_type_get_llvm_type(ft);

    vr = LLVMBuildCall2(builder, ft_, fv, values, arg_count, "");

    tr = v_type_function_get_return_type(ft);

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    v_adopt_result(tr, vr);
}

export
voidc_llvm_build_call_helper: (vis: *voidc_visitor_t, self: *v_ast_base_t,
                               ft: v_type_ptr, fv: LLVMValueRef,
                               arg_ptrs: **v_ast_expr_t, arg_count: unsigned
                              ) -> void
{
    aux: &*void := v_undef();

    void_fun = v_get_intrinsic_q(voidc_llvm_build_call_helper_q, &aux);

    fun_t = (vis: *voidc_visitor_t, aux: *void, self: *v_ast_base_t,
             ft: v_type_ptr, fv: LLVMValueRef,
             arg_ptrs: **v_ast_expr_t, arg_count: unsigned
            ) -> void;

    (void_fun: *fun_t)(vis, aux, self, ft, fv, arg_ptrs, arg_count);
}


//---------------------------------------------------------------------
intrinsic_p1_t = (vis: voidc_visitor_ptr, aux: *void,
                  self: v_ast_base_ptr,
                  t0: v_type_ptr, v0: LLVMValueRef
                 ) -> void;

intrinsic_p2_t = (vis: voidc_visitor_ptr, aux: *void,
                  self: v_ast_base_ptr,
                  t0: v_type_ptr, v0: LLVMValueRef,
                  t1: v_type_ptr, v1: LLVMValueRef
                 ) -> void;


//---------------------------------------------------------------------
private
op_assign_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                      self: v_ast_base_ptr) -> void
{
    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    lhs = v_list_get_item(args, 1);             //- "Place"

    v_ast_accept_visitor((lhs : v_ast_base_ptr), vis);

    t0 = v_get_result_type();
    v0 = v_get_result_value();

    op_data = op_table[(aux: int)];

    q = op_data[2];     //- Quark

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    if (v_util_lookup_function_dict(t0, q, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        if (fun = (void_fun: *intrinsic_p1_t))
        {
            v_set_result_type(ttag);
            v_set_result_value(vtag);

            fun(vis, void_aux, self, t0, v0);
        }
        else
        {
            expr = v_alloca(v_ast_expr_t);
            v_initialize(expr);
            defer v_terminate(expr);

            v_ast_make_expr_compiled(expr, t0, v0);

            arg_ptrs = v_alloca(v_ast_expr_ptr, 2);

            arg_ptrs[0] := expr;                            //- "Place", compiled
            arg_ptrs[1] := v_list_get_item(args, 2);        //- "Value"

            v_set_result_type(ttag);
            v_set_result_value(vtag);

            voidc_llvm_build_call_helper(vis, self, ft, fv, arg_ptrs, 2);
        }

        v_return();
    }

    //- Default treatment...

    expr = v_alloca(v_ast_expr_t);
    v_initialize(expr);
    defer v_terminate(expr);

    v_ast_make_expr_compiled(expr, t0, v0);

    ast0 = expr;                            //- "Place", compiled
    ast1 = v_list_get_item(args, 2);        //- "Value"

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    compile = (op_data[4] : *((v_type_ptr, LLVMValueRef, LLVMValueRef) -> LLVMValueRef));

    if (compile)
    {
        flag = (op_data[5] : bool);

        voidc_internal_compile_op_assign_helper(vis, ast0, ast1, compile, flag);
    }
    else
    {
        voidc_internal_compile_op_infix_assign_helper(vis, ast0, ast1);        //- Sic !?!?!?!?!?!?!?!
    }
}


//---------------------------------------------------------------------
private
op_binary_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                      self: v_ast_base_ptr) -> void
{
    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    //- First argument

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    lhs = v_list_get_item(args, 1);

    v_ast_accept_visitor((lhs : v_ast_base_ptr), vis);

    t0 = v_get_result_type();
    v0 = v_get_result_value();

    op_data = op_table[(aux: int)];

    q0 = op_data[2];        //- Quark (left)

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    if (v_util_lookup_function_dict(t0, q0, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        if (fun = (void_fun: *intrinsic_p1_t))
        {
            v_set_result_type(ttag);
            v_set_result_value(vtag);

            fun(vis, void_aux, self, t0, v0);
        }
        else
        {
            expr = v_alloca(v_ast_expr_t);
            v_initialize(expr);
            defer v_terminate(expr);

            v_ast_make_expr_compiled(expr, t0, v0);

            arg_ptrs = v_alloca(v_ast_expr_ptr, 2);

            arg_ptrs[0] := expr;                            //- "LHS", compiled
            arg_ptrs[1] := v_list_get_item(args, 2);        //- "RHS"

            v_set_result_type(ttag);
            v_set_result_value(vtag);

            voidc_llvm_build_call_helper(vis, self, ft, fv, arg_ptrs, 2);
        }

        v_return();
    }

    //- Second argument

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    rhs = v_list_get_item(args, 2);

    v_ast_accept_visitor((rhs : v_ast_base_ptr), vis);

    t1 = v_get_result_type();
    v1 = v_get_result_value();

    q1 = op_data[3];        //- Quark (right)

    if (v_util_lookup_function_dict(t1, q1, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        if (fun = (void_fun: *intrinsic_p2_t))
        {
            v_set_result_type(ttag);
            v_set_result_value(vtag);

            fun(vis, void_aux, self, t0, v0, t1, v1);
        }
        else
        {
            expr = v_alloca(v_ast_expr_t, 2);
            v_initialize(expr, 2);
            defer v_terminate(expr, 2);

            v_ast_make_expr_compiled(expr+0, t0, v0);
            v_ast_make_expr_compiled(expr+1, t1, v1);

            arg_ptrs = v_alloca(v_ast_expr_ptr, 2);

            arg_ptrs[0] := expr+0;                          //- "LHS", compiled
            arg_ptrs[1] := expr+1;                          //- "RHS", compiled

            v_set_result_type(ttag);
            v_set_result_value(vtag);

            voidc_llvm_build_call_helper(vis, self, ft, fv, arg_ptrs, 2);
        }

        v_return();
    }

    //- Default treatment...

    expr = v_alloca(v_ast_expr_t, 2);
    v_initialize(expr, 2);
    defer v_terminate(expr, 2);

    v_ast_make_expr_compiled(expr+0, t0, v0);
    v_ast_make_expr_compiled(expr+1, t1, v1);

    v_set_result_type(ttag);
    v_set_result_value(vtag);


    helper = (op_data[4] : *((*voidc_visitor_t, *v_ast_expr_t, *v_ast_expr_t, *void) -> void));

    compile = op_data[5];

    helper(vis, expr+0, expr+1, compile);
}


//---------------------------------------------------------------------
private
check_relation: (arg: v_ast_expr_ptr, lhs: *v_ast_expr_ptr, rhs: *v_ast_expr_ptr) -> int
{
    get_tag = v_ast_base_get_visitor_method_tag;

    if (get_tag((arg: v_ast_base_ptr)) != expr_call_q)  v_return(0);

    etmp = v_ast_expr_call_get_fun_expr(arg);

    if (get_tag((etmp: v_ast_base_ptr)) != expr_identifier_q)  v_return(0);

    qname = v_ast_expr_identifier_get_name_q(etmp);

    rk: &int := v_undef();

    block
    {
        if (qname == q_op_infix_lt)  { rk := id_infix_lt; v_break(); }
        if (qname == q_op_infix_le)  { rk := id_infix_le; v_break(); }
        if (qname == q_op_infix_gt)  { rk := id_infix_gt; v_break(); }
        if (qname == q_op_infix_ge)  { rk := id_infix_ge; v_break(); }
        if (qname == q_op_infix_eq)  { rk := id_infix_eq; v_break(); }
        if (qname == q_op_infix_ne)  { rk := id_infix_ne; v_break(); }

        v_return(0);
    }

    if (lhs) ;
    else if (rhs) ;
    else
    {
        v_return(rk);
    }

    lst = v_ast_expr_call_get_arg_list(arg);

    if (lhs)  *lhs := v_list_get_item(lst, 1);
    if (rhs)  *rhs := v_list_get_item(lst, 2);

    v_return(rk);
}

//---------------------------------------------------------------------
private
op_relation_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                        self: v_ast_base_ptr) -> void
{
    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    N: &int := 2;

    {   ast: &v_ast_expr_ptr := v_list_get_item(args, 1);

        while(check_relation(ast, &ast, 0)) ++N;
    }

    ast = v_malloc(v_ast_expr_ptr, N);
    defer v_free(ast);

    Nm1 = N - 1;

    rel = v_malloc(int, Nm1);
    defer v_free(rel);

    {   i = N - 2;

        ast_i: &*v_ast_expr_ptr := ast + i;
        rel_i: &*int            := rel + i;

        ast_i[0] := v_list_get_item(args, 1);
        ast_i[1] := v_list_get_item(args, 2);

        *rel_i := (aux: int);

        while(ast_i1 = ast_i-1, rk = check_relation(*ast_i, ast_i1, ast_i))
        {
            ast_i := ast_i1;
            rel_i := rel_i - 1;

            *rel_i := rk;
        }
    }


    ttag = v_get_result_type();
    vtag = v_get_result_value();

    builder = v_target_get_builder();

    cur_b = LLVMGetInsertBlock(builder);

    cur_f = LLVMGetBasicBlockParent(cur_b);

    cmp_result_v: &LLVMValueRef := 0;

    branch_if_false_b: &LLVMBasicBlockRef := 0;

    _bool = v_find_type("bool");

    bool_ = v_type_get_llvm_type(_bool);

    llvm_ctx = v_target_get_llvm_ctx();

    if (N != 2)
    {
        cmp_result_v := LLVMBuildAlloca(builder, bool_, "");

        LLVMBuildStore(builder, LLVMConstNull(bool_), cmp_result_v);

        branch_if_false_b := LLVMAppendBasicBlockInContext(llvm_ctx, cur_f, "branch_if_false_b");
    }


    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor((ast[0] : v_ast_base_ptr), vis);

    typ: &v_type_ptr   := v_get_result_type();
    val: &LLVMValueRef := v_get_result_value();

    t0: &v_type_ptr   := v_undef();
    v0: &LLVMValueRef := v_undef();
    t1: &v_type_ptr   := v_undef();
    v1: &LLVMValueRef := v_undef();

    r: &LLVMValueRef := v_undef();

    for (i: &int := 0; i < Nm1; ++i)
    {
        r := 0;

        rel_i = rel[i];

        //- First argument

        t0 := typ;
        v0 := val;

        op_data = op_table[rel_i];

        q0 = op_data[2];                    //- Quark (left)

        void_fun: &*void := 0;
        void_aux: &*void := 0;

        ft: &v_type_ptr   := 0;
        fv: &LLVMValueRef := 0;

        if (v_util_lookup_function_dict(typ, q0, void_fun, void_aux, ft, fv))
        {
            //- Got overloading!

            intrinsic_p12_t = (vis: voidc_visitor_ptr, aux: *void,
                               ast: *v_ast_expr_ptr,
                               t0:  v_type_ptr, v0:  LLVMValueRef,
                               t1: &v_type_ptr, v1: &LLVMValueRef
                              ) -> void;

            if (fun = (void_fun: *intrinsic_p12_t))
            {
                v_set_result_type(ttag);        //- Sic !?!
                v_set_result_value(vtag);       //- Sic !?!

                fun(vis, void_aux, ast+i, t0, v0, t1, v1);                      //- Without "self" !?!?!?!?!
            }
            else
            {
                expr = v_alloca(v_ast_expr_t, 2);
                v_initialize(expr, 2);
                defer v_terminate(expr, 2);

                v_ast_make_expr_compiled(expr+0, t0, v0);

                v_ast_make_expr_compile_hook(expr+1, ast[i+1], t1, v1);

                arg_ptrs = v_alloca(v_ast_expr_ptr, 2);

                arg_ptrs[0] := expr+0;                          //- "LHS", compiled
                arg_ptrs[1] := expr+1;                          //- "RHS", compile hook

                v_set_result_type(ttag);
                v_set_result_value(vtag);

                voidc_llvm_build_call_helper(vis, 0, ft, fv, arg_ptrs, 2);      //- Without "self" !?!?!?!?!
            }

            r := v_get_result_value();
        }
        else
        {
            //- Second argument

            v_set_result_type(INVIOLABLE_TAG);
            v_set_result_value(0);

            v_ast_accept_visitor((ast[i+1] : v_ast_base_ptr), vis);

            t1 := v_get_result_type();
            v1 := v_get_result_value();

            q1 = op_data[3];                    //- Quark (right)

            if (v_util_lookup_function_dict(t1, q1, void_fun, void_aux, ft, fv))
            {
                //- Got overloading!

                intrinsic_p22_t = (vis: voidc_visitor_ptr, aux: *void,
                                   ast: *v_ast_expr_ptr,
                                   t0: v_type_ptr, v0: LLVMValueRef,
                                   t1: v_type_ptr, v1: LLVMValueRef
                                  ) -> void;

                if (fun = (void_fun: *intrinsic_p22_t))
                {
                    v_set_result_type(ttag);        //- Sic !?!
                    v_set_result_value(vtag);       //- Sic !?!

                    fun(vis, void_aux, ast+i, t0, v0, t1, v1);                      //- Without "self" !?!?!?!?!
                }
                else
                {
                    expr = v_alloca(v_ast_expr_t, 2);
                    v_initialize(expr, 2);
                    defer v_terminate(expr, 2);

                    v_ast_make_expr_compiled(expr+0, t0, v0);
                    v_ast_make_expr_compiled(expr+1, t1, v1);

                    arg_ptrs = v_alloca(v_ast_expr_ptr, 2);

                    arg_ptrs[0] := expr+0;                          //- "LHS", compiled
                    arg_ptrs[1] := expr+1;                          //- "RHS", compiled

                    v_set_result_type(ttag);
                    v_set_result_value(vtag);

                    voidc_llvm_build_call_helper(vis, 0, ft, fv, arg_ptrs, 2);      //- Without "self" !?!?!?!?!
                }

                r := v_get_result_value();
            }
        }

        typ := t1;
        val := v1;

        if (!r)
        {
            //- Default treatment...

            expr = v_alloca(v_ast_expr_t);
            v_initialize(expr);
            defer v_terminate(expr);

            v_ast_make_expr_compiled(expr, t1, v1);

            helper = (op_data[4] : *((*voidc_visitor_t, *void, *v_type_t, LLVMValueRef,
                                      *v_ast_expr_t, &*v_type_t, &LLVMValueRef) -> LLVMValueRef));

            compile = op_data[5];

            r := helper(vis, compile, t0, v0, expr, t1, v1);
        }

        if (branch_if_false_b)
        {
            if (i < N-2)
            {
                branch_if_true_b = LLVMAppendBasicBlockInContext(llvm_ctx, cur_f, "branch_if_true_b");

                LLVMBuildCondBr(builder, r, branch_if_true_b, branch_if_false_b);

                LLVMPositionBuilderAtEnd(builder, branch_if_true_b);
            }
            else        //- Last ...
            {
                LLVMBuildStore(builder, r, cmp_result_v);

                LLVMBuildBr(builder, branch_if_false_b);

                cur_b = LLVMGetInsertBlock(builder);

                LLVMMoveBasicBlockAfter(branch_if_false_b, cur_b);

                LLVMPositionBuilderAtEnd(builder, branch_if_false_b);

                r := LLVMBuildLoad2(builder, bool_, cmp_result_v, "");
            }
        }
    }


    if (v_type_is_vector(t0))
    {
        sz = v_type_vector_get_size(t0);

        if (v_type_vector_is_scalable(t0))
        {
            t0 := v_svector_type(_bool, sz);
        }
        else
        {
            t0 := v_vector_type(_bool, sz);
        }
    }
    else
    {
        t0 := _bool;
    }


    v_set_result_type(ttag);
    v_set_result_value(vtag);

    v_adopt_result(t0, r);
}


//---------------------------------------------------------------------
private
op_unary_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                     self: v_ast_base_ptr) -> void
{
    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    arg = v_list_get_item(args, 1);

    v_ast_accept_visitor((arg: v_ast_base_ptr), vis);

    t0 = v_get_result_type();
    v0 = v_get_result_value();

    op_data = op_table[(aux: int)];

    q = op_data[2];             //- Quark

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    if (v_util_lookup_function_dict(t0, q, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        v_set_result_type(ttag);
        v_set_result_value(vtag);

        if (fun = (void_fun: *intrinsic_p1_t))
        {
            fun(vis, void_aux, self, t0, v0);
        }
        else
        {
            expr = v_alloca(v_ast_expr_t);
            v_initialize(expr);
            defer v_terminate(expr);

            v_ast_make_expr_compiled(expr, t0, v0);

            arg_ptr: &v_ast_expr_ptr := expr;               //- Value, compiled

            voidc_llvm_build_call_helper(vis, self, ft, fv, &arg_ptr, 1);
        }

        v_return();
    }

    //- Default treatment...

    expr = v_alloca(v_ast_expr_t);
    v_initialize(expr);
    defer v_terminate(expr);

    v_ast_make_expr_compiled(expr, t0, v0);

    helper = (op_data[4] : *((*voidc_visitor_t, *v_ast_expr_t, *void) -> void));

    compile = op_data[5];

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    helper(vis, expr, compile);
}


//---------------------------------------------------------------------
private
static_type_prefix_star_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                                    self: v_ast_base_ptr,
                                    t0: v_type_ptr, v0: LLVMValueRef
                                   ) -> void
{
    //- assert(t0 == v_static_type_t);

    typ = (v0: v_type_ptr);

    typ = v_pointer_type(typ, 0);           //- ...

    v_set_result_type(v_static_type_t);
    v_set_result_value((typ: LLVMValueRef));
}

//---------------------------------------------------------------------
private
static_type_prefix_amp_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                                   self: v_ast_base_ptr,
                                   t0: v_type_ptr, v0: LLVMValueRef
                                  ) -> void
{
    //- assert(t0 == v_static_type_t);

    typ = (v0: v_type_ptr);

    typ = v_reference_type(typ, 0);         //- ...

    v_set_result_type(v_static_type_t);
    v_set_result_value((typ: LLVMValueRef));
}

//---------------------------------------------------------------------
private
static_type_prefix_cv_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                                  self: v_ast_base_ptr,
                                  t0: v_type_ptr, v0: LLVMValueRef
                                 ) -> void
{
    //- assert(t0 == v_static_type_t);

    typ = (v0: v_type_ptr);

    //-----------------------------------------------------------------
    //- Just "ignore" it...
    //-----------------------------------------------------------------

    v_set_result_type(v_static_type_t);
    v_set_result_value((typ: LLVMValueRef));
}


//---------------------------------------------------------------------
export
voidc_internal_compile_expr_call_helper: (vis: voidc_visitor_ptr,
                                          self: v_ast_base_ptr,
                                          args: v_ast_expr_list_ptr,
                                          t: v_type_ptr, v: LLVMValueRef
                                         ) -> void
{
    ttag = v_get_result_type();
    vtag = v_get_result_value();

    void_fun: &*void := 0;
    void_aux: &*void := v_undef();

    q = q_op_postfix_call;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    if (v_util_lookup_function_dict(t, q, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        intrinsic_t = (vis: voidc_visitor_ptr, aux: *void,
                       self: v_ast_base_ptr,
                       args: v_ast_expr_list_ptr,
                       t0: v_type_ptr, v0: LLVMValueRef
                      ) -> void;

        if (fun = (void_fun: *intrinsic_t))
        {
            v_set_result_type(ttag);
            v_set_result_value(vtag);

            fun(vis, void_aux, self, args, t, v);

            v_return();
        }
    }

    i0: &int := 0;

    if (ft)     //- Overloaded...
    {
        i0 := 1;
    }
    else        //- "Normal"...
    {
        v_set_result_type(UNREFERENCE_TAG);
        v_set_result_value(0);

        v_adopt_result(t, v);

        ft := v_get_result_type();
        fv := v_get_result_value();
    }

    i0 = v_load(&i0);       //- Sic!

    if (v_type_is_pointer(ft))  ft := v_type_refptr_get_element_type(ft);

    expr = v_alloca(v_ast_expr_t);
    if (i0) v_initialize(expr);
    defer if (i0) v_terminate(expr);

    arg_count = i0 + v_list_get_size(args);

    arg_ptrs = v_malloc(v_ast_expr_ptr, arg_count);
    defer v_free(arg_ptrs);

    for (i: &int := 0; i < arg_count; ++i)
    {
        if (i == 0  &&  i0 == 1)
        {
            v_ast_make_expr_compiled(expr, t, v);

            arg_ptrs[0] := expr;
        }
        else
        {
            arg_ptrs[i] := v_list_get_item(args, i-i0);
        }
    }

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    voidc_llvm_build_call_helper(vis, self, ft, fv, arg_ptrs, (arg_count: unsigned));
}

//---------------------------------------------------------------------
private
compile_expr_call: (vis: voidc_visitor_ptr, *void,
                    self: v_ast_base_ptr) -> void
{
    fexpr = v_ast_expr_call_get_fun_expr((self: v_ast_expr_ptr));
    args  = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    void_fun: &*void := 0;
    void_aux: &*void := v_undef();

    if (v_ast_base_get_visitor_method_tag((fexpr: v_ast_base_ptr)) == v_ast_expr_identifier_visitor_method_tag)
    {
        fname_q = v_ast_expr_identifier_get_name_q(fexpr);

        void_fun := v_get_intrinsic_q(fname_q, &void_aux);
    }

    if (fun = (void_fun: *voidc_intrinsic_t))       //- Compile-time intrinsic?
    {
        fun(vis, void_aux, self);

        v_return();
    }

    //- Function call (kinda...)

    ttag = v_get_result_type();
    vtag = v_get_result_value();

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);                  //- Sic!

    v_ast_accept_visitor((fexpr: v_ast_base_ptr), vis);

    t = v_get_result_type();
    v = v_get_result_value();

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    voidc_internal_compile_expr_call_helper(vis, self, args, t, v);
}


//---------------------------------------------------------------------
export
voidc_internal_op_postfix_index_helper: (vis: voidc_visitor_ptr,
                                         eidx: v_ast_expr_ptr,
                                         t0: v_type_ptr, v0: LLVMValueRef
                                        ) -> void
{
    ttag = v_get_result_type();
    vtag = v_get_result_value();

    v_set_result_type(UNREFERENCE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor((eidx: v_ast_base_ptr), vis);

    idx_t: &v_type_ptr   := v_get_result_type();
    idx_v: &LLVMValueRef := v_get_result_value();

    block
    {
        st = v_type_get_scalar_type(idx_t);

        if (!v_type_is_integer(st))        v_break();
        if (v_type_integer_is_signed(st))  v_break();

        w = v_type_integer_get_width(st);

        if (w >= 32)  v_break();

        t1: &v_type_ptr := v_uint_type(32);

        if (v_type_is_vector(idx_t))
        {
            count = v_type_vector_get_size(idx_t);

            if (v_type_vector_is_scalable(idx_t))  t1 := v_svector_type(t1, count);
            else                                   t1 := v_vector_type(t1, count);
        }

        v_set_result_type(t1);
        v_set_result_value(0);

        v_adopt_result(idx_t, idx_v);

        idx_t := v_get_result_type();
        idx_v := v_get_result_value();
    }

    agg_t: &v_type_ptr   := t0;
    agg_v: &LLVMValueRef := v0;

    builder = v_target_get_builder();

    if (v_type_is_reference(agg_t))
    {
        e = v_type_refptr_get_element_type(agg_t);

        if (v_type_is_pointer(e))
        {
            agg_t := e;

            agg_v := LLVMBuildLoad2(builder, v_type_get_llvm_type(agg_t), agg_v, "agg");
        }
    }

    t: &v_type_ptr   := v_undef();
    v: &LLVMValueRef := v_undef();

    if (v_type_is_pointer(agg_t))
    {
        v := idx_v;     //- Sic...

        e = v_type_refptr_get_element_type(agg_t);

        v := LLVMBuildGEP2(builder, v_type_get_llvm_type(e), agg_v, &v, 1, "");

        a = v_type_refptr_get_address_space(agg_t);

        t := v_reference_type(e, a);
    }
    else if (v_type_is_reference(agg_t))
    {
        n0 = LLVMConstInt(v_type_get_llvm_type(int), 0, 0);

        idxx: &LLVMValueRef[2] := {n0, idx_v};

        e = v_type_refptr_get_element_type(agg_t);

        v := LLVMBuildGEP2(builder, v_type_get_llvm_type(e), agg_v, &idxx[0], 2, "");

        a = v_type_refptr_get_address_space(agg_t);

        if (v_type_is_struct(e))
        {
            i = (LLVMConstIntGetZExtValue(idx_v) : unsigned);

            e = v_type_struct_get_element_types(e)[i];

            t := v_reference_type(e, a);
        }
        else if (v_type_is_array(e))
        {
            e = v_type_array_get_element_type(e);

            t := v_reference_type(e, a);
        }
        else    //- assert(v_type_is_vector(e)); ...
        {
            e = v_type_vector_get_element_type(e);

            t := v_reference_type(e, a);
        }
    }
    else    //- Just aggregate value
    {
        if (v_type_is_vector(agg_t))
        {
            v := LLVMBuildExtractElement(builder, agg_v, idx_v, "");

            t := v_type_vector_get_element_type(agg_t);
        }
        else
        {
            i = (LLVMConstIntGetZExtValue(idx_v) : unsigned);

            v := LLVMBuildExtractValue(builder, agg_v, i, "");

            if (v_type_is_struct(agg_t))
            {
                t := v_type_struct_get_element_types(agg_t)[i];
            }
            else    //- assert(v_type_is_array(agg_t));
            {
                t := v_type_array_get_element_type(agg_t);
            }
        }
    }

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    v_adopt_result(t, v);
}

//---------------------------------------------------------------------
private
check_index: (arg: *v_ast_expr_t, agg: **v_ast_expr_t, idx: **v_ast_expr_list_t) -> bool
{
    tag = v_ast_base_get_visitor_method_tag((arg: v_ast_base_ptr));

    if (tag != expr_call_q)  v_return(false);

    etmp = v_ast_expr_call_get_fun_expr(arg);

    tag = v_ast_base_get_visitor_method_tag((etmp: v_ast_base_ptr));

    if (tag != expr_identifier_q)  v_return(false);

    qname = v_ast_expr_identifier_get_name_q(etmp);

    if (qname != q_op_postfix_index)  v_return(false);

    if (agg  ||  idx)
    {
        lst = v_ast_expr_call_get_arg_list(arg);

        if (agg)  *agg := v_list_get_item(lst, 1);

        if (idx)
        {
            op = v_list_get_item(lst, 0);

            void_obj = v_ast_generic_get_object(op);

            obj = *(void_obj: v_ast_operator_unary_ptr);

            *idx := (&obj[2] : v_ast_expr_list_ptr);
        }
    }

    v_return(true);
}

//---------------------------------------------------------------------
private
op_postfix_index_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                             self: v_ast_base_ptr) -> void
{
    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    N: &int := 1;

    {   ast: &v_ast_expr_ptr := v_list_get_item(args, 1);

        while(check_index(ast, &ast, 0))  ++N;
    }

    agg: &v_ast_expr_ptr := v_list_get_item(args, 1);

    idx = v_malloc(v_ast_expr_list_ptr, N);
    defer v_free(idx);

    {   idx_i: &*v_ast_expr_list_ptr := idx + (N-1);

        op = v_list_get_item(args, 0);

        void_obj = v_ast_generic_get_object(op);

        obj = *(void_obj: v_ast_operator_unary_ptr);

        *idx_i := (&obj[2] : v_ast_expr_list_ptr);

        while(check_index(agg, &agg, --idx_i)) ;
    }


    ttag = v_get_result_type();
    vtag = v_get_result_value();


    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor((agg: v_ast_base_ptr), vis);

    agg_t: &v_type_ptr   := v_get_result_type();
    agg_v: &LLVMValueRef := v_get_result_value();


    q = q_op_postfix_index;

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    for (i: &int := 0; i < N; ++i)
    {
        if (v_util_lookup_function_dict(agg_t, q, void_fun, void_aux, ft, fv))
        {
            //- Got overloading!

            intrinsic_t = (vis: voidc_visitor_ptr, aux: *void,
                           self: v_ast_base_ptr,
                           agg_t: v_type_ptr, agg_v: LLVMValueRef,
                           idx: *v_ast_expr_list_ptr, count: int
                          ) -> void;

            if (fun = (void_fun: *intrinsic_t))
            {
                v_set_result_type(ttag);
                v_set_result_value(vtag);

                fun(vis, void_aux, self, agg_t, agg_v, idx+i, N-i);

                v_return();
            }
            else
            {
                expr = v_alloca(v_ast_expr_t);
                v_initialize(expr);
                defer v_terminate(expr);

                idx_list = idx[i];

                arg_count = 1 + v_list_get_size(idx_list);

                arg_ptrs = v_malloc(v_ast_expr_ptr, arg_count);
                defer v_free(arg_ptrs);

                v_ast_make_expr_compiled(expr, agg_t, agg_v);

                arg_ptrs[0] := expr;

                for (j: &int := 1; j < arg_count; ++j)
                {
                    arg_ptrs[j] := v_list_get_item(idx_list, j-1);
                }

                agg_t := v_type_function_get_return_type(ft);

                v_set_result_type(agg_t);
                v_set_result_value(0);

                voidc_llvm_build_call_helper(vis, self, ft, fv, arg_ptrs, (arg_count: unsigned));

                agg_v := v_get_result_value();
            }
        }
        else
        {
            //- Default treatment...

            eidx = v_list_get_item(idx[i], 0);              //- Just one!

            v_set_result_type(INVIOLABLE_TAG);
            v_set_result_value(0);

            voidc_internal_op_postfix_index_helper(vis, eidx, agg_t, agg_v);

            agg_t := v_get_result_type();
            agg_v := v_get_result_value();
        }
    }

    v_set_result_type(ttag);
    v_set_result_value(vtag);

    v_adopt_result(agg_t, agg_v);
}


//---------------------------------------------------------------------
private
static_type_postfix_index_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                                      self: v_ast_base_ptr,
                                      agg_t: v_type_ptr, agg_v: LLVMValueRef,
                                      idx: *v_ast_expr_list_ptr, count: int
                                     ) -> void
{
    t: &v_type_ptr := (agg_v: *v_type_t);

    for (i: &int := count-1; i >= 0; --i)
    {
        idx_list = idx[i];

        idx_count = v_list_get_size(idx_list);

        if (idx_count)
        {
            expr = v_list_get_item(idx_list, 0);        //- Just one!

            v_set_result_type(UNREFERENCE_TAG);
            v_set_result_value(0);

            v_ast_accept_visitor((expr: v_ast_base_ptr), vis);

            idx_v = v_get_result_value();

            n = (LLVMConstIntGetZExtValue(idx_v) : uint64_t);

            t := v_array_type(t, n);
        }
        else    //- No indices!
        {
            typs = v_alloca(v_type_ptr, 2);

            incomplete_array_type_tag = v_struct_type_named_q(voidc_incomplete_array_type_tag);     //- Sic!

            typs[0] := incomplete_array_type_tag;
            typs[1] := t;

            t := v_struct_type(typs, 2, false);
        }
    }

    v_set_result_type(v_static_type_t);

    v_set_result_value((t: LLVMValueRef));
}


//---------------------------------------------------------------------
//- Enable overloading
//---------------------------------------------------------------------
export
voidc_enable_overloading_compiler: () -> void
{
    vis = v_get_compiler();

    q = v_quark_from_string;

    q_static_type_prefix_star = q("v.static_type_prefix_star");

    v_return_if(v_get_intrinsic_q(q_static_type_prefix_star, 0));

    voidc_visitor_set_void_method(vis, vis, expr_compiled_q,     compile_expr_compiled,     0);
    voidc_visitor_set_void_method(vis, vis, expr_compile_hook_q, compile_expr_compile_hook, 0);

    v_add_intrinsic_q(voidc_llvm_build_call_helper_q, voidc_llvm_build_call_helper_intrinsic, 0);

    for (id: &int := 0; op_table[id][0]; ++id)
    {
        void_fun: & *void := v_undef();

        switch(op_table[id][1])
        {
        case opk_assign:    void_fun := op_assign_intrinsic;    v_break();
        case opk_logical:   void_fun := 0;                      v_break();
        case opk_relation:  void_fun := op_relation_intrinsic;  v_break();
        case opk_binary:    void_fun := op_binary_intrinsic;    v_break();
        case opk_unary:     void_fun := op_unary_intrinsic;     v_break();
        }

        if (!void_fun)  v_continue();

        v_add_intrinsic_q(op_table[id][2], void_fun, (id: *void));
    }

    q_static_type_prefix_amp      = q("v.static_type_prefix_amp");
    q_static_type_prefix_const    = q("v.static_type_prefix_const");
    q_static_type_prefix_volatile = q("v.static_type_prefix_volatile");
    q_static_type_postfix_index   = q("v.static_type_postfix_index");

    v_util_function_dict_set(v_static_type_t, q("v.op_prefix_star"), q_static_type_prefix_star);
    v_util_function_dict_set(v_static_type_t, q("v.op_prefix_amp"),  q_static_type_prefix_amp);

    v_add_intrinsic_q(q_static_type_prefix_star, static_type_prefix_star_intrinsic, 0);
    v_add_intrinsic_q(q_static_type_prefix_amp,  static_type_prefix_amp_intrinsic,  0);

    v_util_function_dict_set(v_static_type_t, q("v.op_prefix_const"),    q_static_type_prefix_const);
    v_util_function_dict_set(v_static_type_t, q("v.op_prefix_volatile"), q_static_type_prefix_volatile);

    v_add_intrinsic_q(q_static_type_prefix_const,    static_type_prefix_cv_intrinsic, 0);
    v_add_intrinsic_q(q_static_type_prefix_volatile, static_type_prefix_cv_intrinsic, 0);

    voidc_visitor_set_void_method(vis, vis, expr_call_q, compile_expr_call, 0);

    v_add_intrinsic_q(q_op_postfix_index, op_postfix_index_intrinsic, 0);

    v_util_function_dict_set(v_static_type_t, q_op_postfix_index, q_static_type_postfix_index);

    v_add_intrinsic_q(q_static_type_postfix_index, static_type_postfix_index_intrinsic, 0);
}


//---------------------------------------------------------------------
//- Enable overloading
//---------------------------------------------------------------------
export
voidc_enable_overloading: () -> void
{
    voidc_enable_overloading_compiler();
}


//=====================================================================
{   voidc_unit_end_module(); }


//---------------------------------------------------------------------
{   ast_expr_compiled_vtable[2]     := expr_compiled_q;
    ast_expr_compile_hook_vtable[2] := expr_compile_hook_q;
}


