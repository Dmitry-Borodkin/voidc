//---------------------------------------------------------------------
//- Copyright (C) 2020-2023 Dmitry Borodkin <borodkin.dn@gmail.com>
//- SDPX-License-Identifier: LGPL-3.0-or-later
//---------------------------------------------------------------------
{   voidc_guard_target("overloading.void  must be imported into the voidc target only!");

    v_import("level-00");
    v_import("level-01");

    v_import("llvm-c/Core.void");

    v_import("unit_module.void");
    v_import("loops_etc.void");
    v_import("aggregates.void");

//  v_import("printf.void");
}

{   v_enable_level_01();

    voidc_enable_loops_etc();
    voidc_enable_aggregates();
}


//---------------------------------------------------------------------
{   q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("q_op_infix_lt", q_ref, q("v.op_infix_lt"));
    v_add_symbol("q_op_infix_le", q_ref, q("v.op_infix_le"));
    v_add_symbol("q_op_infix_gt", q_ref, q("v.op_infix_gt"));
    v_add_symbol("q_op_infix_ge", q_ref, q("v.op_infix_ge"));
    v_add_symbol("q_op_infix_eq", q_ref, q("v.op_infix_eq"));
    v_add_symbol("q_op_infix_ne", q_ref, q("v.op_infix_ne"));
}


//=====================================================================
{   voidc_unit_begin_module("op_table_module"); }


//---------------------------------------------------------------------
opk_assign   = 0;
opk_logical  = 1;
opk_relation = 2;
opk_binary   = 3;
opk_unary    = 4;

op_table_item_t = v_struct("struct.op_table_item",
{
    *const char,    //- 0 - Name
    int,            //- 1 - Kind
    v_quark_t,      //- 2 - Quark (left)
    v_quark_t       //- 3 - Quark (right)
});

op_table: &op_table_item_t[] :=
{
    {"v.op_infix_assign",      opk_assign   },
    {"v.op_infix_add_assign",  opk_assign   },
    {"v.op_infix_sub_assign",  opk_assign   },
    {"v.op_infix_mul_assign",  opk_assign   },
    {"v.op_infix_div_assign",  opk_assign   },
    {"v.op_infix_rem_assign",  opk_assign   },
    {"v.op_infix_shl_assign",  opk_assign   },
    {"v.op_infix_shr_assign",  opk_assign   },
    {"v.op_infix_and_assign",  opk_assign   },
    {"v.op_infix_xor_assign",  opk_assign   },
    {"v.op_infix_or_assign",   opk_assign   },

//  {"v.op_infix_to",          opk_binary   },          //- ?!?!?!?!?!?!?!?

    {"v.op_infix_logical_or",  opk_logical  },
    {"v.op_infix_logical_and", opk_logical  },

    {"v.op_infix_lt",          opk_relation },
    {"v.op_infix_le",          opk_relation },
    {"v.op_infix_gt",          opk_relation },
    {"v.op_infix_ge",          opk_relation },
    {"v.op_infix_eq",          opk_relation },
    {"v.op_infix_ne",          opk_relation },

    {"v.op_infix_or",          opk_binary   },
    {"v.op_infix_xor",         opk_binary   },
    {"v.op_infix_and",         opk_binary   },

    {"v.op_infix_shl",         opk_binary   },
    {"v.op_infix_shr",         opk_binary   },
    {"v.op_infix_add",         opk_binary   },
    {"v.op_infix_sub",         opk_binary   },
    {"v.op_infix_mul",         opk_binary   },
    {"v.op_infix_div",         opk_binary   },
    {"v.op_infix_rem",         opk_binary   },

    {"v.op_prefix_inc",        opk_unary    },
    {"v.op_prefix_dec",        opk_unary    },
    {"v.op_prefix_plus",       opk_unary    },
    {"v.op_prefix_minus",      opk_unary    },
    {"v.op_prefix_star",       opk_unary    },
    {"v.op_prefix_amp",        opk_unary    },
    {"v.op_prefix_bang",       opk_unary    },
    {"v.op_prefix_tilda",      opk_unary    },

    {"v.op_prefix_const",      opk_unary    },          //- ...
    {"v.op_prefix_volatile",   opk_unary    },          //- ...

    {"v.op_postfix_inc",       opk_unary    },
    {"v.op_postfix_dec",       opk_unary    },

    {0}     //- Sic...
};


//---------------------------------------------------------------------
op_table_ctor: () -> void
{
    sstr = v_alloca(v_std_string_t);
    v_initialize(sstr);
    defer v_terminate(sstr);

    int_ = v_type_get_llvm_type(int);

    for (i: &int := 0; name = op_table[i][0]; ++i)
    {
        op_table[i][2] := v_quark_from_string(name);

        if (k = op_table[i][1],  k == opk_binary  ||  k == opk_relation)
        {
            v_std_string_set(sstr, name);

            v_std_string_append(sstr, ".right");

            op_table[i][3] := v_quark_from_string(v_std_string_get(sstr));
        }

        v_std_string_set(sstr, "id");

        v_std_string_append(sstr, name+4);          //- Skip "v.op"

        v_add_constant(v_std_string_get(sstr), int, LLVMConstInt(int_, i, 0));
    }

    //-------------------------------------------------------------
    q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("expr_call_q",       q_ref, q("expr_call"));
    v_add_symbol("expr_identifier_q", q_ref, q("expr_identifier"));

    v_add_symbol("q_op_postfix_call",  q_ref, q("v.op_postfix_call"));
    v_add_symbol("q_op_postfix_index", q_ref, q("v.op_postfix_index"));
}


//=====================================================================
{   voidc_unit_end_module(); }


//---------------------------------------------------------------------
{   op_table_ctor();
}


//=====================================================================
{   voidc_unit_begin_module("overloading_module"); }


//---------------------------------------------------------------------
intrinsic_p1_t = (vis: voidc_visitor_ptr, aux: *void,
                  self: v_ast_base_ptr,
                  t0: v_type_ptr, v0: LLVMValueRef
                 ) -> void;

intrinsic_p2_t = (vis: voidc_visitor_ptr, aux: *void,
                  self: v_ast_base_ptr,
                  t0: v_type_ptr, v0: LLVMValueRef,
                  t1: v_type_ptr, v1: LLVMValueRef
                 ) -> void;


//---------------------------------------------------------------------
private
op_assign_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                      self: v_ast_base_ptr) -> void
{
    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    tt = v_get_result_type();

    v_set_result_type(INVIOLABLE_TAG);

    lhs = v_list_get_item(args, 1);             //- "Place"

    v_ast_accept_visitor((lhs : v_ast_base_ptr), vis);

    t0 = v_get_result_type();
    v0 = v_get_result_value();

    q = op_table[(aux: int)][2];    //- Quark

    builder = v_target_get_builder();

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    if (v_util_lookup_function_dict(vis, t0, q, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        if (fun = (void_fun: *intrinsic_p1_t))
        {
            v_set_result_type(tt);

            fun(vis, void_aux, self, t0, v0);
        }
        else
        {
            val: &LLVMValueRef[2] := v_undef();

            fpar = v_type_function_get_param_types(ft);

            v_set_result_type(fpar[0]);

            v_adopt_result(t0, v0);

            val[0] := v_get_result_value();

            v_set_result_type(fpar[1]);

            rhs = v_list_get_item(args, 2);             //- "Value"

            v_ast_accept_visitor((rhs : v_ast_base_ptr), vis);

            val[1] := v_get_result_value();

            ft_ = v_type_get_llvm_type(ft);

            vr = LLVMBuildCall2(builder, ft_, fv, &val[0], 2, "");

            v_set_result_type(tt);

            v_adopt_result(v_type_function_get_return_type(ft), vr);
        }

        v_return();
    }

    //- Default treatment...

    e0 = v_type_refptr_get_element_type(t0);

    switch((aux: int))
    {
    case id_infix_add_assign:
    case id_infix_sub_assign:

        if (v_type_is_pointer(e0))
        {
            v_set_result_type(intptr_t);

            v_break();
        }

        //- Fallthrough

    default:

        v_set_result_type(e0);
    }

    rhs = v_list_get_item(args, 2);             //- "Value"

    v_ast_accept_visitor((rhs : v_ast_base_ptr), vis);

    t1 = v_get_result_type();
    v1 = v_get_result_value();

    compile: &*((v_type_ptr, LLVMValueRef, LLVMValueRef) -> LLVMValueRef) := 0;

    switch((aux: int))
    {
    case id_infix_add_assign:   compile := voidc_internal_compile_add_helper;   v_break();
    case id_infix_sub_assign:   compile := voidc_internal_compile_sub_helper;   v_break();
    case id_infix_mul_assign:   compile := voidc_internal_compile_mul_helper;   v_break();
    case id_infix_div_assign:   compile := voidc_internal_compile_div_helper;   v_break();
    case id_infix_rem_assign:   compile := voidc_internal_compile_rem_helper;   v_break();
    case id_infix_shl_assign:   compile := voidc_internal_compile_shl_helper;   v_break();
    case id_infix_shr_assign:   compile := voidc_internal_compile_shr_helper;   v_break();
    case id_infix_and_assign:   compile := voidc_internal_compile_and_helper;   v_break();
    case id_infix_xor_assign:   compile := voidc_internal_compile_xor_helper;   v_break();
    case id_infix_or_assign:    compile := voidc_internal_compile_or_helper;    v_break();
    }


    vr: &LLVMValueRef := v1;

    if (compile)
    {
        v = LLVMBuildLoad2(builder, v_type_get_llvm_type(e0), v0, "");

        vr := compile(e0, v, v1);
    }
    else
    {
        if (v_type_is_pointer(v_type_get_scalar_type(e0)))      //- WTF ?!?!?!?
        {
            vr := v_convert_to_type(t1, v1, e0);
        }
    }

    LLVMBuildStore(builder, vr, v0);


    v_set_result_type(tt);

    v_adopt_result(t0, v0);
}


//---------------------------------------------------------------------
private
op_binary_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                      self: v_ast_base_ptr) -> void
{
    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    tt = v_get_result_type();

    //- First argument

    v_set_result_type(INVIOLABLE_TAG);

    lhs = v_list_get_item(args, 1);

    v_ast_accept_visitor((lhs : v_ast_base_ptr), vis);

    t0 = v_get_result_type();
    v0 = v_get_result_value();

    q0 = op_table[(aux: int)][2];       //- Quark (left)

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    builder = v_target_get_builder();

    if (v_util_lookup_function_dict(vis, t0, q0, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        if (fun = (void_fun: *intrinsic_p1_t))
        {
            v_set_result_type(tt);

            fun(vis, void_aux, self, t0, v0);
        }
        else
        {
            val: &LLVMValueRef[2] := v_undef();

            fpar = v_type_function_get_param_types(ft);

            v_set_result_type(fpar[0]);

            v_adopt_result(t0, v0);

            val[0] := v_get_result_value();

            v_set_result_type(fpar[1]);

            rhs = v_list_get_item(args, 2);

            v_ast_accept_visitor((rhs : v_ast_base_ptr), vis);

            val[1] := v_get_result_value();

            ft_ = v_type_get_llvm_type(ft);

            vr = LLVMBuildCall2(builder, ft_, fv, &val[0], 2, "");

            v_set_result_type(tt);

            v_adopt_result(v_type_function_get_return_type(ft), vr);
        }

        v_return();
    }

    //- Second argument

    v_set_result_type(INVIOLABLE_TAG);

    rhs = v_list_get_item(args, 2);

    v_ast_accept_visitor((rhs : v_ast_base_ptr), vis);

    t1 = v_get_result_type();
    v1 = v_get_result_value();

    q1 = op_table[(aux: int)][3];       //- Quark (right)

    if (v_util_lookup_function_dict(vis, t1, q1, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        if (fun = (void_fun: *intrinsic_p2_t))
        {
            v_set_result_type(tt);

            fun(vis, void_aux, self, t0, v0, t1, v1);
        }
        else
        {
            val: &LLVMValueRef[2] := v_undef();

            fpar = v_type_function_get_param_types(ft);

            v_set_result_type(fpar[0]);

            v_adopt_result(t0, v0);

            val[0] := v_get_result_value();

            v_set_result_type(fpar[1]);

            v_adopt_result(t1, v1);

            val[1] := v_get_result_value();

            ft_ = v_type_get_llvm_type(ft);

            vr = LLVMBuildCall2(builder, ft_, fv, &val[0], 2, "");

            v_set_result_type(tt);

            v_adopt_result(v_type_function_get_return_type(ft), vr);
        }

        v_return();
    }

    //- Default treatment...

    v_set_result_type(UNREFERENCE_TAG);

    v_adopt_result(t0, v0);

    t0: &v_type_ptr   := v_get_result_type();
    v0: &LLVMValueRef := v_get_result_value();

    v_set_result_type(UNREFERENCE_TAG);

    v_adopt_result(t1, v1);

    t1: &v_type_ptr   := v_get_result_type();
    v1: &LLVMValueRef := v_get_result_value();

    {   compile: &*((&v_type_ptr, &LLVMValueRef, &v_type_ptr, &LLVMValueRef) -> LLVMValueRef) := 0;

        switch((aux: int))
        {
        case id_infix_add:  compile := voidc_internal_compile_infix_add_helper; v_break();
        case id_infix_sub:  compile := voidc_internal_compile_infix_sub_helper; v_break();
        }

        if (compile)
        {
            v = compile(t0, v0, t1, v1);

            v_set_result_type(tt);

            v_adopt_result(t0, v);

            v_return();
        }
    }

    compile: &*((v_type_ptr, LLVMValueRef, LLVMValueRef) -> LLVMValueRef) := 0;

    switch((aux: int))
    {
    case id_infix_mul:  compile := voidc_internal_compile_mul_helper;   v_break();
    case id_infix_div:  compile := voidc_internal_compile_div_helper;   v_break();
    case id_infix_rem:  compile := voidc_internal_compile_rem_helper;   v_break();
    case id_infix_shl:  compile := voidc_internal_compile_shl_helper;   v_break();
    case id_infix_shr:  compile := voidc_internal_compile_shr_helper;   v_break();
    case id_infix_and:  compile := voidc_internal_compile_and_helper;   v_break();
    case id_infix_xor:  compile := voidc_internal_compile_xor_helper;   v_break();
    case id_infix_or:   compile := voidc_internal_compile_or_helper;    v_break();
    }

    voidc_internal_convert_to_common_type_helper(t0, v0, t1, v1);

    v = compile(t0, v0, v1);

    v_set_result_type(tt);

    v_adopt_result(t0, v);
}


//---------------------------------------------------------------------
private
check_relation: (arg: v_ast_expr_ptr, lhs: *v_ast_expr_ptr, rhs: *v_ast_expr_ptr) -> int
{
    get_tag = v_ast_base_get_visitor_method_tag;

    if (get_tag((arg: v_ast_base_ptr)) != expr_call_q)  v_return(0);

    etmp = v_ast_expr_call_get_fun_expr(arg);

    if (get_tag((etmp: v_ast_base_ptr)) != expr_identifier_q)  v_return(0);

    qname = v_ast_expr_identifier_get_name_q(etmp);

    rk: &int := v_undef();

    block
    {
        if (qname == q_op_infix_lt)  { rk := id_infix_lt; v_break(); }
        if (qname == q_op_infix_le)  { rk := id_infix_le; v_break(); }
        if (qname == q_op_infix_gt)  { rk := id_infix_gt; v_break(); }
        if (qname == q_op_infix_ge)  { rk := id_infix_ge; v_break(); }
        if (qname == q_op_infix_eq)  { rk := id_infix_eq; v_break(); }
        if (qname == q_op_infix_ne)  { rk := id_infix_ne; v_break(); }

        v_return(0);
    }

    if (lhs) ;
    else if (rhs) ;
    else
    {
        v_return(rk);
    }

    lst = v_ast_expr_call_get_arg_list(arg);

    if (lhs)  *lhs := v_list_get_item(lst, 1);
    if (rhs)  *rhs := v_list_get_item(lst, 2);

    v_return(rk);
}

//---------------------------------------------------------------------
private
op_relation_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                        self: v_ast_base_ptr) -> void
{
    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    N: &int := 2;

    {   ast: &v_ast_expr_ptr := v_list_get_item(args, 1);

        while(check_relation(ast, &ast, 0)) ++N;
    }

    ast = v_malloc(v_ast_expr_ptr, N);
    defer v_free(ast);

    Nm1 = N - 1;

    rel = v_malloc(int, Nm1);
    defer v_free(rel);

    {   i = N - 2;

        ast_i: &*v_ast_expr_ptr := ast + i;
        rel_i: &*int            := rel + i;

        ast_i[0] := v_list_get_item(args, 1);
        ast_i[1] := v_list_get_item(args, 2);

        *rel_i := (aux: int);

        while(ast_i1 = ast_i-1, rk = check_relation(*ast_i, ast_i1, ast_i))
        {
            ast_i := ast_i1;
            rel_i := rel_i - 1;

            *rel_i := rk;
        }
    }


    tt = v_get_result_type();

    builder = v_target_get_builder();

    cur_b = LLVMGetInsertBlock(builder);

    cur_f = LLVMGetBasicBlockParent(cur_b);

    cmp_result_v: &LLVMValueRef := 0;

    branch_if_false_b: &LLVMBasicBlockRef := 0;

    _bool = v_find_type("bool");

    bool_ = v_type_get_llvm_type(_bool);

    if (N != 2)
    {
        cmp_result_v := LLVMBuildAlloca(builder, bool_, "");

        LLVMBuildStore(builder, LLVMConstNull(bool_), cmp_result_v);

        branch_if_false_b := LLVMAppendBasicBlock(cur_f, "branch_if_false_b");
    }


    v_set_result_type(INVIOLABLE_TAG);

    v_ast_accept_visitor((ast[0] : v_ast_base_ptr), vis);

    typ: &v_type_ptr   := v_get_result_type();
    val: &LLVMValueRef := v_get_result_value();

    t0: &v_type_ptr   := v_undef();
    v0: &LLVMValueRef := v_undef();
    t1: &v_type_ptr   := v_undef();
    v1: &LLVMValueRef := v_undef();

    r: &LLVMValueRef := v_undef();

    for (i: &int := 0; i < Nm1; ++i)
    {
        r := 0;

        rel_i = rel[i];

        //- First argument

        t0 := typ;
        v0 := val;

        q0 = op_table[rel_i][2];            //- Quark (left)

        void_fun: &*void := 0;
        void_aux: &*void := 0;

        ft: &v_type_ptr   := 0;
        fv: &LLVMValueRef := 0;

        if (v_util_lookup_function_dict(vis, typ, q0, void_fun, void_aux, ft, fv))
        {
            //- Got overloading!

            intrinsic_p12_t = (vis: voidc_visitor_ptr, aux: *void,
                               ast: *v_ast_expr_ptr,
                               t0:  v_type_ptr, v0:  LLVMValueRef,
                               t1: &v_type_ptr, v1: &LLVMValueRef
                              ) -> void;

            if (fun = (void_fun: *intrinsic_p12_t))
            {
                v_set_result_type(tt);      //- Sic !?!

                fun(vis, void_aux, ast+i, t0, v0, t1, v1);
            }
            else
            {
                vv: &LLVMValueRef[2] := v_undef();

                fpar = v_type_function_get_param_types(ft);

                v_set_result_type(fpar[0]);

                v_adopt_result(t0, v0);

                vv[0] := v_get_result_value();

                v_set_result_type(fpar[1]);

                v_ast_accept_visitor((ast[i+1] : v_ast_base_ptr), vis);

                t1 := v_get_result_type();
                v1 := v_get_result_value();

                vv[1] := v1;

                ft_ = v_type_get_llvm_type(ft);

                vr = LLVMBuildCall2(builder, ft_, fv, &vv[0], 2, "");

                v_set_result_type(tt);      //- Sic !?!

                v_adopt_result(v_type_function_get_return_type(ft), vr);
            }

            r := v_get_result_value();
        }
        else
        {
            //- Second argument

            v_set_result_type(INVIOLABLE_TAG);

            v_ast_accept_visitor((ast[i+1] : v_ast_base_ptr), vis);

            t1 := v_get_result_type();
            v1 := v_get_result_value();

            q1 = op_table[rel_i][3];            //- Quark (right)

            if (v_util_lookup_function_dict(vis, t1, q1, void_fun, void_aux, ft, fv))
            {
                //- Got overloading!

                intrinsic_p22_t = (vis: voidc_visitor_ptr, aux: *void,
                                   ast: *v_ast_expr_ptr,
                                   t0: v_type_ptr, v0: LLVMValueRef,
                                   t1: v_type_ptr, v1: LLVMValueRef
                                  ) -> void;

                if (fun = (void_fun: *intrinsic_p22_t))
                {
                    v_set_result_type(tt);      //- Sic !?!

                    fun(vis, void_aux, ast+i, t0, v0, t1, v1);
                }
                else
                {
                    vv: &LLVMValueRef[2] := v_undef();

                    fpar = v_type_function_get_param_types(ft);

                    v_set_result_type(fpar[0]);

                    v_adopt_result(t0, v0);

                    vv[0] := v_get_result_value();

                    v_set_result_type(fpar[1]);

                    v_adopt_result(t1, v1);

                    vv[1] := v_get_result_value();

                    ft_ = v_type_get_llvm_type(ft);

                    vr = LLVMBuildCall2(builder, ft_, fv, &vv[0], 2, "");

                    v_set_result_type(tt);      //- Sic !?!

                    v_adopt_result(v_type_function_get_return_type(ft), vr);
                }

                r := v_get_result_value();
            }
        }

        typ := t1;
        val := v1;

        if (!r)
        {
            //- Default treatment...

            v_set_result_type(UNREFERENCE_TAG);

            v_adopt_result(t0, v0);

            t0 := v_get_result_type();
            v0 := v_get_result_value();

            v_set_result_type(UNREFERENCE_TAG);

            v_adopt_result(t1, v1);

            t1 := v_get_result_type();
            v1 := v_get_result_value();

            voidc_internal_convert_to_common_type_helper(t0, v0, t1, v1);


            st = v_type_get_scalar_type(t0);


            if (v_type_is_floating_point(st))
            {
                opc: &LLVMRealPredicate := v_undef();

                switch(rel_i)
                {
                case id_infix_eq: opc := LLVMRealOEQ; v_break();    //- 'O' ?...
                case id_infix_ne: opc := LLVMRealUNE; v_break();    //- 'U' ?!?!?..
                case id_infix_lt: opc := LLVMRealOLT; v_break();    //- 'O' ?...
                case id_infix_le: opc := LLVMRealOLE; v_break();    //- 'O' ?...
                case id_infix_gt: opc := LLVMRealOGT; v_break();    //- 'O' ?...
                case id_infix_ge: opc := LLVMRealOGE; v_break();    //- 'O' ?...
                }

                r := LLVMBuildFCmp(builder, opc, v0, v1, "");
            }
            else
            {
                opc: &LLVMIntPredicate := v_undef();

                s: &bool := false;

                if (v_type_is_integer(st))  s := v_type_integer_is_signed(st);

                switch(rel_i)
                {
                case id_infix_eq: opc := LLVMIntEQ; v_break();
                case id_infix_ne: opc := LLVMIntNE; v_break();

                case id_infix_lt: if (s)  opc := LLVMIntSLT;  else  opc := LLVMIntULT;  v_break();
                case id_infix_le: if (s)  opc := LLVMIntSLE;  else  opc := LLVMIntULE;  v_break();
                case id_infix_gt: if (s)  opc := LLVMIntSGT;  else  opc := LLVMIntUGT;  v_break();
                case id_infix_ge: if (s)  opc := LLVMIntSGE;  else  opc := LLVMIntUGE;  v_break();
                }

                r := LLVMBuildICmp(builder, opc, v0, v1, "");
            }
        }

        if (branch_if_false_b)
        {
            if (i < N-2)
            {
                branch_if_true_b = LLVMAppendBasicBlock(cur_f, "branch_if_true_b");

                LLVMBuildCondBr(builder, r, branch_if_true_b, branch_if_false_b);

                LLVMPositionBuilderAtEnd(builder, branch_if_true_b);
            }
            else        //- Last ...
            {
                LLVMBuildStore(builder, r, cmp_result_v);

                LLVMBuildBr(builder, branch_if_false_b);

                cur_b = LLVMGetInsertBlock(builder);

                LLVMMoveBasicBlockAfter(branch_if_false_b, cur_b);

                LLVMPositionBuilderAtEnd(builder, branch_if_false_b);

                r := LLVMBuildLoad2(builder, bool_, cmp_result_v, "");
            }
        }
    }


    if (v_type_is_vector(t0))
    {
        sz = v_type_vector_get_size(t0);

        if (v_type_vector_is_scalable(t0))
        {
            t0 := v_svector_type(_bool, sz);
        }
        else
        {
            t0 := v_vector_type(_bool, sz);
        }
    }
    else
    {
        t0 := _bool;
    }


    v_set_result_type(tt);

    v_adopt_result(t0, r);
}


//---------------------------------------------------------------------
private
inc_dec_helper: (vis: voidc_visitor_ptr, t: &v_type_ptr, v: LLVMValueRef, delta: int, is_pref: bool) -> LLVMValueRef
{
    et = v_type_refptr_get_element_type(t);

    st = v_type_get_scalar_type(et);


    step = v_alloca(v_ast_expr_t);
    v_initialize(step);
    defer v_terminate(step);

    v_ast_make_expr_integer(step, delta);

    step_base = (step: v_ast_base_ptr);


    pf = v_type_is_pointer(st);

    if (pf) v_set_result_type(int);         //- ?
    else    v_set_result_type(st);

    v_ast_accept_visitor(step_base, vis);

    step_t = v_get_result_type();
    step_v = v_get_result_value();


    var_v: &LLVMValueRef := v_undef();

    if (v_type_is_vector(et))
    {
        var_t: &v_type_ptr := et;

        voidc_internal_vectorize_scalar(step_t, step_v, var_t, var_v);
    }
    else
    {
        var_v := step_v;
    }


    builder = v_target_get_builder();

    ev = LLVMBuildLoad2(builder, v_type_get_llvm_type(et), v, "");

    if (pf)
    {
        est = v_type_refptr_get_element_type(st);

        var_v := LLVMBuildGEP2(builder, v_type_get_llvm_type(est), ev, &var_v, 1, "");
    }
    else if (v_type_is_floating_point(st))
    {
        var_v := LLVMBuildFAdd(builder, ev, var_v, "");
    }
    else
    {
        var_v := LLVMBuildAdd(builder, ev, var_v, "");
    }

    LLVMBuildStore(builder, var_v, v);


    if (is_pref)
    {
        v_return(v);
    }
    else
    {
        t := et;

        v_return(ev);
    }
}

//---------------------------------------------------------------------
private
compile_prefix_inc_helper: (vis: voidc_visitor_ptr, t: &v_type_ptr, v: LLVMValueRef) -> LLVMValueRef
{
    v_return(inc_dec_helper(vis, t, v, 1, true));
}

//---------------------------------------------------------------------
private
compile_prefix_dec_helper: (vis: voidc_visitor_ptr, t: &v_type_ptr, v: LLVMValueRef) -> LLVMValueRef
{
    v_return(inc_dec_helper(vis, t, v, -1, true));
}

//---------------------------------------------------------------------
private
compile_prefix_plus_helper: (vis: voidc_visitor_ptr, t: &v_type_ptr, v: LLVMValueRef) -> LLVMValueRef
{
    v_return(v);
}

//---------------------------------------------------------------------
private
compile_prefix_minus_helper: (vis: voidc_visitor_ptr, t: &v_type_ptr, v: LLVMValueRef) -> LLVMValueRef
{
    v_set_result_type(UNREFERENCE_TAG);

    v_adopt_result(t, v);

    t := v_get_result_type();

    v = v_get_result_value();

    builder = v_target_get_builder();

    if (v_type_is_floating_point(v_type_get_scalar_type(t)))
    {
        v_return(LLVMBuildFNeg(builder, v, ""));
    }
    else
    {
        v_return(LLVMBuildNeg(builder, v, ""));
    }
}

//---------------------------------------------------------------------
private
compile_prefix_star_helper: (vis: voidc_visitor_ptr, t: &v_type_ptr, v: LLVMValueRef) -> LLVMValueRef
{
    vr: &LLVMValueRef := v;

    if (v_type_is_reference(t))
    {
        t := v_type_refptr_get_element_type(t);

        builder = v_target_get_builder();

        vr := LLVMBuildLoad2(builder, v_type_get_llvm_type(t), v, "");
    }

    e = v_type_refptr_get_element_type(t);
    a = v_type_refptr_get_address_space(t);

    t := v_reference_type(e, a);

    v_return(vr);
}

//---------------------------------------------------------------------
private
compile_prefix_amp_helper: (vis: voidc_visitor_ptr, t: &v_type_ptr, v: LLVMValueRef) -> LLVMValueRef
{
    vr: &LLVMValueRef := v;

    if (v_type_is_reference(t))
    {
        e = v_type_refptr_get_element_type(t);
        a = v_type_refptr_get_address_space(t);

        t := v_pointer_type(e, a);
    }
    else
    {
        vr := v_make_temporary(t, v);

        t := v_pointer_type(t, 0);
    }

    v_return(vr);
}

//---------------------------------------------------------------------
private
compile_prefix_bang_helper: (vis: voidc_visitor_ptr, t: &v_type_ptr, v: LLVMValueRef) -> LLVMValueRef
{
    v_set_result_type(UNREFERENCE_TAG);

    v_adopt_result(t, v);

    t := v_get_result_type();

    v = v_get_result_value();

    builder = v_target_get_builder();

    vr = LLVMBuildIsNull(builder, v, "");

    if (v_type_is_vector(t))
    {
        b = v_find_type("bool");

        sz = v_type_vector_get_size(t);

        s = v_type_vector_is_scalable(t);

        if (s)  t := v_svector_type(b, sz);
        else    t := v_vector_type(b, sz);
    }
    else
    {
        t := v_find_type("bool");
    }

    v_return(vr);
}

//---------------------------------------------------------------------
private
compile_prefix_tilda_helper: (vis: voidc_visitor_ptr, t: &v_type_ptr, v: LLVMValueRef) -> LLVMValueRef
{
    v_set_result_type(UNREFERENCE_TAG);

    v_adopt_result(t, v);

    t := v_get_result_type();

    v = v_get_result_value();

    builder = v_target_get_builder();

    v_return(LLVMBuildNot(builder, v, ""));
}

//---------------------------------------------------------------------
private
compile_postfix_inc_helper: (vis: voidc_visitor_ptr, t: &v_type_ptr, v: LLVMValueRef) -> LLVMValueRef
{
    v_return(inc_dec_helper(vis, t, v, 1, false));
}

//---------------------------------------------------------------------
private
compile_postfix_dec_helper: (vis: voidc_visitor_ptr, t: &v_type_ptr, v: LLVMValueRef) -> LLVMValueRef
{
    v_return(inc_dec_helper(vis, t, v, -1, false));
}


//---------------------------------------------------------------------
private
op_unary_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                     self: v_ast_base_ptr) -> void
{
    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    tt = v_get_result_type();

    v_set_result_type(INVIOLABLE_TAG);

    arg = v_list_get_item(args, 1);

    v_ast_accept_visitor((arg: v_ast_base_ptr), vis);

    t0 = v_get_result_type();
    v0 = v_get_result_value();

    builder = v_target_get_builder();

    q = op_table[(aux: int)][2];    //- Quark

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    if (v_util_lookup_function_dict(vis, t0, q, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        if (fun = (void_fun: *intrinsic_p1_t))
        {
            v_set_result_type(tt);

            fun(vis, void_aux, self, t0, v0);
        }
        else
        {
            val: &LLVMValueRef := v_undef();

            fpar = v_type_function_get_param_types(ft);

            v_set_result_type(fpar[0]);

            v_adopt_result(t0, v0);

            val := v_get_result_value();

            ft_ = v_type_get_llvm_type(ft);

            vr = LLVMBuildCall2(builder, ft_, fv, &val, 1, "");

            v_set_result_type(tt);

            v_adopt_result(v_type_function_get_return_type(ft), vr);
        }

        v_return();
    }

    //- Default treatment...

    compile: &*((voidc_visitor_ptr, &v_type_ptr, LLVMValueRef) -> LLVMValueRef) := 0;

    switch((aux: int))
    {
    case id_prefix_inc:     compile := compile_prefix_inc_helper;    v_break();
    case id_prefix_dec:     compile := compile_prefix_dec_helper;    v_break();
    case id_prefix_plus:    compile := compile_prefix_plus_helper;   v_break();
    case id_prefix_minus:   compile := compile_prefix_minus_helper;  v_break();
    case id_prefix_star:    compile := compile_prefix_star_helper;   v_break();
    case id_prefix_amp:     compile := compile_prefix_amp_helper;    v_break();
    case id_prefix_bang:    compile := compile_prefix_bang_helper;   v_break();
    case id_prefix_tilda:   compile := compile_prefix_tilda_helper;  v_break();
    case id_postfix_inc:    compile := compile_postfix_inc_helper;   v_break();
    case id_postfix_dec:    compile := compile_postfix_dec_helper;   v_break();
    }

    t0: &v_type_ptr := t0;          //- Sic!

    v = compile(vis, t0, v0);

    v_set_result_type(tt);

    v_adopt_result(t0, v);
}


//---------------------------------------------------------------------
private
static_type_prefix_star_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                                    self: v_ast_base_ptr,
                                    t0: v_type_ptr, v0: LLVMValueRef
                                   ) -> void
{
    //- assert(t0 == v_static_type_t);

    typ = (v0: v_type_ptr);

    typ = v_pointer_type(typ, 0);           //- ...

    v_set_result_type(v_static_type_t);
    v_set_result_value((typ: LLVMValueRef));
}

//---------------------------------------------------------------------
private
static_type_prefix_amp_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                                   self: v_ast_base_ptr,
                                   t0: v_type_ptr, v0: LLVMValueRef
                                  ) -> void
{
    //- assert(t0 == v_static_type_t);

    typ = (v0: v_type_ptr);

    typ = v_reference_type(typ, 0);         //- ...

    v_set_result_type(v_static_type_t);
    v_set_result_value((typ: LLVMValueRef));
}

//---------------------------------------------------------------------
private
static_type_prefix_cv_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                                  self: v_ast_base_ptr,
                                  t0: v_type_ptr, v0: LLVMValueRef
                                 ) -> void
{
    //- assert(t0 == v_static_type_t);

    typ = (v0: v_type_ptr);

    //-----------------------------------------------------------------
    //- Just "ignore" it...
    //-----------------------------------------------------------------

    v_set_result_type(v_static_type_t);
    v_set_result_value((typ: LLVMValueRef));
}


//---------------------------------------------------------------------
export
voidc_internal_compile_expr_call_helper: (vis: voidc_visitor_ptr,
                                          self: v_ast_base_ptr,
                                          args: v_ast_expr_list_ptr,
                                          t: v_type_ptr, v: LLVMValueRef
                                         ) -> void
{
    tt = v_get_result_type();

    void_fun: &*void := 0;
    void_aux: &*void := v_undef();

    builder = v_target_get_builder();

    q = q_op_postfix_call;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    if (v_util_lookup_function_dict(vis, t, q, void_fun, void_aux, ft, fv))
    {
        //- Got overloading!

        intrinsic_t = (vis: voidc_visitor_ptr, aux: *void,
                       self: v_ast_base_ptr,
                       args: v_ast_expr_list_ptr,
                       t0: v_type_ptr, v0: LLVMValueRef
                      ) -> void;

        if (fun = (void_fun: *intrinsic_t))
        {
            v_set_result_type(tt);

            fun(vis, void_aux, self, args, t, v);

            v_return();
        }
    }

    i0: &int := 0;

    if (ft)     //- Overloaded...
    {
        i0 := 1;
    }
    else        //- "Normal"...
    {
        v_set_result_type(UNREFERENCE_TAG);

        v_adopt_result(t, v);

        ft := v_get_result_type();
        fv := v_get_result_value();
    }

    if (v_type_is_pointer(ft))  ft := v_type_refptr_get_element_type(ft);

    par_count = v_type_function_get_param_count(ft);
    par_types = v_type_function_get_param_types(ft);

    arg_count = i0 + v_list_get_size(args);

    values = v_malloc(LLVMValueRef, arg_count);
    defer v_free(values);

    for (i: &int := 0; i < arg_count; ++i)
    {
        if (i == 0  &&  i0 == 1)
        {
            v_set_result_type(par_types[0]);

            v_adopt_result(t, v);
        }
        else
        {
            if (i < par_count)  v_set_result_type(par_types[i]);
            else                v_set_result_type(UNREFERENCE_TAG);

            expr = v_list_get_item(args, i-i0);

            v_ast_accept_visitor((expr: v_ast_base_ptr), vis);
        }

        values[i] := v_get_result_value();
    }

    ft_ = v_type_get_llvm_type(ft);

    vr = LLVMBuildCall2(builder, ft_, fv, values, arg_count, "");


    tr = v_type_function_get_return_type(ft);

    v_set_result_type(tt);

    v_adopt_result(tr, vr);
}

//---------------------------------------------------------------------
private
compile_expr_call: (vis: voidc_visitor_ptr, *void,
                    self: v_ast_base_ptr) -> void
{
    fexpr = v_ast_expr_call_get_fun_expr((self: v_ast_expr_ptr));
    args  = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    void_fun: &*void := 0;
    void_aux: &*void := v_undef();

    if (v_ast_base_get_visitor_method_tag((fexpr: v_ast_base_ptr)) == v_ast_expr_identifier_visitor_method_tag)
    block
    {
        fname_q = v_ast_expr_identifier_get_name_q(fexpr);

        if (void_fun := v_get_intrinsic_q(fname_q, &void_aux))  v_break();

        if (void_fun := voidc_visitor_get_intrinsic(vis, fname_q, &void_aux)) v_break();
    }

    if (fun = (void_fun: *voidc_intrinsic_t))       //- Compile-time intrinsic?
    {
        fun(vis, void_aux, self);

        v_return();
    }

    //- Function call (kinda...)

    tt = v_get_result_type();

    v_set_result_type(INVIOLABLE_TAG);

    v_ast_accept_visitor((fexpr: v_ast_base_ptr), vis);

    t = v_get_result_type();
    v = v_get_result_value();

    v_set_result_type(tt);

    voidc_internal_compile_expr_call_helper(vis, self, args, t, v);
}


//---------------------------------------------------------------------
export
voidc_internal_op_postfix_index_helper: (vis: voidc_visitor_ptr,
                                         eidx: v_ast_expr_ptr,
                                         t0: v_type_ptr, v0: LLVMValueRef
                                        ) -> void
{
    tt = v_get_result_type();

    v_set_result_type(UNREFERENCE_TAG);

    v_ast_accept_visitor((eidx: v_ast_base_ptr), vis);

    idx_t: &v_type_ptr   := v_get_result_type();
    idx_v: &LLVMValueRef := v_get_result_value();

    block
    {
        st = v_type_get_scalar_type(idx_t);

        if (!v_type_is_integer(st))        v_break();
        if (v_type_integer_is_signed(st))  v_break();

        w = v_type_integer_get_width(st);

        if (w >= 32)  v_break();

        t1: &v_type_ptr := v_uint_type(32);

        if (v_type_is_vector(idx_t))
        {
            count = v_type_vector_get_size(idx_t);

            if (v_type_vector_is_scalable(idx_t))  t1 := v_svector_type(t1, count);
            else                                   t1 := v_vector_type(t1, count);
        }

        v_set_result_type(t1);

        v_adopt_result(idx_t, idx_v);

        idx_t := v_get_result_type();
        idx_v := v_get_result_value();
    }

    agg_t: &v_type_ptr   := t0;
    agg_v: &LLVMValueRef := v0;

    builder = v_target_get_builder();

    if (v_type_is_reference(agg_t))
    {
        e = v_type_refptr_get_element_type(agg_t);

        if (v_type_is_pointer(e))
        {
            agg_t := e;

            agg_v := LLVMBuildLoad2(builder, v_type_get_llvm_type(agg_t), agg_v, "agg");
        }
    }

    t: &v_type_ptr   := v_undef();
    v: &LLVMValueRef := v_undef();

    if (v_type_is_pointer(agg_t))
    {
        v := idx_v;     //- Sic...

        e = v_type_refptr_get_element_type(agg_t);

        v := LLVMBuildGEP2(builder, v_type_get_llvm_type(e), agg_v, &v, 1, "");

        a = v_type_refptr_get_address_space(agg_t);

        t := v_reference_type(e, a);
    }
    else if (v_type_is_reference(agg_t))
    {
        n0 = LLVMConstInt(v_type_get_llvm_type(int), 0, 0);

        idxx: &LLVMValueRef[2] := {n0, idx_v};

        e = v_type_refptr_get_element_type(agg_t);

        v := LLVMBuildGEP2(builder, v_type_get_llvm_type(e), agg_v, &idxx[0], 2, "");

        a = v_type_refptr_get_address_space(agg_t);

        if (v_type_is_struct(e))
        {
            i = (LLVMConstIntGetZExtValue(idx_v) : unsigned);

            e = v_type_struct_get_element_types(e)[i];

            t := v_reference_type(e, a);
        }
        else if (v_type_is_array(e))
        {
            e = v_type_array_get_element_type(e);

            t := v_reference_type(e, a);
        }
        else    //- assert(v_type_is_vector(e)); ...
        {
            e = v_type_vector_get_element_type(e);

            t := v_reference_type(e, a);
        }
    }
    else    //- Just aggregate value
    {
        if (v_type_is_vector(agg_t))
        {
            v := LLVMBuildExtractElement(builder, agg_v, idx_v, "");

            t := v_type_vector_get_element_type(agg_t);
        }
        else
        {
            i = (LLVMConstIntGetZExtValue(idx_v) : unsigned);

            v := LLVMBuildExtractValue(builder, agg_v, i, "");

            if (v_type_is_struct(agg_t))
            {
                t := v_type_struct_get_element_types(agg_t)[i];
            }
            else    //- assert(v_type_is_array(agg_t));
            {
                t := v_type_array_get_element_type(agg_t);
            }
        }
    }

    v_set_result_type(tt);

    v_adopt_result(t, v);
}

//---------------------------------------------------------------------
private
check_index: (arg: *v_ast_expr_t, agg: **v_ast_expr_t, idx: **v_ast_expr_list_t) -> bool
{
    tag = v_ast_base_get_visitor_method_tag((arg: v_ast_base_ptr));

    if (tag != expr_call_q)  v_return(false);

    etmp = v_ast_expr_call_get_fun_expr(arg);

    tag = v_ast_base_get_visitor_method_tag((etmp: v_ast_base_ptr));

    if (tag != expr_identifier_q)  v_return(false);

    qname = v_ast_expr_identifier_get_name_q(etmp);

    if (qname != q_op_postfix_index)  v_return(false);

    if (agg  ||  idx)
    {
        lst = v_ast_expr_call_get_arg_list(arg);

        if (agg)  *agg := v_list_get_item(lst, 1);

        if (idx)
        {
            op = v_list_get_item(lst, 0);

            void_obj = v_ast_generic_get_object(op);

            obj = *(void_obj: v_ast_operator_unary_ptr);

            *idx := (&obj[2] : v_ast_expr_list_ptr);
        }
    }

    v_return(true);
}

//---------------------------------------------------------------------
private
op_postfix_index_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                             self: v_ast_base_ptr) -> void
{
    args = v_ast_expr_call_get_arg_list((self: v_ast_expr_ptr));

    N: &int := 1;

    {   ast: &v_ast_expr_ptr := v_list_get_item(args, 1);

        while(check_index(ast, &ast, 0))  ++N;
    }

    agg: &v_ast_expr_ptr := v_list_get_item(args, 1);

    idx = v_malloc(v_ast_expr_list_ptr, N);
    defer v_free(idx);

    {   idx_i: &*v_ast_expr_list_ptr := idx + (N-1);

        op = v_list_get_item(args, 0);

        void_obj = v_ast_generic_get_object(op);

        obj = *(void_obj: v_ast_operator_unary_ptr);

        *idx_i := (&obj[2] : v_ast_expr_list_ptr);

        while(check_index(agg, &agg, --idx_i)) ;
    }


    tt = v_get_result_type();


    v_set_result_type(INVIOLABLE_TAG);

    v_ast_accept_visitor((agg: v_ast_base_ptr), vis);

    agg_t: &v_type_ptr   := v_get_result_type();
    agg_v: &LLVMValueRef := v_get_result_value();


    builder = v_target_get_builder();

    q = q_op_postfix_index;

    void_fun: &*void := 0;
    void_aux: &*void := 0;

    ft: &v_type_ptr   := 0;
    fv: &LLVMValueRef := 0;

    for (i: &int := 0; i < N; ++i)
    {
        if (v_util_lookup_function_dict(vis, agg_t, q, void_fun, void_aux, ft, fv))
        {
            //- Got overloading!

            intrinsic_t = (vis: voidc_visitor_ptr, aux: *void,
                           self: v_ast_base_ptr,
                           agg_t: v_type_ptr, agg_v: LLVMValueRef,
                           idx: *v_ast_expr_list_ptr, count: int
                          ) -> void;

            if (fun = (void_fun: *intrinsic_t))
            {
                v_set_result_type(tt);

                fun(vis, void_aux, self, agg_t, agg_v, idx+i, N-i);

                v_return();
            }
            else
            {
                par_count = v_type_function_get_param_count(ft);
                par_types = v_type_function_get_param_types(ft);

                idx_list = idx[i];

                arg_count = 1 + v_list_get_size(idx_list);

                values = v_malloc(LLVMValueRef, arg_count);
                defer v_free(values);

                for (j: &int := 0; j < arg_count; ++j)
                {
                    if (j == 0)
                    {
                        v_set_result_type(par_types[0]);

                        v_adopt_result(agg_t, agg_v);
                    }
                    else
                    {
                        if (j < par_count)  v_set_result_type(par_types[j]);
                        else                v_set_result_type(UNREFERENCE_TAG);

                        etmp = v_list_get_item(idx_list, j-1);

                        v_ast_accept_visitor((etmp: v_ast_base_ptr), vis);
                    }

                    values[j] := v_get_result_value();
                }

                ft_ = v_type_get_llvm_type(ft);

                agg_v := LLVMBuildCall2(builder, ft_, fv, values, arg_count, "");

                agg_t := v_type_function_get_return_type(ft);
            }
        }
        else
        {
            //- Default treatment...

            eidx = v_list_get_item(idx[i], 0);              //- Just one!

            v_set_result_type(INVIOLABLE_TAG);

            voidc_internal_op_postfix_index_helper(vis, eidx, agg_t, agg_v);

            agg_t := v_get_result_type();
            agg_v := v_get_result_value();
        }
    }

    v_set_result_type(tt);

    v_adopt_result(agg_t, agg_v);
}


//---------------------------------------------------------------------
private
static_type_postfix_index_intrinsic: (vis: voidc_visitor_ptr, aux: *void,
                                      self: v_ast_base_ptr,
                                      agg_t: v_type_ptr, agg_v: LLVMValueRef,
                                      idx: *v_ast_expr_list_ptr, count: int
                                     ) -> void
{
    t: &v_type_ptr := (agg_v: *v_type_t);

    for (i: &int := count-1; i >= 0; --i)
    {
        idx_list = idx[i];

        idx_count = v_list_get_size(idx_list);

        if (idx_count)
        {
            expr = v_list_get_item(idx_list, 0);        //- Just one!

            v_set_result_type(UNREFERENCE_TAG);

            v_ast_accept_visitor((expr: v_ast_base_ptr), vis);

            idx_v = v_get_result_value();

            n = (LLVMConstIntGetZExtValue(idx_v) : uint64_t);

            t := v_array_type(t, n);
        }
        else    //- No indices!
        {
            typs = v_alloca(v_type_ptr, 2);

            incomplete_array_type_tag = v_struct_type_named("voidc.incomplete_array_type_tag");     //- Sic!

            typs[0] := incomplete_array_type_tag;
            typs[1] := t;

            t := v_struct_type(typs, 2, false);
        }
    }

    v_set_result_type(v_static_type_t);

    v_set_result_value((t: LLVMValueRef));
}


//---------------------------------------------------------------------
//- Enable overloading
//---------------------------------------------------------------------
export
voidc_enable_overloading_compiler: () -> void
{
    vis = voidc_compiler;

    q = v_quark_from_string;

    v_return_if(voidc_visitor_get_intrinsic(vis, q("v.static_type_prefix_star"), 0));

    for (id: &int := 0; op_table[id][0]; ++id)
    {
        void_fun: & *void := v_undef();

        switch(op_table[id][1])
        {
        case opk_assign:    void_fun := op_assign_intrinsic;    v_break();
        case opk_logical:   void_fun := 0;                      v_break();
        case opk_relation:  void_fun := op_relation_intrinsic;  v_break();
        case opk_binary:    void_fun := op_binary_intrinsic;    v_break();
        case opk_unary:     void_fun := op_unary_intrinsic;     v_break();
        }

        if (!void_fun)  v_continue();

        voidc_visitor_set_intrinsic(vis, vis, op_table[id][2], void_fun, (id: *void));
    }

    q_static_type_prefix_star     = q("v.static_type_prefix_star");
    q_static_type_prefix_amp      = q("v.static_type_prefix_amp");
    q_static_type_prefix_const    = q("v.static_type_prefix_const");
    q_static_type_prefix_volatile = q("v.static_type_prefix_volatile");
    q_static_type_postfix_index   = q("v.static_type_postfix_index");

    voidc_visitor_function_dict_set(vis, vis, v_static_type_t, q("v.op_prefix_star"), q_static_type_prefix_star);
    voidc_visitor_function_dict_set(vis, vis, v_static_type_t, q("v.op_prefix_amp"),  q_static_type_prefix_amp);

    voidc_visitor_set_intrinsic(vis, vis, q_static_type_prefix_star, static_type_prefix_star_intrinsic, 0);
    voidc_visitor_set_intrinsic(vis, vis, q_static_type_prefix_amp,  static_type_prefix_amp_intrinsic,  0);

    voidc_visitor_function_dict_set(vis, vis, v_static_type_t, q("v.op_prefix_const"),    q_static_type_prefix_const);
    voidc_visitor_function_dict_set(vis, vis, v_static_type_t, q("v.op_prefix_volatile"), q_static_type_prefix_volatile);

    voidc_visitor_set_intrinsic(vis, vis, q_static_type_prefix_const,    static_type_prefix_cv_intrinsic, 0);
    voidc_visitor_set_intrinsic(vis, vis, q_static_type_prefix_volatile, static_type_prefix_cv_intrinsic, 0);

    voidc_visitor_set_void_method(vis, vis, expr_call_q, compile_expr_call, 0);

    voidc_visitor_set_intrinsic(vis, vis, q_op_postfix_index, op_postfix_index_intrinsic, 0);

    voidc_visitor_function_dict_set(vis, vis, v_static_type_t, q_op_postfix_index, q_static_type_postfix_index);

    voidc_visitor_set_intrinsic(vis, vis, q_static_type_postfix_index, static_type_postfix_index_intrinsic, 0);
}


//---------------------------------------------------------------------
//- Enable overloading
//---------------------------------------------------------------------
export
voidc_enable_overloading: () -> void
{
    voidc_enable_overloading_compiler();
}


//=====================================================================
{   voidc_unit_end_module(); }


