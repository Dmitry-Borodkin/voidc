//---------------------------------------------------------------------
//- Copyright (C) 2020-2021 Dmitry Borodkin <borodkin-dn@yandex.ru>
//- SDPX-License-Identifier: LGPL-3.0-or-later
//---------------------------------------------------------------------
{   voidc_guard_target("expression.void  must be imported into the voidc target only!");

    v_import("switch.void");

    v_import("expr_util.void");
}

{   voidc_enable_statement_if_then_else();
    voidc_enable_statement_block();
    voidc_enable_statement_loop();
    voidc_enable_statement_switch();
    voidc_enable_statement_grammar();
}


//---------------------------------------------------------------------
{   void_ptr = v_pointer_type(void, 0);
    char_ptr = v_pointer_type(char, 0);

    v_add_local_symbol("void_ptr", voidc_opaque_type, void_ptr);
    v_add_local_symbol("char_ptr", voidc_opaque_type, char_ptr);
}


//---------------------------------------------------------------------
{   typ0 = v_alloca(v_type_ptr, 3);
    typ1 = v_getelementptr(typ0, 1);
    typ2 = v_getelementptr(typ0, 2);


    //-----------------------------------------------------------------
    //- method ...
    //-----------------------------------------------------------------
    v_store(voidc_visitor_ptr,      typ0);
    v_store(void_ptr,               typ1);
    v_store(v_ast_generic_list_ptr, typ2);

    method_ft  = v_function_type(void, typ0, 3, false);
    method_ptr = v_pointer_type(method_ft, 0);

    v_add_local_symbol("method_ft",  voidc_opaque_type, method_ft);
    v_add_local_symbol("method_ptr", voidc_opaque_type, method_ptr);

    z_method_ft  = v_function_type(void, typ0, 2, false);
    z_method_ptr = v_pointer_type(z_method_ft, 0);

    v_add_local_symbol("z_method_ft",  voidc_opaque_type, z_method_ft);
    v_add_local_symbol("z_method_ptr", voidc_opaque_type, z_method_ptr);
}


//---------------------------------------------------------------------
{   module = LLVMModuleCreateWithName("voidc_expression_mod");

    v_set_module(module);
}


//---------------------------------------------------------------------
//- quark ...
//---------------------------------------------------------------------
{
    quark_name = "v_ast_expr_node_t_visitor_method_tag";

    quark_p = v_quark_ptr_from_string(quark_name);

    v_add_symbol(quark_name, v_reference_type(v_quark_t, 0), quark_p);

    v_add_local_alias("quark", quark_name);
}


//---------------------------------------------------------------------
//- expr_node destroy ...
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("voidc_ast_expr_node_destroy", v_ast_generic_destroy_fun_t);

    v_add_parameter_name(f, 0, "void_obj", void_ptr);
}
{
//  printf("voidc_ast_expr_node_destroy\n");

    obj = v_cast(void_obj, v_ast_generic_list_ptr);

    v_terminate(obj);

    v_mfree(obj);
}


//---------------------------------------------------------------------
//- expr_node accept ...
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("voidc_ast_expr_node_accept", v_ast_generic_accept_fun_t);

    v_add_parameter_name(f, 0, "void_obj", void_ptr);
    v_add_parameter_name(f, 1, "visitor",  voidc_visitor_ptr);
    v_add_parameter_name(f, 2, "aux",      void_ptr);
}
{
//  printf("voidc_ast_expr_node_accept\n");

    obj = v_cast(void_obj, v_ast_generic_list_ptr);

    void_method = voidc_visitor_get_void_method(visitor, quark);

    method = v_cast(void_method, method_ptr);

    method(visitor, aux, obj);
}


//-----------------------------------------------------------------------
//- expr_node vtable ...
//-------------------------------------------------------------------
{
    module = v_get_module();

    val0 = v_alloca(LLVMValueRef, 3);
    val1 = v_getelementptr(val0, 1);
    val2 = v_getelementptr(val0, 2);

    destroy_f = v_obtain_function("voidc_ast_expr_node_destroy");
    accept_f  = v_obtain_function("voidc_ast_expr_node_accept");
    quark_v   = LLVMConstInt(v_type_get_llvm_type(v_quark_t), v_cast(quark, long_long), 0);

    v_store(destroy_f, val0);
    v_store(accept_f,  val1);
    v_store(quark_v,   val2);

    v_ast_generic_vtable_ = v_type_get_llvm_type(v_ast_generic_vtable);

    vtable_v = LLVMConstNamedStruct(v_ast_generic_vtable_, val0, 3);

    vtable_g = LLVMAddGlobal(module, v_ast_generic_vtable_, "voidc_ast_expr_node_vtable");

    LLVMSetInitializer(vtable_g, vtable_v);

    v_add_local_symbol("voidc_ast_expr_node_vtable", v_ast_generic_vtable, 0);      //- Sic!
}


//---------------------------------------------------------------------
//- v_ast_make_expr_node - ...
//---------------------------------------------------------------------
{
    typ0 = v_alloca(v_type_ptr, 3);
    typ1 = v_getelementptr(typ0, 1);
    typ2 = v_getelementptr(typ0, 2);

    v_store(v_ast_expr_ptr, typ0);
    v_store(v_ast_base_ptr, typ1);
    v_store(int,            typ2);

    ft = v_function_type(void, typ0, 3, false);

    //-----------------------------------------------------------------
    f = v_function_hack("v_ast_make_expr_node", ft);

    v_add_parameter_name(f, 0, "ret",   v_ast_expr_ptr);
    v_add_parameter_name(f, 1, "ast0",  v_ast_base_ptr);
    v_add_parameter_name(f, 2, "count", int);
}
{
    list = v_malloc(v_ast_opaque_generic_list_sptr);
    v_initialize(list);

    v_make_list(list, 0, ast0, count);

    v_ast_make_expr_generic(ret, voidc_ast_expr_node_vtable, list);
}


//---------------------------------------------------------------------
//- Precedence climbing algorithm...
//---------------------------------------------------------------------
//- compute_expr(min_prec):
//-   result = compute_atom()
//-
//-   while cur token is a binary operator with precedence >= min_prec:
//-     prec, assoc = precedence and associativity of current token
//-     if assoc is left:
//-       next_min_prec = prec + 1
//-     else:
//-       next_min_prec = prec
//-     rhs = compute_expr(next_min_prec)
//-     result = compute operator(result, rhs)
//-
//-   return result
//---------------------------------------------------------------------


//---------------------------------------------------------------------
//- Global variable(s)
//---------------------------------------------------------------------
{
    module = v_get_module();

    //-----------------------------------------------------------------
    //- precedence_stack_node_t ...
    //-----------------------------------------------------------------
    precedence_stack_node_t = v_struct_type_named("struct.precedence_stack_node_t");

    precedence_stack_node_ptr  = v_pointer_type(precedence_stack_node_t, 0);
    precedence_stack_node_ptr_ = v_type_get_llvm_type(precedence_stack_node_ptr);

    typ0 = v_alloca(v_type_ptr, 2);
    typ1 = v_getelementptr(typ0, 1);

    v_store(intptr_t,                  typ0);       //- Precedence value
    v_store(precedence_stack_node_ptr, typ1);       //- Next node ...

    v_type_struct_set_body(precedence_stack_node_t, typ0, 2, 0);

    //-----------------------------------------------------------------
    stack_g = LLVMAddGlobal(module, precedence_stack_node_ptr_, "precedence_stack");

    stack_u = LLVMGetUndef(precedence_stack_node_ptr_);

    LLVMSetInitializer(stack_g, stack_u);

    //-----------------------------------------------------------------
    v_add_local_symbol("precedence_stack_node_t",   voidc_opaque_type, precedence_stack_node_t);
    v_add_local_symbol("precedence_stack_node_ptr", voidc_opaque_type, precedence_stack_node_ptr);

    v_add_local_symbol("precedence_stack", precedence_stack_node_ptr, 0);       //- Sic!
}


//---------------------------------------------------------------------
//- Precedence stack utility...
//---------------------------------------------------------------------
{
    typ0 = v_alloca(v_type_ptr);

    v_store(intptr_t, typ0);

    ft = v_function_type(void, typ0, 1, false);

    //-----------------------------------------------------------------
    f = v_function_hack("precedence_stack_push", ft);

    v_add_parameter_name(f, 0, "prec", intptr_t);
}
{
//  printf("precedence_stack_push(%d)\n", prec);

    node = v_malloc(precedence_stack_node_t);

    p_prec = v_getelementptr(node, 0, 0);
    p_next = v_getelementptr(node, 0, 1);

    cur = v_load(precedence_stack);

    v_store(prec, p_prec);
    v_store(cur,  p_next);

    v_store(node, precedence_stack);
}

//---------------------------------------------------------------------
{
    ft = v_function_type(intptr_t, 0, 0, false);

    //-----------------------------------------------------------------
    f = v_function_hack("precedence_stack_pop", ft);
}
{
    node = v_load(precedence_stack);

    p_prec = v_getelementptr(node, 0, 0);
    p_next = v_getelementptr(node, 0, 1);

    next = v_load(p_next);

    v_store(next, precedence_stack);

    prec = v_load(p_prec);

    v_mfree(node);

//  printf("precedence_stack_pop: %d\n", prec);

    v_return(prec);
}

//---------------------------------------------------------------------
{
    ft = v_function_type(intptr_t, 0, 0, false);

    //-----------------------------------------------------------------
    f = v_function_hack("precedence_stack_peek", ft);
}
{
    node = v_load(precedence_stack);

    p_prec = v_getelementptr(node, 0, 0);

    prec = v_load(p_prec);

    v_return(prec);
}


//---------------------------------------------------------------------
//- expr_start - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("expr_start_grammar_action", v_peg_grammar_action_fun_t);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any0",      v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("expr_start_grammar_action\n");

    precedence_stack_push(0);

    v_std_any_set_value(ret, 1);
}

//---------------------------------------------------------------------
//- expr_stop - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("expr_stop_grammar_action", v_peg_grammar_action_fun_t);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any0",      v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("expr_stop_grammar_action\n");

    precedence_stack_pop();

    v_copy(ret, any0);
}

//---------------------------------------------------------------------
//- expr_cleanup - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("expr_cleanup_grammar_action", v_peg_grammar_action_fun_t);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any0",      v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("expr_cleanup_grammar_action\n");

    precedence_stack_pop();

    //- Just fail!
}


//---------------------------------------------------------------------
//- expr_check_infix - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("expr_check_infix_grammar_action", v_peg_grammar_action_fun_t);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any0",      v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("expr_check_infix_grammar_action\n");

    min_prec = precedence_stack_peek();

    op = v_std_any_get_pointer(v_ast_opaque_generic_list_sptr, any0);

    arg0 = v_alloca(v_ast_opaque_expr_sptr, 2);
    arg1 = v_getelementptr(arg0, 1);

    v_initialize(arg0, 2);

    v_list_get_items(op, 1, v_cast(arg0, v_ast_base_ptr), 2);

    prec = v_ast_expr_integer_get_number(arg0);
    left = v_ast_expr_integer_get_number(arg1);

    v_terminate(arg0, 2);


    if (v_icmp(LLVMIntULT, prec, min_prec)) v_return();     //- NOK

    precedence_stack_push(v_binop(LLVMAdd, prec, left));

    v_std_any_set_value(ret, 1);                            //- OK
}


//---------------------------------------------------------------------
//- expr_infix - grammar action
//---------------------------------------------------------------------
//{   v_debug_print_module(1); }
{
    //-----------------------------------------------------------------
    f = v_function_hack("expr_infix_grammar_action", v_peg_grammar_action_fun_t);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any0",      v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("expr_infix_grammar_action\n");

    any1 = v_getelementptr(any0, 1);
    any2 = v_getelementptr(any0, 2);

    op  = v_std_any_get_pointer(v_ast_opaque_generic_list_sptr, any0);
    lhs = v_std_any_get_pointer(v_ast_opaque_expr_sptr,         any1);
    rhs = v_std_any_get_pointer(v_ast_opaque_expr_sptr,         any2);

    op  = v_cast(op,  v_ast_base_ptr);
    lhs = v_cast(lhs, v_ast_base_ptr);
    rhs = v_cast(rhs, v_ast_base_ptr);

    ast0 = v_alloca(v_ast_opaque_base_sptr, 3);
    ast1 = v_getelementptr(ast0, 1);
    ast2 = v_getelementptr(ast0, 2);

    v_initialize(ast0, 3);

    v_copy(ast0, op);
    v_copy(ast1, lhs);
    v_copy(ast2, rhs);

    expr = v_alloca(v_ast_opaque_expr_sptr);
    v_initialize(expr);

    v_ast_make_expr_node(expr, ast0, 3);

    v_std_any_set_pointer(ret, expr);

    v_terminate(expr);
    v_terminate(ast0, 3);

    precedence_stack_pop();
}


//---------------------------------------------------------------------
//- expr_make_postfix - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("expr_make_postfix_grammar_action", v_peg_grammar_action_fun_t);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any0",      v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("expr_make_postfix_grammar_action\n");

    min_prec = precedence_stack_peek();

    any1 = v_getelementptr(any0, 1);

    op = v_std_any_get_pointer(v_ast_opaque_generic_list_sptr, any1);

    arg0 = v_alloca(v_ast_opaque_expr_sptr);
    v_initialize(arg0);

    v_list_get_items(op, 1, v_cast(arg0, v_ast_base_ptr));

    prec = v_ast_expr_integer_get_number(arg0);

    v_terminate(arg0);


    if (v_icmp(LLVMIntULT, prec, min_prec)) v_return();     //- NOK

    lhs = v_std_any_get_pointer(v_ast_opaque_expr_sptr, any0);

    op  = v_cast(op,  v_ast_base_ptr);
    lhs = v_cast(lhs, v_ast_base_ptr);

    ast0 = v_alloca(v_ast_opaque_base_sptr, 2);
    ast1 = v_getelementptr(ast0, 1);

    v_initialize(ast0, 2);

    v_copy(ast0, op);
    v_copy(ast1, lhs);

    expr = v_alloca(v_ast_opaque_expr_sptr);
    v_initialize(expr);

    v_ast_make_expr_node(expr, ast0, 2);

    v_std_any_set_pointer(ret, expr);                       //- OK

    v_terminate(expr);
    v_terminate(ast0, 2);
}


//---------------------------------------------------------------------
//- expr_push_prefix - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("expr_push_prefix_grammar_action", v_peg_grammar_action_fun_t);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any0",      v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("expr_push_prefix_grammar_action\n");

    op = v_std_any_get_pointer(v_ast_opaque_generic_list_sptr, any0);

    arg0 = v_alloca(v_ast_opaque_expr_sptr);
    v_initialize(arg0);

    v_list_get_items(op, 1, v_cast(arg0, v_ast_base_ptr));

    precedence_stack_push(v_ast_expr_integer_get_number(arg0));

    v_std_any_set_value(ret, 1);

    v_terminate(arg0);
}


//---------------------------------------------------------------------
//- expr_prefix - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("expr_prefix_grammar_action", v_peg_grammar_action_fun_t);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any0",      v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("expr_prefix_grammar_action\n");

    any1 = v_getelementptr(any0, 1);

    op  = v_std_any_get_pointer(v_ast_opaque_generic_list_sptr, any0);
    rhs = v_std_any_get_pointer(v_ast_opaque_expr_sptr,         any1);

    ast0 = v_alloca(v_ast_opaque_base_sptr, 2);
    ast1 = v_getelementptr(ast0, 1);

    v_initialize(ast0, 2);

    v_copy(ast0, v_cast(op,  v_ast_base_ptr));
    v_copy(ast1, v_cast(rhs, v_ast_base_ptr));


    expr = v_alloca(v_ast_opaque_expr_sptr);
    v_initialize(expr);

    v_ast_make_expr_node(expr, ast0, 2);

    v_std_any_set_pointer(ret, expr);

    v_terminate(expr);
    v_terminate(ast0, 2);

    precedence_stack_pop();
}


//---------------------------------------------------------------------
//- mk_bracketed - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_bracketed_grammar_action", v_peg_grammar_action_fun_t);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any0",      v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("mk_bracketed_grammar_action\n");

    any1 = v_getelementptr(any0, 1);

    op  = v_std_any_get_pointer(v_ast_opaque_generic_list_sptr, any0);
    rhs = v_std_any_get_pointer(v_ast_opaque_expr_sptr,         any1);

    ast0 = v_alloca(v_ast_opaque_base_sptr, 2);
    ast1 = v_getelementptr(ast0, 1);

    v_initialize(ast0, 2);

    v_copy(ast0, v_cast(op,  v_ast_base_ptr));
    v_copy(ast1, v_cast(rhs, v_ast_base_ptr));


    expr = v_alloca(v_ast_opaque_expr_sptr);
    v_initialize(expr);

    v_ast_make_expr_node(expr, ast0, 2);

    v_std_any_set_pointer(ret, expr);

    v_terminate(expr);
    v_terminate(ast0, 2);
}


//---------------------------------------------------------------------
//- mk_op_apply - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_op_apply_grammar_action", v_peg_grammar_action_fun_t);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any0",      v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("mk_op_apply_grammar_action\n");

    any1 = v_getelementptr(any0, 1);

    op   = v_std_any_get_pointer(v_ast_opaque_generic_list_sptr, any0);
    args = v_std_any_get_pointer(v_ast_opaque_expr_list_sptr,    any1);

    list = v_alloca(v_ast_opaque_generic_list_sptr);
    v_initialize(list);

    v_list_append(list, op, v_cast(args, v_ast_base_ptr));

    v_std_any_set_pointer(ret, list);

    v_terminate(list);
}


//---------------------------------------------------------------------
//- compile_ast_expr_node_t - visitor method
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_ast_expr_node_t", method_ft);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "list",    v_ast_generic_list_ptr);
}
{
//  printf("compile_ast_expr_node_t\n");

    ast0 = v_alloca(v_ast_opaque_base_sptr);
    v_initialize(ast0);

    v_list_get_items(list, 0, ast0);


    op = v_cast(ast0, v_ast_generic_list_ptr);

    arg0 = v_alloca(v_ast_opaque_expr_sptr);
    v_initialize(arg0);

    v_list_get_items(op, 0, v_cast(arg0, v_ast_base_ptr));

    q = v_ast_expr_integer_get_number(arg0);

    q = v_cast(q, v_quark_t);


//s = v_quark_to_string(q);
//printf("%s (\n", s);


    void_method = voidc_visitor_get_void_method(visitor, q);

    if (void_method)
    {
        method = v_cast(void_method, method_ptr);

        method(visitor, aux, list);
    }
    else
    {
        void_z_method = voidc_visitor_get_void_method(visitor, 0);

        z_method = v_cast(void_z_method, z_method_ptr);

        z_method(visitor, aux);
    }

//printf("%s )\n", s);

    v_terminate(arg0);
    v_terminate(ast0);
}


//---------------------------------------------------------------------
//- void voidc_enable_expression(void);
//---------------------------------------------------------------------
{
    ft = v_function_type(void, 0, 0, false);

    //-----------------------------------------------------------------
    v_function_hack("voidc_enable_expression", ft);
}
{
    if (voidc_has_grammar()) ;  else v_return();

    if (voidc_grammar_has_parser("expr_lr"))  v_return();


    gr0 = v_alloca(v_peg_opaque_grammar_sptr);
    v_initialize(gr0);

    v_peg_get_grammar(gr0);

    {   op = v_alloca(v_ast_opaque_generic_list_sptr);
        v_initialize(op);

        op_base = v_cast(op, v_ast_base_ptr);

        arg = v_alloca(v_ast_opaque_expr_sptr);
        v_initialize(arg);

        any = v_alloca(v_util_opaque_std_any);
        v_initialize(any);


        count = v_list_get_size(voidc_ast_expression_operator_list);
        count = v_cast(count, int);

        i = v_reference(v_alloca(int));

        v_assign(i, 0);

        loop
        {
            if (v_icmp(LLVMIntEQ, i, count))  v_break();


            v_list_get_items(voidc_ast_expression_operator_list, i, op_base);

            v_list_get_items(op, 0, v_cast(arg, v_ast_base_ptr));

            q = v_ast_expr_integer_get_number(arg);

            name = v_quark_to_string(v_cast(q, v_quark_t));

            v_std_any_set_pointer(any, op);


            v_peg_grammar_set_value(gr0, gr0, name, any);


            v_assign(i, v_binop(LLVMAdd, i, 1));
        }

        v_terminate(any);
        v_terminate(arg);
        v_terminate(op);
    }

    grammar gr0
    {
    actions:
        expr_start        = expr_start_grammar_action;
        expr_stop         = expr_stop_grammar_action;
        expr_cleanup      = expr_cleanup_grammar_action;
        expr_check_infix  = expr_check_infix_grammar_action;
        expr_infix        = expr_infix_grammar_action;
        expr_make_postfix = expr_make_postfix_grammar_action;
        expr_push_prefix  = expr_push_prefix_grammar_action;
        expr_prefix       = expr_prefix_grammar_action;

        mk_bracketed = mk_bracketed_grammar_action;

        mk_op_apply = mk_op_apply_grammar_action;

    parsers:

        expr = { expr_start() }  e:expr_ck  { expr_stop(e) };

        expr_ck = expr_lr / { expr_cleanup() };

        expr_lr = l:expr_lr _ op:infix _ { expr_check_infix(op) }  r:expr_ck  { expr_infix(op, l, r) }

                / l:expr_lr _ op:postfix { expr_make_postfix(l, op) }

                / op:prefix _ { expr_push_prefix(op) }  r:expr_ck  { expr_prefix(op, r) }

                / prim;

        expr_lr is left-recursive;


        prim += bracketed
              ;

        infix = "+="        { op_infix_add_assign }
              / '+' !'+'    { op_infix_add }
              / "-="        { op_infix_sub_assign }
              / '-' !'-'    { op_infix_sub }
              / "*="        { op_infix_mul_assign }
              / '*'         { op_infix_mul }
              / "/="        { op_infix_div_assign }
              / '/'         { op_infix_div }
              / "%="        { op_infix_rem_assign }
              / '%'         { op_infix_rem }
              / ":="        { op_infix_assign }
              / "<="        { op_infix_le }
              / "<<="       { op_infix_shl_assign }
              / "<<"        { op_infix_shl }
              / '<'         { op_infix_lt }
              / ">="        { op_infix_ge }
              / ">>="       { op_infix_shr_assign }
              / ">>"        { op_infix_shr }
              / '>'         { op_infix_gt }
              / "=="        { op_infix_eq }
              / "!="        { op_infix_ne }
              / "&&"        { op_infix_logical_and }
              / "&="        { op_infix_and_assign }
              / '&'         { op_infix_and }
              / "^="        { op_infix_xor_assign }
              / '^'         { op_infix_xor }
              / "||"        { op_infix_logical_or }
              / "|="        { op_infix_or_assign }
              / '|'         { op_infix_or }
              ;

        postfix = "++"      { op_postfix_inc }
                / "--"      { op_postfix_dec }

                / '(' _ a:expr_list _ ')'   { mk_op_apply(op_postfix_call, a) }
                / '[' _ a:expr_list _ ']'   { mk_op_apply(op_postfix_index, a) }
                ;

        prefix = "++"       { op_prefix_inc }
               / '+'        { op_prefix_plus }
               / "--"       { op_prefix_dec }
               / '-'        { op_prefix_minus }
               / '*'        { op_prefix_star }
               / '&'        { op_prefix_amp }
               / '!'        { op_prefix_bang }
               / '~'        { op_prefix_tilda }
               ;

        bracketed = '(' _ e:expr _ ')'      { mk_bracketed(op_parentheses, e) }     //- TODO...
                  ;
    }


    v_peg_set_grammar(gr0);


    void_method = v_cast(compile_ast_expr_node_t, void_ptr);

    voidc_visitor_set_void_method(voidc_compiler,  voidc_compiler,  quark, void_method);
    voidc_visitor_set_void_method(voidc_type_calc, voidc_type_calc, quark, void_method);    //- Sic!

    voidc_ast_add_expr_op_methods();


    v_terminate(gr0);
}


//---------------------------------------------------------------------
{
    v_make_function_private("voidc_ast_expr_node_destroy");
    v_make_function_private("voidc_ast_expr_node_accept");
    v_make_global_private("voidc_ast_expr_node_vtable");
    v_make_function_private("v_ast_make_expr_node");
    v_make_global_private("precedence_stack");
    v_make_function_private("precedence_stack_push");
    v_make_function_private("precedence_stack_pop");
    v_make_function_private("precedence_stack_peek");
    v_make_function_private("expr_start_grammar_action");
    v_make_function_private("expr_stop_grammar_action");
    v_make_function_private("expr_cleanup_grammar_action");
    v_make_function_private("expr_check_infix_grammar_action");
    v_make_function_private("expr_infix_grammar_action");
    v_make_function_private("expr_make_postfix_grammar_action");
    v_make_function_private("expr_push_prefix_grammar_action");
    v_make_function_private("expr_prefix_grammar_action");
    v_make_function_private("mk_bracketed_grammar_action");
    v_make_function_private("mk_op_apply_grammar_action");
    v_make_function_private("compile_ast_expr_node_t");
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
{
    module = v_get_module();

    //-----------------------------------------------------------------
//  v_debug_print_module(1);

    voidc_prepare_module_for_jit(module);

    voidc_add_module_to_jit(module);

    //-----------------------------------------------------------------
    v_set_module(0);
}


//---------------------------------------------------------------------
{
    v_make_symbol_global("voidc_enable_expression");
}


