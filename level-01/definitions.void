//---------------------------------------------------------------------
//- Copyright (C) 2020-2023 Dmitry Borodkin <borodkin.dn@gmail.com>
//- SDPX-License-Identifier: LGPL-3.0-or-later
//---------------------------------------------------------------------
{   voidc_guard_target("definitions.void  must be imported into the voidc target only!");

    v_import("level-00");

    v_import("llvm-c/Core.void");

    v_import("function_hack.void");
    v_import("if_then_else.void");
    v_import("block.void");
    v_import("loop.void");
    v_import("grammar.void");
    v_import("memory.void");
    v_import("expression.void");
    v_import("defer.void");
}

{   voidc_enable_statement_if_then_else();
    voidc_enable_statement_block();
    voidc_enable_statement_loop();
    voidc_enable_statement_grammar();
    voidc_enable_expression();
    voidc_enable_statement_defer();
}

{   v_import("compile_type.void");
}

//{ v_import("printf.void"); }


//---------------------------------------------------------------------
{   v_add_type("void_ptr", v_pointer_type(void, 0));
    v_add_type("char_ptr", v_pointer_type(char, 0));

    convert_to_type_ctx_t = v_struct_type_named("struct.convert_to_type_ctx_t");

    v_add_type("convert_to_type_ctx_t",   convert_to_type_ctx_t);
    v_add_type("convert_to_type_ctx_ptr", v_pointer_type(convert_to_type_ctx_t, 0));

    q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("q_export_symbol_type", q_ref, q("v_export_symbol_type"));
    v_add_symbol("q_export_type",        q_ref, q("v_export_type"));
    v_add_symbol("q_export_constant",    q_ref, q("v_export_constant"));
    v_add_symbol("q_add_symbol",         q_ref, q("v_add_symbol"));
    v_add_symbol("q_add_type",           q_ref, q("v_add_type"));
    v_add_symbol("q_add_constant",       q_ref, q("v_add_constant"));
    v_add_symbol("q_type_get_llvm_type", q_ref, q("v_type_get_llvm_type"));

    v_add_symbol("typ_q",   q_ref, q("typ"));
    v_add_symbol("true_q",  q_ref, q("true"));

    v_add_symbol("voidc_compile_type_q", q_ref, q("voidc.compile_type"));

    v_add_symbol("q_internal_var_decl", q_ref, q("v.internal.var_decl"));
    v_add_symbol("q_internal_var_defn", q_ref, q("v.internal.var_defn"));
    v_add_symbol("q_internal_val_defn", q_ref, q("v.internal.val_defn"));

    v_add_symbol("q_cast", q_ref, q("v_cast"));

    v_add_symbol("LLVMConstInt_q",          q_ref, q("LLVMConstInt"));
    v_add_symbol("LLVMConstRealOfString_q", q_ref, q("LLVMConstRealOfString"));

    v_add_symbol("constant_type_not_supported_q", q_ref, q("<constant type not supported>"));

    v_add_symbol("q_op_infix_assign", q_ref, q("v.op_infix_assign"));

    v_add_symbol("q_prepare_function_parameters", q_ref, q("v.prepare_function_parameters"));
}


//---------------------------------------------------------------------
{   typ = v_alloca(v_type_ptr, 2);

    typ[0] := char_ptr;
    typ[1] := char_ptr;

    ft = v_function_type(int, typ, 2, true);
    v_add_symbol("sprintf", ft, 0);

//  typ[0] := char_ptr;

    ft = v_function_type(void, typ, 1, false);
    v_add_symbol("free", ft, 0);

    typ[0] := void_ptr;

    ft = v_function_type(void, typ, 1, false);
    v_add_type("cleaner_ft_ptr", v_pointer_type(ft, 0));

    ft = v_function_type(void, 0, 0, false);
    v_add_symbol("abort", ft, 0);

    //-----------------------------------------------------------------
    LLVMDisposeMemoryBuffer(voidc_get_unit_buffer());
    voidc_set_unit_buffer(0);
}


//---------------------------------------------------------------------
//- Some utility...
//---------------------------------------------------------------------
{   typ = v_alloca(v_type_ptr, 2);

    typ[0] := char_ptr;
    typ[1] := v_type_ptr;

    ft = v_function_type(LLVMValueRef, typ, 2, false);

    //-----------------------------------------------------------------
    f = v_function_hack("v_make_global", ft);

    v_add_parameter_name(f, 0, "name", char_ptr);
    v_add_parameter_name(f, 1, "type", v_type_ptr);
}
{
    v_add_symbol(name, type, 0);

    if (!voidc_has_grammar())   v_return(0);

    t = *v_alloca(v_type_ptr);

    if (v_type_is_reference(type))  t := v_type_refptr_get_element_type(type);
    else                            t := type;

    t_ = v_type_get_llvm_type(t);

    value = LLVMAddGlobal(v_get_module(), t_, name);

    LLVMSetInitializer(value, LLVMGetUndef(t_));

    v_return(value);
}


//---------------------------------------------------------------------
//- Module ...
//---------------------------------------------------------------------
{   module = LLVMModuleCreateWithName("voidc_definitions_internal_module");

    v_set_module(module);

    //-----------------------------------------------------------------
    LLVMDisposeMemoryBuffer(voidc_get_unit_buffer());
    voidc_set_unit_buffer(0);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
{
    bool_ref = v_reference_type(bool, 0);
    mod_ref  = v_reference_type(LLVMModuleRef, 0);

    v_make_global("export_flag", bool_ref);

    v_make_global("saved_module", mod_ref);
    v_make_global("defn_module",  mod_ref);

    v_make_global("op_infix_to",        v_ast_expr_t);
    v_make_global("op_prefix_const",    v_ast_expr_t);
    v_make_global("op_prefix_volatile", v_ast_expr_t);

    intptr_t_ = v_type_get_llvm_type(intptr_t);

    v_add_constant("qf_none",    intptr_t, LLVMConstInt(intptr_t_, 0, 0));
    v_add_constant("qf_export",  intptr_t, LLVMConstInt(intptr_t_, 1, 0));
    v_add_constant("qf_private", intptr_t, LLVMConstInt(intptr_t_, 2, 0));


    typ = v_alloca(v_type_ptr);

    typ[0] := void_ptr;

    ft = v_function_type(void, typ, 1, false);

    //-----------------------------------------------------------------
    f = v_function_hack("voidc_definitions_internal_globals_cleaner", ft);
}
{
//  printf("voidc_definitions_internal_globals_cleaner\n");

    v_terminate(op_infix_to);
    v_terminate(op_prefix_const);
    v_terminate(op_prefix_volatile);
}

//---------------------------------------------------------------------
{
    quark_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("br_item_list_q",   quark_ref, q("br_item_list"));
    v_add_symbol("unit_fun_defn_q",  quark_ref, q("unit_fun_defn"));
    v_add_symbol("unit_var_defn_q",  quark_ref, q("unit_var_defn"));
    v_add_symbol("unit_val_defn_q",  quark_ref, q("unit_val_defn"));
    v_add_symbol("defn_list_unit_q", quark_ref, q("defn_list_unit"));

    v_add_symbol("voidc_decl_stmt_list_q", quark_ref, q("voidc.decl_stmt_list"));
    v_add_symbol("voidc_compile_type_q",   quark_ref, q("voidc.compile_type"));
}


//---------------------------------------------------------------------
//- mk_br_item - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_br_item_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_br_item_grammar_action\n");

    key  = v_std_any_get_pointer(v_ast_expr_t, any+0);
    type = v_std_any_get_pointer(v_ast_expr_t, any+1);

    expr = v_alloca(v_ast_expr_t, 2);
    v_initialize(expr, 2);
    defer v_terminate(expr, 2);

    if (key)    v_copy(expr+0, key);
    if (type)   v_copy(expr+1, type);

    lst = v_alloca(v_ast_expr_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, expr, 2);

    v_std_any_set_pointer(ret, lst);
}

//---------------------------------------------------------------------
//- mk_br_item_list - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_br_item_list_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_br_item_list_grammar_action\n");

    list = v_std_any_get_pointer(v_ast_expr_t, any+0);
    list = v_cast(list, v_ast_generic_list_ptr);                    //- Sic!!!

    item = v_std_any_get_pointer(v_ast_expr_list_t, any+1);

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    if (list)   v_list_append(lst, list, v_cast(item, v_ast_base_ptr));
    else
    {
        if (item)   v_make_list(lst, br_item_list_q, v_cast(item, v_ast_base_ptr), 1);
        else        v_make_list_nil(lst, br_item_list_q);
    }

    v_std_any_set_pointer(ret, v_cast(lst, v_ast_expr_ptr));        //- Sic!!!
}


//---------------------------------------------------------------------
//- mk_qualif_flags - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_qualif_flags_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_qlf_ident_grammar_action\n");

    flags = v_std_any_get_value(intptr_t, any+0);
    flag  = v_std_any_get_value(intptr_t, any+1);

    v_std_any_set_value(ret, flags|flag);
}


//---------------------------------------------------------------------
//- mk_qlf_ident - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_qlf_ident_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_qlf_ident_grammar_action\n");

    qualif = v_std_any_get_value(intptr_t, any+0);

    name = v_std_any_get_pointer(v_std_string_t, any+1);

    ast = v_alloca(v_ast_base_t, 2);
    v_initialize(ast, 2);
    defer v_terminate(ast, 2);

    v_ast_make_expr_integer(v_cast(&ast[0], v_ast_expr_ptr), qualif);

    v_ast_make_expr_identifier(v_cast(&ast[1], v_ast_expr_ptr), v_std_string_get(name));

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, 0, ast, 2);

    v_std_any_set_pointer(ret, lst);
}


//---------------------------------------------------------------------
//- mk_unit_fun_defn_hdr - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_unit_fun_defn_hdr_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_unit_fun_defn_hdr_grammar_action\n");

    q_id = v_std_any_get_pointer(v_ast_generic_list_t, any+0);

    args = v_std_any_get_pointer(v_ast_expr_t, any+1);
    type = v_std_any_get_pointer(v_ast_expr_t, any+2);

    ast = v_alloca(v_ast_base_t, 4);
    v_initialize(ast, 4);
    defer v_terminate(ast, 4);

    v_copy(ast+0, v_list_get_item(q_id, 0));
    v_copy(ast+1, v_list_get_item(q_id, 1));

    v_copy(ast+2, v_cast(args, v_ast_base_ptr));
    v_copy(ast+3, v_cast(type, v_ast_base_ptr));

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, unit_fun_defn_q, ast, 4);

    v_std_any_set_pointer(ret, lst);
}

//---------------------------------------------------------------------
//- mk_unit_fun_defn - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_unit_fun_defn_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_unit_fun_defn_grammar_action\n");

    head = v_std_any_get_pointer(v_ast_generic_list_t, any+0);
    body = v_std_any_get_pointer(v_ast_stmt_list_t,    any+1);

    ast = v_alloca(v_ast_base_t);
    v_initialize(ast);
    defer v_terminate(ast);

    if (body)   v_copy(ast, v_cast(body, v_ast_base_ptr));

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_list_append(lst, head, ast, 1);

    v_std_any_set_pointer(ret, lst);
}

//---------------------------------------------------------------------
//- mk_unit_var_defn - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_unit_var_defn_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_unit_var_defn_grammar_action\n");
//  defer printf("mk_unit_var_defn_grammar_action leave\n");

    q_id = v_std_any_get_pointer(v_ast_generic_list_t, any+0);

    expr = v_std_any_get_pointer(v_ast_expr_t, any+1);

    ast = v_alloca(v_ast_base_t, 4);
    v_initialize(ast, 4);
    defer v_terminate(ast, 4);

    type  = v_cast(ast+2, v_ast_expr_ptr);
    value = v_cast(ast+3, v_ast_expr_ptr);

    v_copy(type, expr);

    block
    {
        tag = v_ast_base_get_visitor_method_tag(ast+2);

        if (tag != v_ast_expr_call_visitor_method_tag) v_break();

        ast2 = v_cast(ast+2, v_ast_expr_ptr);

        efun = v_ast_expr_call_get_fun_expr(ast2);

        tag = v_ast_base_get_visitor_method_tag(v_cast(efun, v_ast_base_ptr));

        if (tag != v_ast_expr_identifier_visitor_method_tag) v_break();

        qname = v_ast_expr_identifier_get_name_q(efun);

        if (qname != q_op_infix_assign)  v_break();

        arg_list = v_ast_expr_call_get_arg_list(ast2);

        v_copy(ast2+0, v_list_get_item(arg_list, 1));
        v_copy(ast2+1, v_list_get_item(arg_list, 2));
    }

    v_copy(ast+0, v_list_get_item(q_id, 0));
    v_copy(ast+1, v_list_get_item(q_id, 1));

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, unit_var_defn_q, ast, 4);

    v_std_any_set_pointer(ret, lst);
}

//---------------------------------------------------------------------
//- mk_unit_val_defn - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_unit_val_defn_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_unit_val_defn_grammar_action\n");

    q_id = v_std_any_get_pointer(v_ast_generic_list_t, any+0);

    type  = v_std_any_get_pointer(v_ast_expr_t, any+1);
    value = v_std_any_get_pointer(v_ast_expr_t, any+2);

    ast = v_alloca(v_ast_base_t, 4);
    v_initialize(ast, 4);
    defer v_terminate(ast, 4);

    v_copy(ast+0, v_list_get_item(q_id, 0));
    v_copy(ast+1, v_list_get_item(q_id, 1));

    if (type)   v_copy(ast+2, v_cast(type, v_ast_base_ptr));

    v_copy(ast+3, v_cast(value, v_ast_base_ptr));

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, unit_val_defn_q, ast, 4);

    v_std_any_set_pointer(ret, lst);
}


//---------------------------------------------------------------------
//- mk_unit_defn_list - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_unit_defn_list_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_unit_defn_list_grammar_action\n");

    list = v_std_any_get_pointer(v_ast_generic_list_t, any+0);
    item = v_std_any_get_pointer(v_ast_generic_list_t, any+1);

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    if (list)   v_list_append(lst, list, v_cast(item, v_ast_base_ptr));
    else
    {
        v_make_list(lst, 0, v_cast(item, v_ast_base_ptr), 1);
    }

    v_std_any_set_pointer(ret, lst);
}

//---------------------------------------------------------------------
//- mk_defn_list_unit - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_defn_list_unit_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_defn_list_unit_grammar_action\n");

    list = v_std_any_get_pointer(v_ast_generic_list_t, any+0);

    pos = v_std_any_get_value(size_t, any+1);

    line   = *v_alloca(size_t) := 0;
    column = *v_alloca(size_t) := 0;

    v_peg_get_line_column(pos, line, column);

    ast = v_alloca(v_ast_base_t, 3);
    v_initialize(ast, 3);
    defer v_terminate(ast, 3);

    v_copy(&ast[0], v_cast(list, v_ast_base_ptr));

    v_ast_make_expr_integer(v_cast(&ast[1], v_ast_expr_ptr), v_cast(line,   intptr_t));
    v_ast_make_expr_integer(v_cast(&ast[2], v_ast_expr_ptr), v_cast(column, intptr_t));

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, defn_list_unit_q, ast, 3);

    v_std_any_set_pointer(ret, v_cast(lst, v_ast_unit_ptr));        //- Sic!!!
}


//---------------------------------------------------------------------
//- mk_stmt_var_defn - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_stmt_var_defn_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_stmt_var_defn_grammar_action\n");

    name = v_std_any_get_pointer(v_std_string_t, any+0);

    expr = v_std_any_get_pointer(v_ast_expr_t, any+1);

    ast = v_alloca(v_ast_base_t, 2);
    v_initialize(ast, 2);
    defer v_terminate(ast, 2);

    type  = v_cast(ast+0, v_ast_expr_ptr);
    value = v_cast(ast+1, v_ast_expr_ptr);

    v_copy(type, expr);

    block
    {
        tag = v_ast_base_get_visitor_method_tag(ast+0);

        if (tag != v_ast_expr_call_visitor_method_tag) v_break();

        ast0 = v_cast(ast+0, v_ast_expr_ptr);

        efun = v_ast_expr_call_get_fun_expr(ast0);

        tag = v_ast_base_get_visitor_method_tag(v_cast(efun, v_ast_base_ptr));

        if (tag != v_ast_expr_identifier_visitor_method_tag) v_break();

        qopnm = v_ast_expr_identifier_get_name_q(efun);

        if (qopnm != q_op_infix_assign)  v_break();

        arg_list = v_ast_expr_call_get_arg_list(ast0);

        v_copy(ast0+0, v_list_get_item(arg_list, 1));
        v_copy(ast0+1, v_list_get_item(arg_list, 2));
    }

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);

    lst = v_alloca(v_ast_expr_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    etmp = v_alloca(v_ast_expr_t);
    v_initialize(etmp);
    defer v_terminate(etmp);

    if (v_empty(value))     //- Declaration
    {
        v_ast_make_expr_identifier(etmp, v_std_string_get(name));

        v_make_list(lst, etmp, 1);

        v_list_append(lst, lst, type, 1);

        v_ast_make_expr_identifier_q(etmp, q_internal_var_decl);

        v_ast_make_expr_call(etmp, etmp, lst);

        v_ast_make_stmt_q(stmt, 0, etmp);
    }
    else                    //- Definition
    {
        v_make_list(lst, type, 2);

        v_ast_make_expr_identifier_q(etmp, q_internal_var_defn);

        v_ast_make_expr_call(etmp, etmp, lst);

        v_ast_make_stmt(stmt, v_std_string_get(name), etmp);
    }

    v_std_any_set_pointer(ret, stmt);
}

//---------------------------------------------------------------------
//- mk_stmt_val_defn - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_stmt_val_defn_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_stmt_val_defn_grammar_action\n");

    name = v_std_any_get_pointer(v_std_string_t, any+0);

    type = v_std_any_get_pointer(v_ast_expr_t, any+1);
    expr = v_std_any_get_pointer(v_ast_expr_t, any+2);

    lst = v_alloca(v_ast_expr_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, expr, 1);

    v_list_append(lst, lst, type, 1);

    etmp = v_alloca(v_ast_expr_t);
    v_initialize(etmp);
    defer v_terminate(etmp);

    v_ast_make_expr_identifier_q(etmp, q_internal_val_defn);

    v_ast_make_expr_call(etmp, etmp, lst);

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);

    v_ast_make_stmt(stmt, v_std_string_get(name), etmp);

    v_std_any_set_pointer(ret, stmt);
}


//---------------------------------------------------------------------
//- convert_to_type - utility...
//---------------------------------------------------------------------
{
    typ0 = v_alloca(v_type_ptr, 4);
    typ1 = v_getelementptr(typ0, 1);
    typ2 = v_getelementptr(typ0, 2);
    typ3 = v_getelementptr(typ0, 3);

    v_store(void_ptr,     typ0);
    v_store(v_type_ptr,   typ1);
    v_store(LLVMValueRef, typ2);
    v_store(v_type_ptr,   typ3);

    ft = v_function_type(LLVMValueRef, typ0, 4, false);

    //-----------------------------------------------------------------
    f = v_function_hack("convert_to_type", ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "void_ctx", void_ptr);
    v_add_parameter_name(f, 1, "type",     v_type_ptr);
    v_add_parameter_name(f, 2, "value",    LLVMValueRef);
    v_add_parameter_name(f, 3, "to_type",  v_type_ptr);
}
{
    if (type == to_type)  v_return(value);

    block
    {
        if (!v_type_is_struct(to_type))  v_break();

        typs = v_type_struct_get_element_types(to_type);

        incomplete_array_type_tag = v_struct_type_named("voidc.incomplete_array_type_tag");     //- Sic!

        if (typs[0] != incomplete_array_type_tag)  v_break();

        v_set_result_type(type);        //- Sic!!!

        v_return(value);
    }

    ctx = *v_cast(void_ctx, convert_to_type_ctx_ptr);

    saved_fun = ctx[0];
    saved_ctx = ctx[1];

    v_return(saved_fun(saved_ctx, type, value, to_type));         //- Sic!!!
}


//---------------------------------------------------------------------
//- v.internal.var_decl - compiler intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("v_internal_var_decl_intrinsic", voidc_intrinsic_t);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("v_internal_var_decl_intrinsic\n");
//  defer printf("v_internal_var_decl_intrinsic leave\n");

    call = v_cast(self, v_ast_expr_ptr);

    arg_list = v_ast_expr_call_get_arg_list(call);

    arg0 = v_list_get_item(arg_list, 0);
    arg1 = v_list_get_item(arg_list, 1);

    name = v_ast_expr_identifier_get_name(arg0);                            //- Name

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(v_cast(arg1, v_ast_base_ptr), visitor);            //- Type

    type = *v_alloca(v_type_ptr) := v_cast(v_get_result_value(), v_type_ptr);

    if (v_type_is_pointer(type))
    {
        type := v_type_refptr_get_element_type(type);       //- Sic!
    }

    v_add_symbol(name, type, 0);
}

//---------------------------------------------------------------------
//- v.internal.var_defn - compiler intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("v_internal_var_defn_intrinsic", voidc_intrinsic_t);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("v_internal_var_defn_intrinsic\n");
//  defer printf("v_internal_var_defn_intrinsic leave\n");

    call = v_cast(self, v_ast_expr_ptr);

    arg_list = v_ast_expr_call_get_arg_list(call);

    arg0 = v_list_get_item(arg_list, 0);
    arg1 = v_list_get_item(arg_list, 1);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(v_cast(arg0, v_ast_base_ptr), visitor);            //- Type

    var_type = v_cast(v_get_result_value(), v_type_ptr);

    t = v_type_refptr_get_element_type(var_type);       //- Sic!
    a = v_type_refptr_get_address_space(var_type);      //- Sic!

    v_set_result_type(t);
    v_set_result_value(0);

    v_ast_accept_visitor(v_cast(arg1, v_ast_base_ptr), visitor);            //- Value

    t = v_get_result_type();
    v = v_get_result_value();

    builder = v_target_get_builder();

    t_ = v_type_get_llvm_type(t);

    var_value = LLVMBuildAlloca(builder, t_, "");

    LLVMBuildStore(builder, v, var_value);

    v_set_result_type(v_reference_type(t, a));
    v_set_result_value(var_value);
}

//---------------------------------------------------------------------
//- v.internal.val_defn - compiler intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("v_internal_val_defn_intrinsic", voidc_intrinsic_t);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("v_internal_val_defn_intrinsic\n");
//  defer printf("v_internal_val_defn_intrinsic leave\n");

    call = v_cast(self, v_ast_expr_ptr);

    arg_list = v_ast_expr_call_get_arg_list(call);

    arg0 = v_list_get_item(arg_list, 0);
    arg1 = v_list_get_item(arg_list, 1);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(v_cast(arg1, v_ast_base_ptr), visitor);            //- Type

    t = v_cast(v_get_result_value(), v_type_ptr);

    is_ref = v_type_is_reference(t);

    if (is_ref)  v_set_result_type(INVIOLABLE_TAG);
    else         v_set_result_type(t);

    v_set_result_value(0);

    v_ast_accept_visitor(v_cast(arg0, v_ast_base_ptr), visitor);            //- Value

    if (is_ref)
    {
        tr = v_get_result_type();

        if (!v_type_is_reference(tr))  abort();         //- !?!?!?!?!?!

        vr = v_get_result_value();

        v_set_result_type(t);
        v_set_result_value(0);

        v_adopt_result(tr, vr);
    }
}


//---------------------------------------------------------------------
//- compile_br_item_list - visitor method - special cases for '(' _ (expr _ ':')? _ expr _ ')'
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_br_item_list", voidc_visitor_method_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("compile_br_item_list\n");
//  defer printf("compile_br_item_list leave\n");

    list = v_cast(self, v_ast_generic_list_ptr);

    lst = v_cast(v_list_get_item(list, 0), v_ast_expr_list_ptr);

    expr = v_alloca(v_ast_expr_t);
    v_initialize(expr);
    defer v_terminate(expr);

    v_copy(expr, v_list_get_item(lst, 0));

    if (!v_empty(expr))
    {
        v_ast_make_expr_identifier_q(expr, q_cast);

        v_ast_make_expr_call(expr, expr, lst);
    }
    else
    {
        v_copy(expr, v_list_get_item(lst, 1));
    }

    v_ast_accept_visitor(v_cast(expr, v_ast_base_ptr), visitor);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
{
    typ = *v_alloca(v_type_ptr) := void_ptr;

    ft = v_function_type(LLVMModuleRef, &typ, 1, false);

    //-----------------------------------------------------------------
    f = v_function_hack("check_defn_module", ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);
}
{
    if (!defn_module)
    {
        //- voidc_guard_target(...);

        defn_module := LLVMModuleCreateWithName("voidc_definitions_internal_defn_module");
    }

    v_return(defn_module);
}


//---------------------------------------------------------------------
//- v_prepare_function_parameters_default ...
//---------------------------------------------------------------------
{
    typ = v_alloca(v_type_ptr, 6);
    typ[0] := void_ptr;
    typ[1] := LLVMValueRef;
    typ[2] := intptr_t;
    typ[3] := char_ptr;
    typ[4] := v_type_ptr;
    typ[5] := v_ast_generic_list_ptr;

    ft = v_function_type(void, typ, 6, false);

    v_add_type("v_prepare_function_parameters_t", ft);

    //-----------------------------------------------------------------
    f = v_function_hack("v_prepare_function_parameters_default", ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 1, "fun",      LLVMValueRef);
    v_add_parameter_name(f, 2, "qualif",   intptr_t);
    v_add_parameter_name(f, 3, "fun_name", char_ptr);
    v_add_parameter_name(f, 4, "fun_type", v_type_ptr);
    v_add_parameter_name(f, 5, "fun_args", v_ast_generic_list_ptr);
}
{
    count = v_type_function_get_param_count(fun_type);
    types = v_type_function_get_param_types(fun_type);

    if (count == 0) v_return();

    i = *v_alloca(int) := 0;

    loop
    {
        if (i >= count) v_break();

        item = v_cast(v_list_get_item(fun_args, i), v_ast_generic_list_ptr);

        etmp = v_cast(v_list_get_item(item, 0), v_ast_expr_ptr);

        if (!v_empty(etmp))
        {
            pname = v_ast_expr_identifier_get_name(etmp);

            v_add_parameter_name(fun, i, pname, types[i]);
        }

        ++i;
    }
}

//---------------------------------------------------------------------
//- voidc_compile_unit_fun_defn_helper - ...
//---------------------------------------------------------------------
{
    typ = v_alloca(v_type_ptr, 6);
    typ[0] := voidc_visitor_ptr;
    typ[1] := intptr_t;
    typ[2] := char_ptr;
    typ[3] := v_type_ptr;
    typ[4] := v_ast_generic_list_ptr;
    typ[5] := v_ast_base_ptr;

    ft = v_function_type(void, typ, 6, false);

    //-----------------------------------------------------------------
    f = v_function_hack("voidc_compile_unit_fun_defn_helper", ft);

    v_add_parameter_name(f, 0, "vis",      voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "qualif",   intptr_t);
    v_add_parameter_name(f, 2, "fun_name", char_ptr);
    v_add_parameter_name(f, 3, "fun_type", v_type_ptr);
    v_add_parameter_name(f, 4, "fun_args", v_ast_generic_list_ptr);
    v_add_parameter_name(f, 5, "fun_body", v_ast_base_ptr);
}
{
    private = (qualif & qf_private);
    export  = (export_flag  ||  qualif & qf_export)  &&  !private;

    if (export) v_export_symbol_type(fun_name, fun_type);
    else        v_add_symbol(fun_name, fun_type, 0);

    //-------------------------------------------------------------
    if (!v_empty(fun_body))
    {
        //- assert(v_get_module() == 0);

        v_set_module(v_obtain_module());

        f = v_prepare_function(fun_name, fun_type);

        if (private)  LLVMSetLinkage(f, LLVMPrivateLinkage);

        aux = *v_alloca(void_ptr);
        void_fun = voidc_visitor_get_intrinsic(vis, q_prepare_function_parameters, &aux);

        fun = v_cast(void_fun, *v_prepare_function_parameters_t);

        fun(aux, f, qualif, fun_name, fun_type, fun_args);

        v_ast_accept_visitor(fun_body, vis);

        v_finish_function();

        v_set_module(0);
    }

    //-------------------------------------------------------------
    stmt_list = voidc_visitor_get_intrinsic(vis, voidc_decl_stmt_list_q, 0);

    if (!stmt_list)  v_return();

    stmt_list = v_cast(stmt_list, v_ast_stmt_list_ptr);


    expr = v_alloca(v_ast_expr_t, 3);
    v_initialize(expr, 3);
    defer v_terminate(expr, 3);

    elst = v_alloca(v_ast_expr_list_t);
    v_initialize(elst);
    defer v_terminate(elst);

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);


    v_ast_make_expr_integer(expr+0, v_cast(fun_type, intptr_t));        //- Sic!!!

    v_make_list(elst, expr+0, 1);

    v_ast_make_expr_identifier_q(expr+0, voidc_compile_type_q);

    v_ast_make_expr_call(expr+1, expr+0, elst);

    v_ast_make_expr_string(expr+0, fun_name);


    if (export)
    {
        v_ast_make_stmt_call(stmt, 0, q_export_symbol_type, expr, 2);
    }
    else
    {
        v_ast_make_expr_integer(expr+2, 0);

        v_ast_make_stmt_call(stmt, 0, q_add_symbol, expr, 3);
    }

    v_list_append(stmt_list, stmt_list, stmt);
}

//---------------------------------------------------------------------
//- compile_unit_fun_defn - visitor method
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_unit_fun_defn", voidc_visitor_method_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("compile_unit_fun_defn\n");
//  defer printf("compile_unit_fun_defn leave\n");

    list = v_cast(self, v_ast_generic_list_ptr);

    ast0 = v_list_get_item(list, 0);
    ast1 = v_list_get_item(list, 1);

    //-------------------------------------------------------------
    qualif = v_ast_expr_integer_get_number(v_cast(ast0, v_ast_expr_ptr));

    name = v_ast_expr_identifier_get_name(v_cast(ast1, v_ast_expr_ptr));

    params   = v_list_get_item(list, 2);
    ret_type = v_list_get_item(list, 3);
    body     = v_list_get_item(list, 4);

    //-------------------------------------------------------------
    args = v_ast_expr_call_get_arg_list(v_cast(params, v_ast_expr_ptr));

    args = v_cast(v_list_get_item(args, 1), v_ast_generic_list_ptr);

    //-------------------------------------------------------------
    {   expr = v_alloca(v_ast_expr_t);
        v_initialize(expr);
        defer v_terminate(expr);

        v_ast_make_expr_op_binary(expr, op_infix_to, v_cast(params, v_ast_expr_ptr), v_cast(ret_type, v_ast_expr_ptr));

        v_set_result_type(INVIOLABLE_TAG);
        v_set_result_value(0);

        v_ast_accept_visitor(v_cast(expr, v_ast_base_ptr), visitor);
    }

    fun_type = v_cast(v_get_result_value(), v_type_ptr);

    voidc_compile_unit_fun_defn_helper(visitor, qualif, name, fun_type, args, body);
}

//---------------------------------------------------------------------
//- compile_unit_var_defn - visitor method
//---------------------------------------------------------------------
//{ v_debug_print_module(2); }
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_unit_var_defn", voidc_visitor_method_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("compile_unit_var_defn\n");
//  defer printf("compile_unit_var_defn leave\n");

    list = v_cast(self, v_ast_generic_list_ptr);

    ast0 = v_list_get_item(list, 0);
    ast1 = v_list_get_item(list, 1);

    //-------------------------------------------------------------
    qualif = v_ast_expr_integer_get_number(v_cast(ast0, v_ast_expr_ptr));

    private = (qualif & qf_private);
    export  = (export_flag  ||  qualif & qf_export)  &&  !private;

    name = v_ast_expr_identifier_get_name(v_cast(ast1, v_ast_expr_ptr));

    type  = v_list_get_item(list, 2);
    value = v_list_get_item(list, 3);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(type, visitor);

    var_type = *v_alloca(v_type_ptr);

    var_type := v_cast(v_get_result_value(), v_type_ptr);

    if (!v_empty(value))
    {
        //- assert(v_get_module() == 0);

        v_set_module(v_obtain_module());

        t = v_type_refptr_get_element_type(var_type);       //- Sic!
        a = v_type_refptr_get_address_space(var_type);      //- Sic!

        v_set_result_type(t);
        v_set_result_value(0);

        v_ast_accept_visitor(value, visitor);

        t = v_get_result_type();

        var_type := v_reference_type(t, a);
    }

    if (export) v_export_symbol_type(name, var_type);
    else        v_add_symbol(name, var_type, 0);

    if (!v_empty(value))
    {
        value_g = *v_alloca(LLVMValueRef);

        v_obtain_identifier(name, 0, &value_g);         //- Sic!

        if (private)  LLVMSetLinkage(value_g, LLVMPrivateLinkage);

        LLVMSetInitializer(value_g, v_get_result_value());

        v_set_module(0);
    }

    //-------------------------------------------------------------
    stmt_list = voidc_visitor_get_intrinsic(visitor, voidc_decl_stmt_list_q, 0);

    if (!stmt_list)  v_return();

    stmt_list = v_cast(stmt_list, v_ast_stmt_list_ptr);


    expr = v_alloca(v_ast_expr_t, 3);
    v_initialize(expr, 3);
    defer v_terminate(expr, 3);

    elst = v_alloca(v_ast_expr_list_t);
    v_initialize(elst);
    defer v_terminate(elst);

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);


    v_ast_make_expr_integer(expr+0, v_cast(var_type, intptr_t));        //- Sic!!!

    v_make_list(elst, expr+0, 1);

    v_ast_make_expr_identifier_q(expr+0, voidc_compile_type_q);

    v_ast_make_expr_call(expr+1, expr+0, elst);

    v_ast_make_expr_string(expr+0, name);


    if (export)
    {
        v_ast_make_stmt_call(stmt, 0, q_export_symbol_type, expr, 2);
    }
    else
    {
        v_ast_make_expr_integer(expr+2, 0);

        v_ast_make_stmt_call(stmt, 0, q_add_symbol, expr, 3);
    }

    v_list_append(stmt_list, stmt_list, stmt);
}

//---------------------------------------------------------------------
//- compile_unit_val_defn - visitor method
//---------------------------------------------------------------------
//{ v_debug_print_module(2); }
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_unit_val_defn", voidc_visitor_method_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("compile_unit_val_defn\n");
//  defer printf("compile_unit_val_defn leave\n");

    list = v_cast(self, v_ast_generic_list_ptr);

    ast0 = v_list_get_item(list, 0);
    ast1 = v_list_get_item(list, 1);

    //-------------------------------------------------------------
    qualif = v_ast_expr_integer_get_number(v_cast(ast0, v_ast_expr_ptr));

    private = (qualif & qf_private);
    export  = (export_flag  ||  qualif & qf_export)  &&  !private;

    name = v_ast_expr_identifier_get_name(v_cast(ast1, v_ast_expr_ptr));

    type  = v_list_get_item(list, 2);
    value = v_list_get_item(list, 3);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    if (!v_empty(type))
    {
        v_ast_accept_visitor(type, visitor);

        v_set_result_type(v_cast(v_get_result_value(), v_type_ptr));
    }

    v_set_result_value(0);

    v_ast_accept_visitor(value, visitor);

    t = v_get_result_type();
    v = v_get_result_value();

    if (export)
    {
        if (t == v_static_type_t) v_export_type(name, v_cast(v, v_type_ptr));
        else                      v_export_constant(name, t, v);
    }
    else
    {
        if (t == v_static_type_t) v_add_type(name, v_cast(v, v_type_ptr));
        else                      v_add_constant(name, t, v);
    }

    //-------------------------------------------------------------
    stmt_list = voidc_visitor_get_intrinsic(visitor, voidc_decl_stmt_list_q, 0);

    if (!stmt_list)  v_return();

    stmt_list = v_cast(stmt_list, v_ast_stmt_list_ptr);


    expr = v_alloca(v_ast_expr_t, 3);
    v_initialize(expr, 3);
    defer v_terminate(expr, 3);

    elst = v_alloca(v_ast_expr_list_t);
    v_initialize(elst);
    defer v_terminate(elst);

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);


    typ = *v_alloca(*void);

    if (t == v_static_type_t)  typ := v;
    else                       typ := t;

    v_ast_make_expr_integer(expr+0, v_cast(typ, intptr_t));         //- Sic!!!

    v_ast_make_stmt_call(stmt, typ_q, voidc_compile_type_q, expr+0, 1);

    v_list_append(stmt_list, stmt_list, stmt);

    v_ast_make_expr_identifier_q(expr+1, typ_q);


    if (t != v_static_type_t)
    {
        v_make_list(elst, expr+1, 1);

        v_ast_make_expr_identifier_q(expr+0, q_type_get_llvm_type);

        v_ast_make_expr_call(expr+0, expr+0, elst);

        v_make_list(elst, expr+0, 1);

        if (v_type_is_integer(t))
        {
            //- assert(v_type_integer_get_width(t) <= v_type_integer_get_width(intptr_t));

            cv = *v_alloca(intptr_t);

            if (v_type_integer_is_signed(t))
            {
                llv = LLVMConstIntGetSExtValue(v);

                cv := v_cast(llv, intptr_t);
            }
            else
            {
                ullv = LLVMConstIntGetZExtValue(v);

                cv := v_cast(ullv, intptr_t);
            }

            v_ast_make_expr_integer(expr+0, cv);

            v_list_append(elst, elst, expr+0, 1);

            v_ast_make_expr_identifier_q(expr+0, true_q);

            v_list_append(elst, elst, expr+0, 1);

            v_ast_make_expr_identifier_q(expr+0, LLVMConstInt_q);
        }
        else if (v_type_is_floating_point(t))
        {
            fl = *v_alloca(LLVMBool);

            cv = LLVMConstRealGetDouble(v, &fl);

            str = v_alloca(char, 32);

            sprintf(str, "%.13a", cv);              //- WTF ?!?!?!?!?

            v_ast_make_expr_string(expr+0, str);

            v_list_append(elst, elst, expr+0, 1);

            v_ast_make_expr_identifier_q(expr+0, LLVMConstRealOfString_q);
        }
        else    //- ?!?!?!?!?!?!?!?!?!?
        {
            v_ast_make_expr_identifier_q(expr+0, constant_type_not_supported_q);
        }

        v_ast_make_expr_call(expr+2, expr+0, elst);
    }

    v_ast_make_expr_string(expr+0, name);


    if (export)
    {
        if (t == v_static_type_t) v_ast_make_stmt_call(stmt, 0, q_export_type,     expr, 2);
        else                      v_ast_make_stmt_call(stmt, 0, q_export_constant, expr, 3);
    }
    else
    {
        if (t == v_static_type_t) v_ast_make_stmt_call(stmt, 0, q_add_type,     expr, 2);
        else                      v_ast_make_stmt_call(stmt, 0, q_add_constant, expr, 3);
    }

    v_list_append(stmt_list, stmt_list, stmt);
}


//---------------------------------------------------------------------
//- voidc.compile_type - compiler intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("voidc_compile_type_intrinsic", voidc_intrinsic_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "vis",  voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",  void_ptr);
    v_add_parameter_name(f, 2, "self", v_ast_base_ptr);
}
{
//  printf("voidc_compile_type_intrinsic\n");
//  defer printf("voidc_compile_type_intrinsic leave\n");

    call = v_cast(self, v_ast_expr_ptr);

    args = v_ast_expr_call_get_arg_list(call);

    ctx = *v_cast(aux, *voidc_compile_type_ctx_t);

    arg = v_list_get_item(args, 0);

    num = v_ast_expr_integer_get_number(arg);

    typ = v_cast(num, v_type_ptr);

    v = voidc_compile_type(typ, ctx);

    v_adopt_result(v_type_ptr, v);
}


//---------------------------------------------------------------------
//- compile_defn_list_unit - visitor method
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_defn_list_unit", voidc_visitor_method_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("compile_defn_list_unit\n");
//  defer printf("compile_defn_list_unit leave\n");

    list = v_cast(self, v_ast_generic_list_ptr);

    //- Definitions (i.e. "values of things") ---------------------

    saved_module := v_get_module();

    defn_module := saved_module;

    saved_obtain_module_ctx = *v_alloca(*void);
    saved_obtain_module_fun = v_get_obtain_module(&saved_obtain_module_ctx);

    v_set_obtain_module(check_defn_module, 0);

    //- Declarations (i.e. "types of things") ---------------------

    stmt_list = *v_alloca(v_ast_stmt_list_ptr);

    decl_stmt_list = v_alloca(v_ast_stmt_list_t);

    inner_visitor = v_alloca(voidc_visitor_t);
    v_initialize(inner_visitor);
    defer v_terminate(inner_visitor);

    v_copy(inner_visitor, visitor);


    if (v_target_local_ctx_has_parent())
    {
        //- We're importing - need to build a unit

        v_initialize(decl_stmt_list);

        v_make_list_nil(decl_stmt_list);

        voidc_visitor_set_intrinsic(inner_visitor, inner_visitor, voidc_decl_stmt_list_q, decl_stmt_list, 0);

        stmt_list := decl_stmt_list;
    }
    else
    {
        //- We'll do "direct declaration" ...

        stmt_list := 0;
    }

    defer  if (stmt_list)  v_terminate(decl_stmt_list);

    v_set_module(0);


    //-------------------------------------------------------------
    lst0 = v_cast(v_list_get_item(list, 0), v_ast_generic_list_ptr);

    n = v_list_get_size(lst0);

    i = *v_alloca(int) := 0;

    loop
    {
        if (i == n) v_break();

        lst1 = v_cast(v_list_get_item(lst0, i), v_ast_generic_list_ptr);

        v_ast_accept_visitor(v_cast(lst1, v_ast_base_ptr), inner_visitor);

        ++i;
    }


    //-------------------------------------------------------------
    if (stmt_list)      //- Importing
    {
        saved_target = v_target_get_global_ctx();

        v_target_set_global_ctx(v_target_get_voidc_global_ctx());

        saved_voidc_module = v_get_module();

        expr0 = v_cast(v_list_get_item(list, 1), v_ast_expr_ptr);
        expr1 = v_cast(v_list_get_item(list, 2), v_ast_expr_ptr);

        line   = v_cast(v_ast_expr_integer_get_number(expr0), int);
        column = v_cast(v_ast_expr_integer_get_number(expr1), int);

        voidc_prepare_unit_action(line, column);

        //---------------------------------------------------------
        v_import("level-00/voidc_target.void");
        v_import("level-00/voidc_types.void");

        v_import("llvm-c/Core.void");

        builder = v_target_get_builder();

        //---------------------------------------------------------
        ctx = *v_alloca(voidc_compile_type_ctx_t);

        voidc_compile_type_ctx_initialize(ctx);


        int_ = v_type_get_llvm_type(int);

        int_ptr_    = v_type_get_llvm_type(v_pointer_type(int, 0));
        v_type_ptr_ = v_type_get_llvm_type(v_type_ptr);

        dummy_len_v = LLVMBuildLoad2(builder, int_, LLVMGetUndef(int_ptr_), "dummy_len");

        ctx_stack = LLVMBuildArrayMalloc(builder, v_type_ptr_, dummy_len_v, "stk");

        voidc_compile_type_ctx_set_stack(ctx, ctx_stack);


        vis = inner_visitor;

        voidc_visitor_set_intrinsic(vis, vis, voidc_compile_type_q, voidc_compile_type_intrinsic, &ctx);


        v_ast_accept_visitor(v_cast(stmt_list, v_ast_base_ptr), vis);


        LLVMBuildFree(builder, ctx_stack);


        len = voidc_compile_type_ctx_get_stack_length(ctx);

        voidc_compile_type_ctx_terminate(ctx);

        LLVMReplaceAllUsesWith(dummy_len_v, LLVMConstInt(int_, len, 0));          //- Sic!!!

        LLVMInstructionEraseFromParent(dummy_len_v);


        //---------------------------------------------------------
        if (defn_module  &&  !saved_module)
        {
            v_finish_module(defn_module);

            voidc_prepare_module_for_jit(defn_module);

            voidc_compile_load_module_to_jit(defn_module, true, false);     //- local?  (TODO)

            LLVMDisposeModule(defn_module);
        }

        voidc_finish_unit_action();

        v_set_module(saved_voidc_module);

        v_target_set_global_ctx(saved_target);
    }
    else    //- "direct declarations"
    {
        voidc_flush_unit_symbols();         //- WTF?

        if (defn_module  &&  !saved_module)
        {
            //- voidc_guard_target(...);

            v_finish_module(defn_module);

            voidc_prepare_module_for_jit(defn_module);

            voidc_add_local_module_to_jit(defn_module);             //- local?  (TODO)

            LLVMDisposeModule(defn_module);
        }
    }


    //-------------------------------------------------------------
    v_set_obtain_module(saved_obtain_module_fun, saved_obtain_module_ctx);

    v_set_module(saved_module);
}


//---------------------------------------------------------------------
//- op_prefix_const/volatile - compiler intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_op_prefix_cv", voidc_intrinsic_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("compile_op_prefix_cv\n");

    call = v_cast(self, v_ast_expr_ptr);

    arg_list = v_ast_expr_call_get_arg_list(call);

    ast = v_list_get_item(arg_list, 1);

    //-----------------------------------------------------------------
    //- Just "ignore" it...
    //-----------------------------------------------------------------

    v_ast_accept_visitor(v_cast(ast, v_ast_base_ptr), visitor);
}


//---------------------------------------------------------------------
//- op_infix_to - compiler intrinsic (types only(!))
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_op_infix_to", voidc_intrinsic_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("compile_op_infix_to\n");
//  defer printf("compile_op_infix_to leave\n");

    call = v_cast(self, v_ast_expr_ptr);

    arg_list = v_ast_expr_call_get_arg_list(call);

    ast0 = v_list_get_item(arg_list, 1);

    args = v_ast_expr_call_get_arg_list(v_cast(ast0, v_ast_expr_ptr));

    args = v_cast(v_list_get_item(args, 1), v_ast_generic_list_ptr);


    argtypes = *v_alloca(* v_type_ptr) := 0;
    defer if (argtypes) v_free(argtypes);

    is_vararg = *v_alloca(bool) := false;

    count = *v_alloca(size_t) := v_list_get_size(args);

    if (count)
    {
        argtypes := v_malloc(v_type_ptr, count);

        i = *v_alloca(size_t) := 0;

        loop
        {
            if (i >= count) v_break();

            item = v_cast(v_list_get_item(args, i), v_ast_expr_list_ptr);

            item = v_cast(v_list_get_item(item, 1), v_ast_base_ptr);

            if (v_empty(item))
            {
                is_vararg := true;

                count := i;     //- ?

                v_break();
            }

            v_set_result_type(INVIOLABLE_TAG);
            v_set_result_value(0);

            v_ast_accept_visitor(item, visitor);

            argtypes[i] := v_cast(v_get_result_value(), v_type_ptr);

            ++i;
        }
    }

    ast1 = v_list_get_item(arg_list, 2);        //- Sic!

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(v_cast(ast1, v_ast_base_ptr), visitor);

    rtyp = v_cast(v_get_result_value(), v_type_ptr);

    ft = v_function_type(rtyp, argtypes, v_cast(count, unsigned), is_vararg);

    v_set_result_type(v_static_type_t);
    v_set_result_value(v_cast(ft, LLVMValueRef));
}


//---------------------------------------------------------------------
//- Set "export_flag"
//---------------------------------------------------------------------
{
    typ = *v_alloca(v_type_ptr) := bool;

    ft = v_function_type(void, &typ, 1, false);

    //-----------------------------------------------------------------
    f = v_function_hack("v_set_export_flag", ft);

    v_add_parameter_name(f, 0, "flag", bool);
}
{
    export_flag := flag;
}

//---------------------------------------------------------------------
//- Get "export_flag"
//---------------------------------------------------------------------
{
    ft = v_function_type(bool, 0, 0, false);

    //-----------------------------------------------------------------
    f = v_function_hack("v_get_export_flag", ft);
}
{
    v_return(export_flag);
}


//---------------------------------------------------------------------
//- v_undef intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("v_undef_intrinsic", voidc_intrinsic_t);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
    call = v_cast(self, v_ast_expr_ptr);

    arg_list = v_ast_expr_call_get_arg_list(call);

    t = *v_alloca(v_type_ptr) := v_get_result_type();

    if (v_list_get_size(arg_list))
    {
        arg = v_list_get_item(arg_list, 0);

        v_set_result_type(INVIOLABLE_TAG);
        v_set_result_value(0);

        v_ast_accept_visitor(v_cast(arg, v_ast_base_ptr), visitor);

        t := v_cast(v_get_result_value(), v_type_ptr);

        v_set_result_type(t);
    }

    v = LLVMGetUndef(v_type_get_llvm_type(t));

//  v_set_result_type(t);
    v_set_result_value(v);
}


//---------------------------------------------------------------------
//- Enable definitions compiler
//---------------------------------------------------------------------
{
    ft = v_function_type(void, 0, 0, false);

    //-----------------------------------------------------------------
    v_function_hack("voidc_enable_definitions_compiler", ft);
}
{
    v_return_if(voidc_visitor_get_void_method(voidc_compiler, unit_fun_defn_q, 0));

    voidc_enable_expression_compiler();         //- Sic!


    //-------------------------------------------------------------
    saved_ctx = v_malloc(convert_to_type_ctx_t);

    saved_ctx_fun = v_getelementptr(saved_ctx, 0, 0);
    saved_ctx_ctx = v_getelementptr(saved_ctx, 0, 1);

    v_store(v_get_convert_to_type(saved_ctx_ctx), saved_ctx_fun);

    v_set_convert_to_type(convert_to_type, saved_ctx);

    v_add_local_cleaner(v_cast(free, cleaner_ft_ptr), saved_ctx);


    //-------------------------------------------------------------
    vis = voidc_compiler;

    voidc_visitor_set_void_method(vis, vis, br_item_list_q,   compile_br_item_list,   0);
    voidc_visitor_set_void_method(vis, vis, unit_fun_defn_q,  compile_unit_fun_defn,  0);
    voidc_visitor_set_void_method(vis, vis, unit_var_defn_q,  compile_unit_var_defn,  0);
    voidc_visitor_set_void_method(vis, vis, unit_val_defn_q,  compile_unit_val_defn,  0);
    voidc_visitor_set_void_method(vis, vis, defn_list_unit_q, compile_defn_list_unit, 0);

    q = v_quark_from_string;

    voidc_visitor_set_intrinsic(vis, vis, q("v.op_infix_to"),        compile_op_infix_to,  0);
    voidc_visitor_set_intrinsic(vis, vis, q("v.op_prefix_const"),    compile_op_prefix_cv, 0);
    voidc_visitor_set_intrinsic(vis, vis, q("v.op_prefix_volatile"), compile_op_prefix_cv, 0);

    voidc_visitor_set_intrinsic(vis, vis, q("v.internal.var_decl"), v_internal_var_decl_intrinsic, 0);
    voidc_visitor_set_intrinsic(vis, vis, q("v.internal.var_defn"), v_internal_var_defn_intrinsic, 0);
    voidc_visitor_set_intrinsic(vis, vis, q("v.internal.val_defn"), v_internal_val_defn_intrinsic, 0);

    voidc_visitor_set_intrinsic(vis, vis, q("v_undef"), v_undef_intrinsic, 0);

    //-----------------------------------------------------------------
    voidc_visitor_set_intrinsic(vis, vis, q_prepare_function_parameters, v_prepare_function_parameters_default, 0);


    //-----------------------------------------------------------------
    typ = *v_alloca(v_type_ptr) := bool;

    ft = v_function_type(void, &typ, 1, false);

    v_add_symbol("v_set_export_flag", ft, 0);

    ft = v_function_type(bool, 0, 0, false);

    v_add_symbol("v_get_export_flag", ft, 0);
}


//---------------------------------------------------------------------
//- Enable definitions
//---------------------------------------------------------------------
{
    ft = v_function_type(void, 0, 0, false);

    //-----------------------------------------------------------------
    v_function_hack("voidc_enable_definitions", ft);
}
{
    voidc_enable_definitions_compiler();


    v_return_if_not(voidc_has_grammar());
    v_return_if(voidc_grammar_has_parser("unit_fun_defn"));


    voidc_enable_expression();          //- Sic!


    any = v_alloca(v_std_any_t, 6);
    v_initialize(any, 6);
    defer v_terminate(any, 6);

    any_to       = any + 0;
    any_const    = any + 1;
    any_volatile = any + 2;

    v_std_any_set_pointer(any_to,       op_infix_to);
    v_std_any_set_pointer(any_const,    op_prefix_const);
    v_std_any_set_pointer(any_volatile, op_prefix_volatile);

    any_qf_none    = any + 3;
    any_qf_export  = any + 4;
    any_qf_private = any + 5;

    v_std_any_set_value(any_qf_none,    qf_none);
    v_std_any_set_value(any_qf_export,  qf_export);
    v_std_any_set_value(any_qf_private, qf_private);


    gr0 = v_alloca(v_peg_grammar_t);
    v_initialize(gr0);
    defer v_terminate(gr0);

    v_peg_get_grammar(gr0);

    grammar gr0
    {
    values:
        op_infix_to        = any_to;
        op_prefix_const    = any_const;
        op_prefix_volatile = any_volatile;

        qf_none    = any_qf_none;
        qf_export  = any_qf_export;
        qf_private = any_qf_private;

    actions:
        mk_br_item_list      = mk_br_item_list_grammar_action;
        mk_br_item           = mk_br_item_grammar_action;
        mk_qualif_flags      = mk_qualif_flags_grammar_action;
        mk_qlf_ident         = mk_qlf_ident_grammar_action;
        mk_unit_fun_defn_hdr = mk_unit_fun_defn_hdr_grammar_action;
        mk_unit_fun_defn     = mk_unit_fun_defn_grammar_action;
        mk_unit_var_defn     = mk_unit_var_defn_grammar_action;
        mk_unit_val_defn     = mk_unit_val_defn_grammar_action;
        mk_unit_defn_list    = mk_unit_defn_list_grammar_action;
        mk_defn_list_unit    = mk_defn_list_unit_grammar_action;

        mk_stmt_var_defn = mk_stmt_var_defn_grammar_action;
        mk_stmt_val_defn = mk_stmt_val_defn_grammar_action;

    parsers:

        prefix += "const"    !ident_cont  { op_prefix_const }
                / "volatile" !ident_cont  { op_prefix_volatile }
                ;


        infix += "->"   { op_infix_to };


        bracketed = '('_ l:br_item_list _')'    { mk_bracketed(op_parentheses, l) }
                  ;

        br_item_list = br_item_list_lr
                     /                          { mk_br_item_list(0, 0) }
                     ;

        br_item_list_lr = l:br_item_list_lr _','_ i:br_item     { mk_br_item_list(l, i) }
                        / i:br_item                             { mk_br_item_list(0, i) }
                        ;

        br_item_list_lr is left-recursive;


        br_item = k:expr _':'_ e:expr           { mk_br_item(k, e) }
                / e:expr                        { mk_br_item(0, e) }
                / "..."                         { mk_br_item(0, 0) }
                ;


        qualif_flag = "export"  !ident_cont     {qf_export}
                    / "private" !ident_cont     {qf_private}
                    ;

        qualif_flags_lr = qfs:qualif_flags_lr _ qf:qualif_flag      { mk_qualif_flags(qfs, qf) }
                        / qualif_flag
                        ;

        qualif_flags_lr is left-recursive;

        qualif_flags = qualif_flags_lr
                     /                      {qf_none}
                     ;

        qlf_ident = q:qualif_flags _ i:identifier       { mk_qlf_ident(q, i) };


        unit_fun_defn_hdr = qf:qlf_ident _':'_ a:bracketed _"->"_ r:expr    { mk_unit_fun_defn_hdr(qf, a, r) };

        unit_fun_defn = h:unit_fun_defn_hdr _';'                    { mk_unit_fun_defn(h, 0) }
                      / h:unit_fun_defn_hdr _'{'_ l:stmt_list _'}'  { mk_unit_fun_defn(h, l) }
                      ;


        unit_defn_list_lr = l:unit_defn_list_lr _ d:unit_defn   { mk_unit_defn_list(l, d) }
                          / d:unit_defn                         { mk_unit_defn_list(0, d) }
                          ;

        unit_defn_list_lr is left-recursive;


        unit_defn = unit_fun_defn
                  / unit_var_defn
                  / unit_val_defn
                  ;


        unit_var_defn = qi:qlf_ident _':'_ tv: expr _';'                { mk_unit_var_defn(qi, tv) }         //- Sic!!!
                      ;


        unit_val_defn = qi:qlf_ident _':'_ t: expr _'='_ v:expr _';'    { mk_unit_val_defn(qi, t, v) }
                      / qi:qlf_ident _'='_ v:expr _';'                  { mk_unit_val_defn(qi, 0, v) }
                      ;


        unit += _ <l:unit_defn_list_lr>     { mk_defn_list_unit(l, $1s) };


        stmt_defn = stmt_var_defn
                  / stmt_val_defn
                  ;


        stmt_var_defn = i:identifier _':'_ tv: expr _';'                { mk_stmt_var_defn(i, tv) }         //- Sic!!!
                 ;


        stmt_val_defn = i:identifier _':'_ t: expr _'='_ v:expr _';'    { mk_stmt_val_defn(i, t, v) }
                 ;


        stmt += stmt_defn;
    }

    v_peg_set_grammar(gr0);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
{
    module = v_get_module();

    //-----------------------------------------------------------------
//  v_debug_print_module(1);

    voidc_unit_load_module_to_jit(module, true);

    LLVMDisposeModule(module);
    v_set_module(0);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
{
    export_flag := false;

    v_initialize(op_infix_to);
    v_initialize(op_prefix_const);
    v_initialize(op_prefix_volatile);

    op_binary = v_ast_make_operator_binary;
    op_unary  = v_ast_make_operator_unary;

    q = v_quark_from_string;

    op_binary(op_infix_to, q("v.op_infix_to"), 2000, 0, 0);                 //- "Lowest" priority, right-assoc

    op_unary(op_prefix_const,    q("v.op_prefix_const"),    20000, 0);      //- "Prefix" priority
    op_unary(op_prefix_volatile, q("v.op_prefix_volatile"), 20000, 0);      //- "Prefix" priority

    v_add_cleaner(voidc_definitions_internal_globals_cleaner, 0);
}


//---------------------------------------------------------------------
{
    v_make_export_symbol("voidc_compile_unit_fun_defn_helper");

    v_make_export_symbol("voidc_enable_definitions_compiler");
    v_make_export_symbol("voidc_enable_definitions");
}


