//---------------------------------------------------------------------
//- Copyright (C) 2020-2022 Dmitry Borodkin <borodkin.dn@gmail.com>
//- SDPX-License-Identifier: LGPL-3.0-or-later
//---------------------------------------------------------------------
{   voidc_guard_target("definitions.void  must be imported into the voidc target only!");

    v_import("level-00");

    v_import("llvm-c/Core.void");

    v_import("function_hack.void");
    v_import("memory.void");
    v_import("if_then_else.void");
    v_import("block.void");
    v_import("loop.void");
    v_import("grammar.void");
    v_import("expression.void");
    v_import("defer.void");
}

{   voidc_enable_statement_if_then_else();
    voidc_enable_statement_block();
    voidc_enable_statement_loop();
    voidc_enable_statement_grammar();
    voidc_enable_expression();
    voidc_enable_statement_defer();
}

{   v_import("compile_type.void");
}

//{ v_import("printf.void"); }


//---------------------------------------------------------------------
{   v_add_type("void_ptr", v_pointer_type(void, 0));
    v_add_type("char_ptr", v_pointer_type(char, 0));

    convert_to_type_ctx_t = v_struct_type_named("struct.convert_to_type_ctx_t");

    v_add_type("convert_to_type_ctx_t",   convert_to_type_ctx_t);
    v_add_type("convert_to_type_ctx_ptr", v_pointer_type(convert_to_type_ctx_t, 0));

    v_add_type("incomplete_array_type_tag", v_struct_type_named("voidc.incomplete_array_type_tag"));
}


//---------------------------------------------------------------------
{   typ = v_alloca(v_type_ptr, 2);

    typ[0] := char_ptr;
    typ[1] := char_ptr;

    ft = v_function_type(int, typ, 2, false);
    v_add_symbol("strcmp", ft, 0);

//  typ[0] := char_ptr;

    ft = v_function_type(void, typ, 1, false);
    v_add_symbol("free", ft, 0);

    typ[0] := void_ptr;

    ft = v_function_type(void, typ, 1, false);
    v_add_type("cleaner_ft_ptr", v_pointer_type(ft, 0));

    //-----------------------------------------------------------------
    LLVMDisposeMemoryBuffer(voidc_get_unit_buffer());
    voidc_set_unit_buffer(0);
}


//---------------------------------------------------------------------
//- Some utility...
//---------------------------------------------------------------------
{   typ = v_alloca(v_type_ptr, 2);

    typ[0] := char_ptr;
    typ[1] := v_type_ptr;

    ft = v_function_type(LLVMValueRef, typ, 2, false);

    //-----------------------------------------------------------------
    f = v_function_hack("v_make_global", ft);

    v_add_parameter_name(f, 0, "name", char_ptr);
    v_add_parameter_name(f, 1, "type", v_type_ptr);
}
{
    v_add_symbol(name, type, 0);

    if (!voidc_has_grammar())   v_return(0);

    t = *v_alloca(v_type_ptr);

    if (v_type_is_reference(type))  t := v_type_refptr_get_element_type(type);
    else                            t := type;

    t_ = v_type_get_llvm_type(t);

    value = LLVMAddGlobal(v_get_module(), t_, name);

    LLVMSetInitializer(value, LLVMGetUndef(t_));

    v_return(value);
}


//---------------------------------------------------------------------
{   typ = v_alloca(v_type_ptr, 3);

    //-----------------------------------------------------------------
    //- method ...
    //-----------------------------------------------------------------
    typ[0] := voidc_visitor_ptr;
    typ[1] := void_ptr;
    typ[2] := v_ast_generic_list_ptr;

    method_ft = v_function_type(void, typ, 3, false);

    v_add_type("method_ft", method_ft);
}


//---------------------------------------------------------------------
//- Module ...
//---------------------------------------------------------------------
{   module = LLVMModuleCreateWithName("voidc_definitions_internal_module");

    v_set_module(module);

    //-----------------------------------------------------------------
    LLVMDisposeMemoryBuffer(voidc_get_unit_buffer());
    voidc_set_unit_buffer(0);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
{
    bool_ref = v_reference_type(bool, 0);
    mod_ref  = v_reference_type(LLVMModuleRef, 0);
    lst_ref  = v_reference_type(v_ast_generic_list_ptr, 0);

    v_make_global("export_flag", bool_ref);

    v_make_global("saved_module", mod_ref);
    v_make_global("defn_module",  mod_ref);
    v_make_global("decl_list",    lst_ref);
    v_make_global("const_list",   lst_ref);

    v_make_global("op_infix_to",        v_ast_opaque_expr_sptr);
    v_make_global("op_prefix_const",    v_ast_opaque_expr_sptr);
    v_make_global("op_prefix_volatile", v_ast_opaque_expr_sptr);

    intptr_t_ = v_type_get_llvm_type(intptr_t);

    v_add_constant("qf_none",    intptr_t, LLVMConstInt(intptr_t_, 0, 0));
    v_add_constant("qf_export",  intptr_t, LLVMConstInt(intptr_t_, 1, 0));
    v_add_constant("qf_private", intptr_t, LLVMConstInt(intptr_t_, 2, 0));


    typ = v_alloca(v_type_ptr);

    typ[0] := void_ptr;

    ft = v_function_type(void, typ, 1, false);

    //-----------------------------------------------------------------
    f = v_function_hack("voidc_definitions_internal_globals_cleaner", ft);
}
{
//  printf("voidc_definitions_internal_globals_cleaner\n");

    v_terminate(op_infix_to);
    v_terminate(op_prefix_const);
    v_terminate(op_prefix_volatile);
}

//---------------------------------------------------------------------
{
    quark_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("br_item_list_q",   quark_ref, q("br_item_list"));
    v_add_symbol("unit_fun_defn_q",  quark_ref, q("unit_fun_defn"));
    v_add_symbol("unit_var_defn_q",  quark_ref, q("unit_var_defn"));
    v_add_symbol("unit_val_defn_q",  quark_ref, q("unit_val_defn"));
    v_add_symbol("defn_list_unit_q", quark_ref, q("defn_list_unit"));
}


//---------------------------------------------------------------------
//- mk_br_item - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_br_item_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any",       v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("mk_br_item_grammar_action\n");

    key  = v_std_any_get_pointer(v_ast_opaque_expr_sptr, any+0);
    type = v_std_any_get_pointer(v_ast_opaque_expr_sptr, any+1);

    expr = v_alloca(v_ast_opaque_expr_sptr, 2);
    v_initialize(expr, 2);
    defer v_terminate(expr, 2);

    if (key)    v_copy(expr+0, key);
    if (type)   v_copy(expr+1, type);

    lst = v_alloca(v_ast_opaque_expr_list_sptr);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, expr, 2);

    v_std_any_set_pointer(ret, lst);
}

//---------------------------------------------------------------------
//- mk_br_item_list - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_br_item_list_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any",       v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("mk_br_item_list_grammar_action\n");

    list = v_std_any_get_pointer(v_ast_opaque_expr_sptr, any+0);
    list = v_cast(list, v_ast_generic_list_ptr);                    //- Sic!!!

    item = v_std_any_get_pointer(v_ast_opaque_expr_list_sptr, any+1);

    lst = v_alloca(v_ast_opaque_generic_list_sptr);
    v_initialize(lst);
    defer v_terminate(lst);

    if (list)   v_list_append(lst, list, v_cast(item, v_ast_base_ptr));
    else
    {
        if (item)   v_make_list(lst, br_item_list_q, v_cast(item, v_ast_base_ptr), 1);
        else        v_make_list_nil(lst, br_item_list_q);
    }

    v_std_any_set_pointer(ret, v_cast(lst, v_ast_expr_ptr));        //- Sic!!!
}


//---------------------------------------------------------------------
//- mk_qlf_ident - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_qlf_ident_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any",       v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("mk_qlf_ident_grammar_action\n");

    qualif = v_std_any_get_value(intptr_t, any+0);

    name = v_std_any_get_pointer(v_util_opaque_std_string,    any+1);

    ast = v_alloca(v_ast_opaque_base_sptr, 2);
    v_initialize(ast, 2);
    defer v_terminate(ast, 2);

    v_ast_make_expr_integer(v_cast(&ast[0], v_ast_expr_ptr), qualif);

    v_ast_make_expr_identifier(v_cast(&ast[1], v_ast_expr_ptr), v_std_string_get(name));

    lst = v_alloca(v_ast_opaque_generic_list_sptr);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, 0, ast, 2);

    v_std_any_set_pointer(ret, lst);
}


//---------------------------------------------------------------------
//- mk_unit_fun_defn_hdr - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_unit_fun_defn_hdr_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any",       v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("mk_unit_fun_defn_hdr_grammar_action\n");

    q_id = v_std_any_get_pointer(v_ast_opaque_generic_list_sptr, any+0);

    args = v_std_any_get_pointer(v_ast_opaque_expr_sptr, any+1);
    type = v_std_any_get_pointer(v_ast_opaque_expr_sptr, any+2);

    ast = v_alloca(v_ast_opaque_base_sptr, 4);
    v_initialize(ast, 4);
    defer v_terminate(ast, 4);

    v_list_get_items(q_id, 0, ast, 2);

    v_copy(ast+2, v_cast(args, v_ast_base_ptr));
    v_copy(ast+3, v_cast(type, v_ast_base_ptr));

    lst = v_alloca(v_ast_opaque_generic_list_sptr);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, unit_fun_defn_q, ast, 4);

    v_std_any_set_pointer(ret, lst);
}

//---------------------------------------------------------------------
//- mk_unit_fun_defn - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_unit_fun_defn_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any",       v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("mk_unit_fun_defn_grammar_action\n");

    head = v_std_any_get_pointer(v_ast_opaque_generic_list_sptr, any+0);
    body = v_std_any_get_pointer(v_ast_opaque_stmt_list_sptr,    any+1);

    ast = v_alloca(v_ast_opaque_base_sptr);
    v_initialize(ast);
    defer v_terminate(ast);

    if (body)   v_copy(ast, v_cast(body, v_ast_base_ptr));

    lst = v_alloca(v_ast_opaque_generic_list_sptr);
    v_initialize(lst);
    defer v_terminate(lst);

    v_list_append(lst, head, ast, 1);

    v_std_any_set_pointer(ret, lst);
}

//---------------------------------------------------------------------
//- mk_unit_var_defn - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_unit_var_defn_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any",       v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("mk_unit_var_defn_grammar_action\n");
//  defer printf("mk_unit_var_defn_grammar_action leave\n");

    q_id = v_std_any_get_pointer(v_ast_opaque_generic_list_sptr, any+0);

    expr = v_std_any_get_pointer(v_ast_opaque_expr_sptr, any+1);

    ast = v_alloca(v_ast_opaque_base_sptr, 4);
    v_initialize(ast, 4);
    defer v_terminate(ast, 4);

    type  = v_cast(ast+2, v_ast_expr_ptr);
    value = v_cast(ast+3, v_ast_expr_ptr);

    v_copy(type, expr);

    block
    {
        tag = v_ast_base_get_visitor_method_tag(ast+2);

        if (tag != v_ast_expr_call_t_visitor_method_tag) v_break();

        ast2 = v_cast(ast+2, v_ast_expr_ptr);

        etmp = v_alloca(v_ast_opaque_expr_sptr);
        v_initialize(etmp);
        defer v_terminate(etmp);

        v_ast_expr_call_get_fun_expr(ast2, etmp);

        tag = v_ast_base_get_visitor_method_tag(v_cast(etmp, v_ast_base_ptr));

        if (tag != v_ast_expr_identifier_t_visitor_method_tag) v_break();

        name = v_ast_expr_identifier_get_name(etmp);

        if (strcmp(name, "v.op_infix_assign"))  v_break();

        arg_list = v_cast(etmp, v_ast_expr_list_ptr);

        v_ast_expr_call_get_arg_list(ast2, arg_list);

        v_list_get_items(arg_list, 1, ast2, 2);
    }

    v_list_get_items(q_id, 0, ast, 2);

    lst = v_alloca(v_ast_opaque_generic_list_sptr);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, unit_var_defn_q, ast, 4);

    v_std_any_set_pointer(ret, lst);
}

//---------------------------------------------------------------------
//- mk_unit_val_defn - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_unit_val_defn_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any",       v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("mk_unit_var_defn_grammar_action\n");

    q_id = v_std_any_get_pointer(v_ast_opaque_generic_list_sptr, any+0);

    type  = v_std_any_get_pointer(v_ast_opaque_expr_sptr, any+1);
    value = v_std_any_get_pointer(v_ast_opaque_expr_sptr, any+2);

    ast = v_alloca(v_ast_opaque_base_sptr, 4);
    v_initialize(ast, 4);
    defer v_terminate(ast, 4);

    v_list_get_items(q_id, 0, ast, 2);

    if (type)   v_copy(ast+2, v_cast(type, v_ast_base_ptr));

    v_copy(ast+3, v_cast(value, v_ast_base_ptr));

    lst = v_alloca(v_ast_opaque_generic_list_sptr);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, unit_val_defn_q, ast, 4);

    v_std_any_set_pointer(ret, lst);
}


//---------------------------------------------------------------------
//- mk_unit_defn_list - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_unit_defn_list_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any",       v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("mk_unit_defn_list_grammar_action\n");

    list = v_std_any_get_pointer(v_ast_opaque_generic_list_sptr, any+0);
    item = v_std_any_get_pointer(v_ast_opaque_generic_list_sptr, any+1);

    lst = v_alloca(v_ast_opaque_generic_list_sptr);
    v_initialize(lst);
    defer v_terminate(lst);

    if (list)   v_list_append(lst, list, v_cast(item, v_ast_base_ptr));
    else
    {
        v_make_list(lst, 0, v_cast(item, v_ast_base_ptr), 1);
    }

    v_std_any_set_pointer(ret, lst);
}

//---------------------------------------------------------------------
//- mk_defn_list_unit - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_defn_list_unit_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any",       v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("mk_defn_list_unit_grammar_action\n");

    list = v_std_any_get_pointer(v_ast_opaque_generic_list_sptr, any+0);

    pos = v_std_any_get_value(size_t, any+1);

    line   = *v_alloca(size_t) := 0;
    column = *v_alloca(size_t) := 0;

    v_peg_get_line_column(pos, line, column);

    ast = v_alloca(v_ast_opaque_base_sptr, 3);
    v_initialize(ast, 3);
    defer v_terminate(ast, 3);

    v_copy(&ast[0], v_cast(list, v_ast_base_ptr));

    v_ast_make_expr_integer(v_cast(&ast[1], v_ast_expr_ptr), v_cast(line,   intptr_t));
    v_ast_make_expr_integer(v_cast(&ast[2], v_ast_expr_ptr), v_cast(column, intptr_t));

    lst = v_alloca(v_ast_opaque_generic_list_sptr);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, defn_list_unit_q, ast, 3);

    v_std_any_set_pointer(ret, v_cast(lst, v_ast_unit_ptr));        //- Sic!!!
}


//---------------------------------------------------------------------
//- mk_stmt_var_defn - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_stmt_var_defn_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any",       v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("mk_stmt_var_defn_grammar_action\n");

    name = v_std_any_get_pointer(v_util_opaque_std_string, any+0);

    expr = v_std_any_get_pointer(v_ast_opaque_expr_sptr, any+1);

    ast = v_alloca(v_ast_opaque_base_sptr, 2);
    v_initialize(ast, 2);
    defer v_terminate(ast, 2);

    type  = v_cast(ast+0, v_ast_expr_ptr);
    value = v_cast(ast+1, v_ast_expr_ptr);

    v_copy(type, expr);

    block
    {
        tag = v_ast_base_get_visitor_method_tag(ast+0);

        if (tag != v_ast_expr_call_t_visitor_method_tag) v_break();

        ast0 = v_cast(ast+0, v_ast_expr_ptr);

        etmp = v_alloca(v_ast_opaque_expr_sptr);
        v_initialize(etmp);
        defer v_terminate(etmp);

        v_ast_expr_call_get_fun_expr(ast0, etmp);

        tag = v_ast_base_get_visitor_method_tag(v_cast(etmp, v_ast_base_ptr));

        if (tag != v_ast_expr_identifier_t_visitor_method_tag) v_break();

        name = v_ast_expr_identifier_get_name(etmp);

        if (strcmp(name, "v.op_infix_assign"))  v_break();

        arg_list = v_cast(etmp, v_ast_expr_list_ptr);

        v_ast_expr_call_get_arg_list(ast0, arg_list);

        v_list_get_items(arg_list, 1, ast0, 2);
    }

    lst = v_alloca(v_ast_opaque_expr_list_sptr);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, type, 2);

    etmp = v_alloca(v_ast_opaque_expr_sptr);
    v_initialize(etmp);
    defer v_terminate(etmp);

    v_ast_make_expr_identifier(etmp, "v.internal.var_defn");

    v_ast_make_expr_call(etmp, etmp, lst);

    stmt = v_alloca(v_ast_opaque_stmt_sptr);
    v_initialize(stmt);
    defer v_terminate(stmt);

    v_ast_make_stmt(stmt, v_std_string_get(name), etmp);

    v_std_any_set_pointer(ret, stmt);
}

//---------------------------------------------------------------------
//- mk_stmt_val_defn - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_stmt_val_defn_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_util_std_any_ptr);
    v_add_parameter_name(f, 1, "any",       v_util_std_any_ptr);
    v_add_parameter_name(f, 2, "any_count", size_t);
}
{
//  printf("mk_stmt_val_defn_grammar_action\n");

    name = v_std_any_get_pointer(v_util_opaque_std_string, any+0);

    type = v_std_any_get_pointer(v_ast_opaque_expr_sptr, any+1);
    expr = v_std_any_get_pointer(v_ast_opaque_expr_sptr, any+2);

    lst = v_alloca(v_ast_opaque_expr_list_sptr);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, expr, 1);

    v_list_append(lst, lst, type, 1);

    etmp = v_alloca(v_ast_opaque_expr_sptr);
    v_initialize(etmp);
    defer v_terminate(etmp);

    v_ast_make_expr_identifier(etmp, "v.internal.val_defn");

    v_ast_make_expr_call(etmp, etmp, lst);

    stmt = v_alloca(v_ast_opaque_stmt_sptr);
    v_initialize(stmt);
    defer v_terminate(stmt);

    v_ast_make_stmt(stmt, v_std_string_get(name), etmp);

    v_std_any_set_pointer(ret, stmt);
}


//---------------------------------------------------------------------
//- convert_to_type - utility...
//---------------------------------------------------------------------
{
    typ0 = v_alloca(v_type_ptr, 4);
    typ1 = v_getelementptr(typ0, 1);
    typ2 = v_getelementptr(typ0, 2);
    typ3 = v_getelementptr(typ0, 3);

    v_store(void_ptr,     typ0);
    v_store(v_type_ptr,   typ1);
    v_store(LLVMValueRef, typ2);
    v_store(v_type_ptr,   typ3);

    ft = v_function_type(LLVMValueRef, typ0, 4, false);

    //-----------------------------------------------------------------
    f = v_function_hack("convert_to_type", ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "void_ctx", void_ptr);
    v_add_parameter_name(f, 1, "type",     v_type_ptr);
    v_add_parameter_name(f, 2, "value",    LLVMValueRef);
    v_add_parameter_name(f, 3, "to_type",  v_type_ptr);
}
{
    if (type == to_type)  v_return(value);

    block
    {
        if (!v_type_is_struct(to_type))  v_break();

        typs = v_type_struct_get_element_types(to_type);

        if (typs[0] != incomplete_array_type_tag)  v_break();

        v_set_result_type(type);        //- Sic!!!

        v_return(value);
    }

    ctx = *v_cast(void_ctx, convert_to_type_ctx_ptr);

    saved_fun = ctx[0];
    saved_ctx = ctx[1];

    v_return(saved_fun(saved_ctx, type, value, to_type));         //- Sic!!!
}


//---------------------------------------------------------------------
//- v.internal.var_defn - compiler intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("v_internal_var_defn_intrinsic", voidc_intrinsic_t);

    v_add_parameter_name(f, 0, "visitor",  voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",      void_ptr);
    v_add_parameter_name(f, 2, "arg_list", v_ast_expr_list_ptr);
}
{
//  printf("v_internal_var_defn_intrinsic\n");
//  defer printf("v_internal_var_defn_intrinsic leave\n");

    arg = v_alloca(v_ast_opaque_expr_sptr, 2);
    v_initialize(arg, 2);
    defer v_terminate(arg, 2);

    v_list_get_items(arg_list, 0, arg, 2);

    v_set_result_type(INVIOLABLE_TAG);

    v_ast_accept_visitor(v_cast(arg+0, v_ast_base_ptr), visitor);           //- Type

    var_type = v_cast(v_get_result_value(), v_type_ptr);

    t = v_type_refptr_get_element_type(var_type);       //- Sic!
    a = v_type_refptr_get_address_space(var_type);      //- Sic!

    v_set_result_type(t);

    v_ast_accept_visitor(v_cast(arg+1, v_ast_base_ptr), visitor);           //- Value

    t = v_get_result_type();
    v = v_get_result_value();

    builder = v_target_get_builder();

    t_ = v_type_get_llvm_type(t);

    var_value = LLVMBuildAlloca(builder, t_, "");

    LLVMBuildStore(builder, v, var_value);

    v_set_result_type(v_reference_type(t, a));
    v_set_result_value(var_value);
}

//---------------------------------------------------------------------
//- v.internal.val_defn - compiler intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("v_internal_val_defn_intrinsic", voidc_intrinsic_t);

    v_add_parameter_name(f, 0, "visitor",  voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",      void_ptr);
    v_add_parameter_name(f, 2, "arg_list", v_ast_expr_list_ptr);
}
{
//  printf("v_internal_val_defn_intrinsic\n");
//  defer printf("v_internal_val_defn_intrinsic leave\n");

    arg = v_alloca(v_ast_opaque_expr_sptr, 2);
    v_initialize(arg, 2);
    defer v_terminate(arg, 2);

    v_list_get_items(arg_list, 0, arg, 2);

    v_set_result_type(INVIOLABLE_TAG);

    v_ast_accept_visitor(v_cast(arg+1, v_ast_base_ptr), visitor);           //- Type

    t = v_cast(v_get_result_value(), v_type_ptr);

    v_set_result_type(t);

    v_ast_accept_visitor(v_cast(arg+0, v_ast_base_ptr), visitor);           //- Value
}


//---------------------------------------------------------------------
//- compile_br_item_list - visitor method - special cases for '(' _ (expr _ ':')? _ expr _ ')'
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_br_item_list", method_ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "list",    v_ast_generic_list_ptr);
}
{
//  printf("compile_br_item_list\n");
//  defer printf("compile_br_item_list leave\n");

    lst = v_alloca(v_ast_opaque_expr_list_sptr);
    v_initialize(lst);
    defer v_terminate(lst);

    v_list_get_items(list, 0, v_cast(lst, v_ast_base_ptr));     //- Just first one

    expr = v_alloca(v_ast_opaque_expr_sptr);
    v_initialize(expr);
    defer v_terminate(expr);

    v_list_get_items(lst, 0, expr);

    if (!v_empty(expr))
    {
        v_ast_make_expr_identifier(expr, "v_cast");

        v_ast_make_expr_call(expr, expr, lst);
    }
    else
    {
        v_list_get_items(lst, 1, expr);
    }

    v_ast_accept_visitor(v_cast(expr, v_ast_base_ptr), visitor);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
{
    ft = v_function_type(LLVMModuleRef, 0, 0, false);

    //-----------------------------------------------------------------
    f = v_function_hack("check_defn_module", ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);
}
{
    if (!defn_module)
    {
        //- voidc_guard_target(...);

        defn_module := LLVMModuleCreateWithName("voidc_definitions_internal_defn_module");
    }

    v_return(defn_module);
}

//---------------------------------------------------------------------
//- compile_unit_fun_defn - visitor method
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_unit_fun_defn", method_ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "list",    v_ast_generic_list_ptr);
}
{
//  printf("compile_unit_fun_defn\n");
//  defer printf("compile_unit_fun_defn leave\n");

    ast = v_alloca(v_ast_opaque_base_sptr, 9);
    v_initialize(ast, 9);
    defer v_terminate(ast, 9);

    v_list_get_items(list, 0, ast, 5);

    //-------------------------------------------------------------
    qualif = v_ast_expr_integer_get_number(v_cast(ast+0, v_ast_expr_ptr));

    private = (qualif == qf_private);
    export  = (export_flag  ||  qualif == qf_export)  &&  !private;

    name = v_ast_expr_identifier_get_name(v_cast(ast+1, v_ast_expr_ptr));

    params   = ast + 2;
    ret_type = ast + 3;
    body     = ast + 4;

    //-------------------------------------------------------------
    args = v_cast(ast+5, v_ast_expr_list_ptr);

    v_ast_expr_call_get_arg_list(v_cast(params, v_ast_expr_ptr), args);

    v_list_get_items(args, 1, v_cast(ast+5, v_ast_expr_ptr));

    args = v_cast(ast+5, v_ast_generic_list_ptr);


    //-------------------------------------------------------------
    expr = v_alloca(v_ast_opaque_expr_sptr);
    v_initialize(expr);
    defer v_terminate(expr);

    v_ast_make_expr_op_binary(expr, op_infix_to, v_cast(params, v_ast_expr_ptr), v_cast(ret_type, v_ast_expr_ptr));


    v_set_result_type(INVIOLABLE_TAG);

    v_ast_accept_visitor(v_cast(expr, v_ast_base_ptr), visitor);

    fun_type = v_cast(v_get_result_value(), v_type_ptr);

    if (export) v_export_symbol_type(name, fun_type);
    else        v_add_symbol(name, fun_type, 0);

    //-------------------------------------------------------------
    if (decl_list)      //- Importing
    {
        item = v_alloca(v_ast_opaque_expr_list_sptr);
        v_initialize(item);
        defer v_terminate(item);

        v_ast_make_expr_identifier(expr, name);

        v_make_list(item, expr, 1);

        v_ast_make_expr_integer(expr, export);

        v_list_append(item, item, expr, 1);

        v_list_append(decl_list, decl_list, v_cast(item, v_ast_base_ptr));
    }

    if (!v_empty(body))
    {
        count = v_type_function_get_param_count(fun_type);

        argtypes = v_type_function_get_param_types(fun_type);

        //- assert(v_get_module() == 0);

        v_set_module(check_defn_module());

        f = v_prepare_function(name, fun_type);

        if (private)  LLVMSetLinkage(f, LLVMPrivateLinkage);

        if (count)
        {
            item = v_alloca(v_ast_opaque_generic_list_sptr);
            v_initialize(item);
            defer v_terminate(item);

            i = *v_alloca(int) := 0;

            loop
            {
                if (i >= count) v_break();

                v_list_get_items(args, i, v_cast(item, v_ast_base_ptr));

                v_list_get_items(item, 0, v_cast(expr, v_ast_base_ptr));

                if (!v_empty(expr))
                {
                    pname = v_ast_expr_identifier_get_name(expr);

                    v_add_parameter_name(f, i, pname, argtypes[i]);
                }

                ++i;
            }
        }

        v_ast_accept_visitor(body, visitor);

        v_finish_function();

        v_set_module(0);
    }
}

//---------------------------------------------------------------------
//- compile_unit_var_defn - visitor method
//---------------------------------------------------------------------
//{ v_debug_print_module(2); }
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_unit_var_defn", method_ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "list",    v_ast_generic_list_ptr);
}
{
//  printf("compile_unit_var_defn\n");
//  defer printf("compile_unit_var_defn leave\n");

    ast = v_alloca(v_ast_opaque_base_sptr, 4);
    v_initialize(ast, 4);
    defer v_terminate(ast, 4);

    v_list_get_items(list, 0, ast, 4);

    //-------------------------------------------------------------
    qualif = v_ast_expr_integer_get_number(v_cast(ast+0, v_ast_expr_ptr));

    private = (qualif == qf_private);
    export  = (export_flag  ||  qualif == qf_export)  &&  !private;

    name = v_ast_expr_identifier_get_name(v_cast(ast+1, v_ast_expr_ptr));

    type  = ast + 2;
    value = ast + 3;

    v_set_result_type(INVIOLABLE_TAG);

    v_ast_accept_visitor(type, visitor);

    var_type = *v_alloca(v_type_ptr);

    var_type := v_cast(v_get_result_value(), v_type_ptr);

    if (!v_empty(value))
    {
        //- assert(v_get_module() == 0);

        module = check_defn_module();

        v_set_module(module);

        t = v_type_refptr_get_element_type(var_type);       //- Sic!
        a = v_type_refptr_get_address_space(var_type);      //- Sic!

        v_set_result_type(t);

        v_ast_accept_visitor(value, visitor);

        t = v_get_result_type();

        var_type := v_reference_type(t, a);

        t_ = v_type_get_llvm_type(t);

        value_g = LLVMAddGlobal(module, t_, name);

        if (private)  LLVMSetLinkage(value_g, LLVMPrivateLinkage);

        LLVMSetInitializer(value_g, v_get_result_value());

        v_set_module(0);
    }

    if (export) v_export_symbol_type(name, var_type);
    else        v_add_symbol(name, var_type, 0);

    //-------------------------------------------------------------
    if (decl_list)      //- Importing
    {
        expr = v_alloca(v_ast_opaque_expr_sptr, 2);
        v_initialize(expr, 2);
        defer v_terminate(expr, 2);

        v_ast_make_expr_identifier(expr+0, name);

        v_ast_make_expr_integer(expr+1, export);

        item = v_alloca(v_ast_opaque_expr_list_sptr);
        v_initialize(item);
        defer v_terminate(item);

        v_make_list(item, expr, 2);

        v_list_append(decl_list, decl_list, v_cast(item, v_ast_base_ptr));
    }
}

//---------------------------------------------------------------------
//- compile_unit_val_defn - visitor method
//---------------------------------------------------------------------
//{ v_debug_print_module(2); }
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_unit_val_defn", method_ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "list",    v_ast_generic_list_ptr);
}
{
//  printf("compile_unit_val_defn\n");
//  defer printf("compile_unit_val_defn leave\n");

    ast = v_alloca(v_ast_opaque_base_sptr, 4);
    v_initialize(ast, 4);
    defer v_terminate(ast, 4);

    v_list_get_items(list, 0, ast, 4);

    //-------------------------------------------------------------
    qualif = v_ast_expr_integer_get_number(v_cast(ast+0, v_ast_expr_ptr));

    private = (qualif == qf_private);
    export  = (export_flag  ||  qualif == qf_export)  &&  !private;

    name = v_ast_expr_identifier_get_name(v_cast(ast+1, v_ast_expr_ptr));

    type  = ast + 2;
    value = ast + 3;

    v_set_result_type(INVIOLABLE_TAG);

    if (!v_empty(type))
    {
        v_ast_accept_visitor(type, visitor);

        v_set_result_type(v_cast(v_get_result_value(), v_type_ptr));

    }

    v_ast_accept_visitor(value, visitor);

    t = v_get_result_type();
    v = v_get_result_value();

    if (export)
    {
        if (t == voidc_static_type) v_export_type(name, v_cast(v, v_type_ptr));
        else                        v_export_constant(name, t, v);
    }
    else
    {
        if (t == voidc_static_type) v_add_type(name, v_cast(v, v_type_ptr));
        else                        v_add_constant(name, t, v);
    }

    //-------------------------------------------------------------
    if (const_list)     //- Importing
    {
        expr = v_alloca(v_ast_opaque_expr_sptr, 3);
        v_initialize(expr, 3);
        defer v_terminate(expr, 3);

        v_ast_make_expr_identifier(expr+0, name);

        v_ast_make_expr_integer(expr+1, export);

        if (t != voidc_static_type)
        {
            cv = *v_alloca(intptr_t);

            if (v_type_integer_is_signed(t))
            {
                llv = LLVMConstIntGetSExtValue(v);

                cv := v_cast(llv, intptr_t);
            }
            else
            {
                ullv = LLVMConstIntGetZExtValue(v);

                cv := v_cast(ullv, intptr_t);
            }

            v_ast_make_expr_integer(expr+2, cv);
        }

        item = v_alloca(v_ast_opaque_expr_list_sptr);
        v_initialize(item);
        defer v_terminate(item);

        v_make_list(item, expr, 3);

        v_list_append(const_list, const_list, v_cast(item, v_ast_base_ptr));
    }
}


//---------------------------------------------------------------------
//- compile_defn_list_unit - visitor method
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_defn_list_unit", method_ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",     void_ptr);
    v_add_parameter_name(f, 2, "list",    v_ast_generic_list_ptr);
}
{
//  printf("compile_defn_list_unit\n");
//  defer printf("compile_defn_list_unit leave\n");

    //- Definitions (i.e. "values of things") ---------------------

    saved_module := v_get_module();

    defn_module := saved_module;

    //- Declarations (i.e. "types of things") ---------------------

    symbol_list   = v_alloca(v_ast_opaque_generic_list_sptr);
    constant_list = v_alloca(v_ast_opaque_generic_list_sptr);

    if (v_target_local_ctx_has_parent())
    {
        //- We're importing - need to build a unit

        v_initialize(symbol_list);
        v_initialize(constant_list);

        v_make_list_nil(symbol_list, 0);
        v_make_list_nil(constant_list, 0);

        decl_list  := symbol_list;
        const_list := constant_list;
    }
    else
    {
        //- We'll do "direct declaration" ...

        decl_list  := 0;
        const_list := 0;
    }

    defer
        if (decl_list)
        {
            v_terminate(decl_list);
            v_terminate(const_list);
        }

    v_set_module(0);


    //-------------------------------------------------------------
    lst = v_alloca(v_ast_opaque_generic_list_sptr, 2);
    v_initialize(lst, 2);
    defer v_terminate(lst, 2);

    v_list_get_items(list, 0, v_cast(lst+0, v_ast_base_ptr));

    n = v_list_get_size(lst+0);

    i = *v_alloca(int) := 0;

    loop
    {
        if (i == n) v_break();

        v_list_get_items(lst+0, i, v_cast(lst+1, v_ast_base_ptr));

        v_ast_accept_visitor(v_cast(lst+1, v_ast_base_ptr), visitor);

        ++i;
    }


    //-------------------------------------------------------------
    if (decl_list)      //- Importing
    {
        saved_target = v_target_get_global_ctx();

        v_target_set_global_ctx(v_target_get_voidc_global_ctx());

        saved_voidc_module = v_get_module();

        expr = v_alloca(v_ast_opaque_expr_sptr, 3);
        v_initialize(expr, 3);
        defer v_terminate(expr, 3);

        v_list_get_items(list, 1, v_cast(expr, v_ast_base_ptr), 2);

        line   = v_cast(v_ast_expr_integer_get_number(expr+0), int);
        column = v_cast(v_ast_expr_integer_get_number(expr+1), int);

        voidc_prepare_unit_action(line, column);

        //---------------------------------------------------------
        v_import("level-00/voidc_target.void");
        v_import("level-00/voidc_types.void");

        v_import("llvm-c/Core.void");

        //---------------------------------------------------------
        item = v_alloca(v_ast_opaque_expr_list_sptr);
        v_initialize(item);
        defer v_terminate(item);

        ctx = *v_alloca(voidc_compile_type_ctx_t);

        voidc_compile_type_ctx_initialize(ctx);

        i = *v_alloca(int) := 0;

        nc = v_list_get_size(const_list);

        loop
        {
            if (i == nc)  v_break();

            v_list_get_items(const_list, i, v_cast(item, v_ast_base_ptr));

            v_list_get_items(item, 0, expr+0);

            name = v_ast_expr_identifier_get_name(expr+0);

            type = *v_alloca(v_type_ptr) := v_find_constant_type(name);

            if (type == voidc_static_type)
            {
                type := v_cast(v_find_constant_value(name), v_type_ptr);
            }

            voidc_compile_type_compute_stack_length(type, ctx);

            ++i;
        }

        i := 0;

        nd = v_list_get_size(decl_list);

        loop
        {
            if (i == nd)  v_break();

            v_list_get_items(decl_list, i, v_cast(item, v_ast_base_ptr));

            v_list_get_items(item, 0, expr+0);

            name = v_ast_expr_identifier_get_name(expr+0);

            type = v_find_symbol_type(name);

            voidc_compile_type_compute_stack_length(type, ctx);

            ++i;
        }

        len = voidc_compile_type_ctx_get_stack_length(ctx);

        builder = v_target_get_builder();

        stksv = *v_alloca(LLVMValueRef) := 0;

        ctx_stack = *v_alloca(LLVMValueRef) := 0;

        if (len)
        {
            int_        = v_type_get_llvm_type(int);
            v_type_ptr_ = v_type_get_llvm_type(v_type_ptr);

            len_v = LLVMConstInt(int_, len, 0);

            if (len < 32)       //- ?
            {
                llvm_stacksave_ft_ = v_type_get_llvm_type(v_find_symbol_type("llvm.stacksave"));
                llvm_stacksave_f = v_obtain_function("llvm.stacksave");

                stksv := LLVMBuildCall2(builder, llvm_stacksave_ft_, llvm_stacksave_f, 0, 0, "stksv");

                ctx_stack := LLVMBuildArrayAlloca(builder, v_type_ptr_, len_v, "stk");
            }
            else
            {
                ctx_stack := LLVMBuildArrayMalloc(builder, v_type_ptr_, len_v, "stk");
            }

            voidc_compile_type_ctx_set_stack(ctx, ctx_stack);
        }

        voidc_compile_type_ctx_reset(ctx);      //- Sic!

        val = v_alloca(LLVMValueRef, 6);

        llvm_const_int_ft_ = v_type_get_llvm_type(v_find_symbol_type("LLVMConstInt"));
        llvm_const_int_f   = v_obtain_function("LLVMConstInt");

        get_llvm_type_ft_ = v_type_get_llvm_type(v_find_symbol_type("v_type_get_llvm_type"));
        get_llvm_type_f   = v_obtain_function("v_type_get_llvm_type");

        long_long_ = v_type_get_llvm_type(long_long);

        int_ = v_type_get_llvm_type(int);

        true_ = LLVMConstInt(int_, true, false);

        export_const_ft_ = v_type_get_llvm_type(v_find_symbol_type("v_export_constant"));
        export_const_f   = v_obtain_function("v_export_constant");

        add_const_ft_ = v_type_get_llvm_type(v_find_symbol_type("v_add_constant"));
        add_const_f   = v_obtain_function("v_add_constant");

        export_type_ft_ = v_type_get_llvm_type(v_find_symbol_type("v_export_type"));
        export_type_f   = v_obtain_function("v_export_type");

        add_type_ft_ = v_type_get_llvm_type(v_find_symbol_type("v_add_type"));
        add_type_f   = v_obtain_function("v_add_type");

        i := 0;

        loop
        {
            if (i == nc)  v_break();

            v_list_get_items(const_list, i, v_cast(item, v_ast_base_ptr));

            v_list_get_items(item, 0, expr, 3);

            name = v_ast_expr_identifier_get_name(expr+0);

            val[0] := LLVMBuildGlobalStringPtr(builder, name, "name");

            type = *v_alloca(v_type_ptr) := v_find_constant_type(name);

            if (type == voidc_static_type)
            {
                type := v_cast(v_find_constant_value(name), v_type_ptr);
            }

            val[1] := voidc_compile_type(type, ctx);

            export = v_ast_expr_integer_get_number(expr+1);

            if (v_empty(expr+2))        //- Type
            {
                if (export) LLVMBuildCall2(builder, export_type_ft_, export_type_f, val, 2, "");
                else        LLVMBuildCall2(builder, add_type_ft_, add_type_f, val, 2, "");
            }
            else        //- Constant
            {
                val[3] := LLVMBuildCall2(builder, get_llvm_type_ft_, get_llvm_type_f, val+1, 1, "");

                number = v_ast_expr_integer_get_number(expr+2);

                val[4] := LLVMConstInt(long_long_, v_cast(number, long_long), true);

                val[5] := true_;

                val[2] := LLVMBuildCall2(builder, llvm_const_int_ft_, llvm_const_int_f, val+3, 3, "");

                if (export) LLVMBuildCall2(builder, export_const_ft_, export_const_f, val, 3, "");
                else        LLVMBuildCall2(builder, add_const_ft_, add_const_f, val, 3, "");
            }

            ++i;
        }

        export_sym_ft_ = v_type_get_llvm_type(v_find_symbol_type("v_export_symbol"));
        export_sym_f   = v_obtain_function("v_export_symbol");

        add_sym_ft_ = v_type_get_llvm_type(v_find_symbol_type("v_add_symbol"));
        add_sym_f   = v_obtain_function("v_add_symbol");

        val[2] := LLVMConstNull(v_type_get_llvm_type(void_ptr));

        i := 0;

        loop
        {
            if (i == nd)  v_break();

            v_list_get_items(decl_list, i, v_cast(item, v_ast_base_ptr));

            v_list_get_items(item, 0, expr, 2);

            name = v_ast_expr_identifier_get_name(expr+0);

            val[0] := LLVMBuildGlobalStringPtr(builder, name, "name");

            type = v_find_symbol_type(name);

            val[1] := voidc_compile_type(type, ctx);

            export = v_ast_expr_integer_get_number(expr+1);

            if (export) LLVMBuildCall2(builder, export_sym_ft_, export_sym_f, val, 3, "");
            else        LLVMBuildCall2(builder, add_sym_ft_, add_sym_f, val, 3, "");

            ++i;
        }

        voidc_compile_type_ctx_reset(ctx);

        if (stksv)
        {
            llvm_stackrestore_ft_ = v_type_get_llvm_type(v_find_symbol_type("llvm.stackrestore"));
            llvm_stackrestore_f   = v_obtain_function("llvm.stackrestore");

            LLVMBuildCall2(builder, llvm_stackrestore_ft_, llvm_stackrestore_f, &stksv, 1, "");
        }
        else if (ctx_stack)
        {
            LLVMBuildFree(builder, ctx_stack);
        }


        //---------------------------------------------------------
        if (defn_module  &&  !saved_module)
        {
            voidc_prepare_module_for_jit(defn_module);

            voidc_compile_load_module_to_jit(defn_module, true);    //- local?  (TODO)

            LLVMDisposeModule(defn_module);
        }

        voidc_finish_unit_action();

        v_set_module(saved_voidc_module);

        v_target_set_global_ctx(saved_target);
    }
    else    //- "direct declarations"
    {
        voidc_flush_unit_symbols();         //- WTF?

        if (defn_module  &&  !saved_module)
        {
            //- voidc_guard_target(...);

            voidc_prepare_module_for_jit(defn_module);

            voidc_add_local_module_to_jit(defn_module);             //- local?  (TODO)

            LLVMDisposeModule(defn_module);
        }
    }


    //-------------------------------------------------------------
    v_set_module(saved_module);
}


//---------------------------------------------------------------------
//- op_prefix_const/volatile - compiler intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_op_prefix_cv", voidc_intrinsic_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "visitor",  voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",      void_ptr);
    v_add_parameter_name(f, 2, "arg_list", v_ast_expr_list_ptr);
}
{
//  printf("compile_op_prefix_cv\n");

    ast = v_alloca(v_ast_opaque_expr_sptr);
    v_initialize(ast);
    defer v_terminate(ast);

    v_list_get_items(arg_list, 1, ast);

    //-----------------------------------------------------------------
    //- Just "ignore" it...
    //-----------------------------------------------------------------

    v_ast_accept_visitor(v_cast(ast, v_ast_base_ptr), visitor);
}


//---------------------------------------------------------------------
//- op_infix_to - compiler intrinsic (types only(!))
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_op_infix_to", voidc_intrinsic_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "visitor",  voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",      void_ptr);
    v_add_parameter_name(f, 2, "arg_list", v_ast_expr_list_ptr);
}
{
//  printf("compile_op_infix_to\n");
//  defer printf("compile_op_infix_to leave\n");

    ast = v_alloca(v_ast_opaque_expr_sptr, 2);
    v_initialize(ast, 2);
    defer v_terminate(ast, 2);

    v_list_get_items(arg_list, 1, ast, 2);


    args = v_cast(ast+0, v_ast_expr_list_ptr);

    v_ast_expr_call_get_arg_list(v_cast(ast+0, v_ast_expr_ptr), args);

    v_list_get_items(args, 1, v_cast(ast+0, v_ast_expr_ptr));

    args = v_cast(ast+0, v_ast_generic_list_ptr);


    argtypes = *v_alloca(* v_type_ptr) := 0;
    defer if (argtypes) v_free(argtypes);

    is_vararg = *v_alloca(bool) := false;

    count = *v_alloca(int) := v_list_get_size(args);

    if (count)
    {
        argtypes := v_malloc(v_type_ptr, count);

        item = v_alloca(v_ast_opaque_base_sptr);
        v_initialize(item);
        defer v_terminate(item);

        i = *v_alloca(int) := 0;

        loop
        {
            if (i >= count) v_break();

            v_list_get_items(args, i, item);

            v_list_get_items(v_cast(item, v_ast_expr_list_ptr), 1, v_cast(item, v_ast_expr_ptr));

            if (v_empty(item))
            {
                is_vararg := true;

                count := i;     //- ?

                v_break();
            }

            v_set_result_type(INVIOLABLE_TAG);

            v_ast_accept_visitor(item, visitor);

            argtypes[i] := v_cast(v_get_result_value(), v_type_ptr);

            ++i;
        }
    }

    v_set_result_type(INVIOLABLE_TAG);

    v_ast_accept_visitor(v_cast(ast+1, v_ast_base_ptr), visitor);

    rtyp = v_cast(v_get_result_value(), v_type_ptr);

    ft = v_function_type(rtyp, argtypes, count, is_vararg);

    v_set_result_type(voidc_static_type);
    v_set_result_value(v_cast(ft, LLVMValueRef));
}


//---------------------------------------------------------------------
//- Set "export_flag"
//---------------------------------------------------------------------
{
    typ = *v_alloca(v_type_ptr) := bool;

    ft = v_function_type(void, &typ, 1, false);

    //-----------------------------------------------------------------
    f = v_function_hack("v_set_export_flag", ft);

    v_add_parameter_name(f, 0, "flag", bool);
}
{
    export_flag := flag;
}


//---------------------------------------------------------------------
//- v_undef intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("v_undef_intrinsic", voidc_intrinsic_t);

    v_add_parameter_name(f, 0, "visitor",  voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "aux",      void_ptr);
    v_add_parameter_name(f, 2, "arg_list", v_ast_expr_list_ptr);
}
{
    arg = v_alloca(v_ast_opaque_expr_sptr);
    v_initialize(arg);
    defer v_terminate(arg);

    t = *v_alloca(v_type_ptr) := v_get_result_type();

    if (v_list_get_size(arg_list))
    {
        v_list_get_items(arg_list, 0, arg);

        v_set_result_type(INVIOLABLE_TAG);

        v_ast_accept_visitor(v_cast(arg, v_ast_base_ptr), visitor);

        t := v_cast(v_get_result_value(), v_type_ptr);

        v_set_result_type(t);
    }

    v = LLVMGetUndef(v_type_get_llvm_type(t));

//  v_set_result_type(t);
    v_set_result_value(v);
}


//---------------------------------------------------------------------
//- Enable definitions compiler
//---------------------------------------------------------------------
{
    ft = v_function_type(void, 0, 0, false);

    //-----------------------------------------------------------------
    v_function_hack("voidc_enable_definitions_compiler", ft);
}
{
    v_return_if(voidc_visitor_get_void_method(voidc_compiler, unit_fun_defn_q, 0));

//    v_import("voidc_target.void");              //- WTF ?!?!?!?
//    v_import("voidc_types.void");               //- WTF ?!?!?!?
//    v_import("llvm-c/Core.void");               //- WTF ?!?!?!?

    voidc_enable_expression_compiler();         //- Sic!


    //-------------------------------------------------------------
    saved_ctx = v_malloc(convert_to_type_ctx_t);

    saved_ctx_fun = v_getelementptr(saved_ctx, 0, 0);
    saved_ctx_ctx = v_getelementptr(saved_ctx, 0, 1);

    v_store(v_get_convert_to_type(saved_ctx_ctx), saved_ctx_fun);

    v_set_convert_to_type(convert_to_type, saved_ctx);

    v_add_local_cleaner(v_cast(free, cleaner_ft_ptr), saved_ctx);


    //-------------------------------------------------------------
    vis = voidc_compiler;

    voidc_visitor_set_void_method(vis, vis, br_item_list_q,   compile_br_item_list,   0);
    voidc_visitor_set_void_method(vis, vis, unit_fun_defn_q,  compile_unit_fun_defn,  0);
    voidc_visitor_set_void_method(vis, vis, unit_var_defn_q,  compile_unit_var_defn,  0);
    voidc_visitor_set_void_method(vis, vis, unit_val_defn_q,  compile_unit_val_defn,  0);
    voidc_visitor_set_void_method(vis, vis, defn_list_unit_q, compile_defn_list_unit, 0);

    voidc_visitor_set_intrinsic(vis, vis, "v.op_infix_to",        compile_op_infix_to,  0);
    voidc_visitor_set_intrinsic(vis, vis, "v.op_prefix_const",    compile_op_prefix_cv, 0);
    voidc_visitor_set_intrinsic(vis, vis, "v.op_prefix_volatile", compile_op_prefix_cv, 0);

    voidc_visitor_set_intrinsic(vis, vis, "v.internal.var_defn", v_internal_var_defn_intrinsic, 0);
    voidc_visitor_set_intrinsic(vis, vis, "v.internal.val_defn", v_internal_val_defn_intrinsic, 0);

    voidc_visitor_set_intrinsic(vis, vis, "v_undef", v_undef_intrinsic, 0);

    //-----------------------------------------------------------------
    typ = *v_alloca(v_type_ptr) := bool;

    ft = v_function_type(void, &typ, 1, false);

    v_add_symbol("v_set_export_flag", ft, 0);
}


//---------------------------------------------------------------------
//- Enable definitions
//---------------------------------------------------------------------
{
    ft = v_function_type(void, 0, 0, false);

    //-----------------------------------------------------------------
    v_function_hack("voidc_enable_definitions", ft);
}
{
    voidc_enable_definitions_compiler();


    v_return_if_not(voidc_has_grammar());
    v_return_if(voidc_grammar_has_parser("unit_fun_defn"));


    voidc_enable_expression();          //- Sic!


    any = v_alloca(v_util_opaque_std_any, 6);
    v_initialize(any, 6);
    defer v_terminate(any, 6);

    any_to       = any + 0;
    any_const    = any + 1;
    any_volatile = any + 2;

    v_std_any_set_pointer(any_to,       op_infix_to);
    v_std_any_set_pointer(any_const,    op_prefix_const);
    v_std_any_set_pointer(any_volatile, op_prefix_volatile);

    any_qf_none    = any + 3;
    any_qf_export  = any + 4;
    any_qf_private = any + 5;

    v_std_any_set_value(any_qf_none,    qf_none);
    v_std_any_set_value(any_qf_export,  qf_export);
    v_std_any_set_value(any_qf_private, qf_private);


    gr0 = v_alloca(v_peg_opaque_grammar_sptr);
    v_initialize(gr0);
    defer v_terminate(gr0);

    v_peg_get_grammar(gr0);

    grammar gr0
    {
    values:
        op_infix_to        = any_to;
        op_prefix_const    = any_const;
        op_prefix_volatile = any_volatile;

        qf_none    = any_qf_none;
        qf_export  = any_qf_export;
        qf_private = any_qf_private;

    actions:
        mk_br_item_list      = mk_br_item_list_grammar_action;
        mk_br_item           = mk_br_item_grammar_action;
        mk_qlf_ident         = mk_qlf_ident_grammar_action;
        mk_unit_fun_defn_hdr = mk_unit_fun_defn_hdr_grammar_action;
        mk_unit_fun_defn     = mk_unit_fun_defn_grammar_action;
        mk_unit_var_defn     = mk_unit_var_defn_grammar_action;
        mk_unit_val_defn     = mk_unit_val_defn_grammar_action;
        mk_unit_defn_list    = mk_unit_defn_list_grammar_action;
        mk_defn_list_unit    = mk_defn_list_unit_grammar_action;

        mk_stmt_var_defn = mk_stmt_var_defn_grammar_action;
        mk_stmt_val_defn = mk_stmt_val_defn_grammar_action;

    parsers:

        prefix += "const"    !ident_cont  { op_prefix_const }
                / "volatile" !ident_cont  { op_prefix_volatile }
                ;


        infix += "->"   { op_infix_to };


        bracketed = '('_ l:br_item_list _')'    { mk_bracketed(op_parentheses, l) }
                  ;

        br_item_list = br_item_list_lr
                     /                          { mk_br_item_list(0, 0) }
                     ;

        br_item_list_lr = l:br_item_list_lr _','_ i:br_item     { mk_br_item_list(l, i) }
                        / i:br_item                             { mk_br_item_list(0, i) }
                        ;

        br_item_list_lr is left-recursive;


        br_item = k:expr _':'_ e:expr           { mk_br_item(k, e) }
                / e:expr                        { mk_br_item(0, e) }
                / "..."                         { mk_br_item(0, 0) }
                ;


        qualif_flag = "export"  !ident_cont _ {qf_export}
                    / "private" !ident_cont _ {qf_private}
                    / {qf_none};

        qlf_ident = q:qualif_flag i:identifier  { mk_qlf_ident(q, i) };


        unit_fun_defn_hdr = qf:qlf_ident _':'_ a:bracketed _"->"_ r:expr    { mk_unit_fun_defn_hdr(qf, a, r) };

        unit_fun_defn = h:unit_fun_defn_hdr _';'                    { mk_unit_fun_defn(h, 0) }
                      / h:unit_fun_defn_hdr _'{'_ l:stmt_list _'}'  { mk_unit_fun_defn(h, l) }
                      ;


        unit_defn_list_lr = l:unit_defn_list_lr _ d:unit_defn   { mk_unit_defn_list(l, d) }
                          / d:unit_defn                         { mk_unit_defn_list(0, d) }
                          ;

        unit_defn_list_lr is left-recursive;


        unit_defn = unit_fun_defn
                  / unit_var_defn
                  / unit_val_defn
                  ;


        unit_var_defn = qi:qlf_ident _':'_ tv: expr _';'                { mk_unit_var_defn(qi, tv) }         //- Sic!!!
                      ;


        unit_val_defn = qi:qlf_ident _':'_ t: expr _'='_ v:expr _';'    { mk_unit_val_defn(qi, t, v) }
                      / qi:qlf_ident _'='_ v:expr _';'                  { mk_unit_val_defn(qi, 0, v) }
                      ;


        unit += _ <l:unit_defn_list_lr>     { mk_defn_list_unit(l, $1s) };


        stmt_defn = stmt_var_defn
                  / stmt_val_defn
                  ;


        stmt_var_defn = i:identifier _':'_ tv: expr _';'                { mk_stmt_var_defn(i, tv) }         //- Sic!!!
                 ;


        stmt_val_defn = i:identifier _':'_ t: expr _'='_ v:expr _';'    { mk_stmt_val_defn(i, t, v) }
                 ;


        stmt += stmt_defn;
    }

    v_peg_set_grammar(gr0);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
{
    module = v_get_module();

    //-----------------------------------------------------------------
//  v_debug_print_module(1);

    voidc_unit_load_module_to_jit(module);
    voidc_add_module_to_jit(module);

    LLVMDisposeModule(module);
    v_set_module(0);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
{
    export_flag := false;

    v_initialize(op_infix_to);
    v_initialize(op_prefix_const);
    v_initialize(op_prefix_volatile);

    op_binary = v_ast_make_operator_binary;
    op_unary  = v_ast_make_operator_unary;

    q = v_quark_from_string;

    op_binary(op_infix_to, q("op_infix_to"), 2000, 1, 0);               //- "Lowest" priority, left-assoc

    op_unary(op_prefix_const,    q("op_prefix_const"),    20000, 0);    //- "Prefix" priority
    op_unary(op_prefix_volatile, q("op_prefix_volatile"), 20000, 0);    //- "Prefix" priority

    v_add_cleaner(voidc_definitions_internal_globals_cleaner, 0);
}


//---------------------------------------------------------------------
{
    v_make_export_symbol("voidc_enable_definitions_compiler");
    v_make_export_symbol("voidc_enable_definitions");
}


