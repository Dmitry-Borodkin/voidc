//---------------------------------------------------------------------
//- Copyright (C) 2020-2024 Dmitry Borodkin <borodkin.dn@gmail.com>
//- SDPX-License-Identifier: LGPL-3.0-or-later
//---------------------------------------------------------------------
{   voidc_guard_target("definitions.void  must be imported into the voidc target only!");

    v_import("level-00");

    v_import("llvm-c/Core.void");
    v_import("llvm-c/BitWriter.void");
    v_import("llvm-c/BitReader.void");

    v_import("function_hack.void");
    v_import("if_then_else.void");
    v_import("block.void");
    v_import("loop.void");
    v_import("grammar.void");
    v_import("memory.void");
    v_import("handlers.void");
    v_import("expression.void");
    v_import("defer.void");
}

{   voidc_enable_statement_if_then_else();
    voidc_enable_statement_block();
    voidc_enable_statement_loop();
    voidc_enable_statement_grammar();
    voidc_enable_expression();
    voidc_enable_statement_defer();
}

{   v_import("compile_type.void");
}

//{ v_import("printf.void"); }


//---------------------------------------------------------------------
{   v_add_type("void_ptr", v_pointer_type(void, 0));
    v_add_type("char_ptr", v_pointer_type(char, 0));

    q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("q_export_symbol_type", q_ref, q("v_export_symbol_type"));
    v_add_symbol("q_export_type",        q_ref, q("v_export_type"));
    v_add_symbol("q_export_constant",    q_ref, q("v_export_constant"));
    v_add_symbol("q_add_symbol",         q_ref, q("v_add_symbol"));
    v_add_symbol("q_add_type",           q_ref, q("v_add_type"));
    v_add_symbol("q_add_constant",       q_ref, q("v_add_constant"));
    v_add_symbol("q_type_get_llvm_type", q_ref, q("v_type_get_llvm_type"));

    v_add_symbol("typ_q",  q_ref, q("typ"));
    v_add_symbol("true_q", q_ref, q("true"));

    v_add_symbol("voidc_compile_type_q", q_ref, q("voidc.compile_type"));

    v_add_symbol("q_internal_var_decl", q_ref, q("v.internal.var_decl"));
    v_add_symbol("q_internal_var_defn", q_ref, q("v.internal.var_defn"));
    v_add_symbol("q_internal_val_defn", q_ref, q("v.internal.val_defn"));

    v_add_symbol("q_cast",   q_ref, q("v_cast"));
    v_add_symbol("q_alloca", q_ref, q("v_alloca"));
    v_add_symbol("q_load",   q_ref, q("v_load"));

    v_add_symbol("LLVMGetNamedGlobal_q", q_ref, q("LLVMGetNamedGlobal"));
    v_add_symbol("LLVMGetInitializer_q", q_ref, q("LLVMGetInitializer"));

    v_add_symbol("voidc_internal_constants_module_helper_q", q_ref, q("voidc_internal_constants_module_helper"));

    v_add_symbol("LLVMDisposeModule_q", q_ref, q("LLVMDisposeModule"));


    v_add_symbol("q_op_infix_assign", q_ref, q("v.op_infix_assign"));

    v_add_symbol("voidc_definitions_context_q", q_ref, q("voidc.definitions_context"));

    v_add_symbol("voidc_incomplete_array_type_tag", q_ref, q("voidc.incomplete_array_type_tag"));
}

{   typ = v_alloca(v_type_ptr, 6);

    typ[0] := void_ptr;
    typ[1] := v_type_ptr;
    typ[2] := LLVMValueRef;
    typ[3] := v_type_ptr;

    ft = v_function_type(LLVMValueRef, typ, 4, false);

    ctx_t = v_handler_type(ft);

    v_add_type("convert_to_type_ft",    ft);
    v_add_type("convert_to_type_ctx_t", ctx_t);

    typ[0] := void_ptr;
    typ[1] := LLVMValueRef;
    typ[2] := intptr_t;
    typ[3] := char_ptr;
    typ[4] := v_type_ptr;
    typ[5] := v_ast_generic_list_ptr;

    ft = v_function_type(void, typ, 6, false);

    ctx_t = v_handler_type(ft);

    v_add_type("v_prepare_function_parameters_ft",    ft);
    v_add_type("v_prepare_function_parameters_ctx_t", ctx_t);
}


//---------------------------------------------------------------------
//- Context ...
//---------------------------------------------------------------------
{   typ = v_alloca(v_type_ptr, 7);

    typ[0] := bool;                                 //- "export_flag"
    typ[1] := LLVMModuleRef;                        //- "saved_module"
    typ[2] := LLVMModuleRef;                        //- "defn_module"
    typ[3] := convert_to_type_ctx_t;                //- "convert_ctx"
    typ[4] := v_ast_stmt_list_ptr;                  //- "stmt_list"
    typ[5] := LLVMModuleRef;                        //- "mod_const"
    typ[6] := v_prepare_function_parameters_ctx_t;  //- "fun_params"

    ctx_type = v_struct_type_named("struct.voidc_definitions_ctx");

    v_type_struct_set_body(ctx_type, typ, 7, false);

    v_add_type("definitions_ctx_t", ctx_type);
}

{   int_ = v_type_get_llvm_type(int);

    v_add_constant("ctx_export_flag",  int, LLVMConstInt(int_, 0, 0));
    v_add_constant("ctx_saved_module", int, LLVMConstInt(int_, 1, 0));
    v_add_constant("ctx_defn_module",  int, LLVMConstInt(int_, 2, 0));
    v_add_constant("ctx_convert_ctx",  int, LLVMConstInt(int_, 3, 0));
    v_add_constant("ctx_stmt_list",    int, LLVMConstInt(int_, 4, 0));
    v_add_constant("ctx_mod_const",    int, LLVMConstInt(int_, 5, 0));
    v_add_constant("ctx_fun_params",   int, LLVMConstInt(int_, 6, 0));

    //-----------------------------------------------------------------
    voidc_skip_unit_save(1);
}


//---------------------------------------------------------------------
{   typ = v_alloca(v_type_ptr, 2);

    typ[0] := char_ptr;
    typ[1] := char_ptr;

    ft = v_function_type(int, typ, 2, true);
    v_add_symbol("sprintf", ft, 0);

    typ[0] := void_ptr;

    ft = v_function_type(void, typ, 1, false);
    v_add_symbol("free", ft, 0);

    ft = v_function_type(void, 0, 0, false);
    v_add_symbol("abort", ft, 0);

    //-----------------------------------------------------------------
    voidc_skip_unit_save(1);
}


//---------------------------------------------------------------------
//- Some utility...
//---------------------------------------------------------------------
{   typ = v_alloca(v_type_ptr, 2);

    typ[0] := char_ptr;
    typ[1] := v_type_ptr;

    ft = v_function_type(LLVMValueRef, typ, 2, false);

    //-----------------------------------------------------------------
    f = v_function_hack("v_make_global", ft);

    v_add_parameter_name(f, 0, "name", char_ptr);
    v_add_parameter_name(f, 1, "type", v_type_ptr);
}
{
    v_add_symbol(name, type, 0);

    if (!voidc_has_grammar())   v_return(0);

    t = *v_alloca(v_type_ptr);

    if (v_type_is_reference(type))  t := v_type_refptr_get_element_type(type);
    else                            t := type;

    t_ = v_type_get_llvm_type(t);

    value = LLVMAddGlobal(v_get_module(), t_, name);

    LLVMSetInitializer(value, LLVMGetUndef(t_));

    v_return(value);
}


//=====================================================================
{   voidc_unit_begin_module("voidc_definitions_internal_module"); }


//---------------------------------------------------------------------
//- Add "definitions context"...
//---------------------------------------------------------------------
{
    ctx_ptr = v_pointer_type(definitions_ctx_t, 0);

    typ = *v_alloca(v_type_ptr) := ctx_ptr;

    ft = v_function_type(void, &typ, 1, false);

    //-----------------------------------------------------------------
    f = v_function_hack("add_definitions_context", ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ctx", ctx_ptr);
}
{
    any = v_alloca(v_std_any_t);
    v_initialize(any);
    defer v_terminate(any);

    v_std_any_set_value(any, v_cast(ctx, intptr_t));

    v_add_property_q(voidc_definitions_context_q, any);
}

//---------------------------------------------------------------------
//- Get "definitions context"...
//---------------------------------------------------------------------
{
    ctx_ptr = v_pointer_type(definitions_ctx_t, 0);

    ft = v_function_type(ctx_ptr, 0, 0, false);

    //-----------------------------------------------------------------
    f = v_function_hack("get_definitions_context", ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);
}
{
    any = v_get_property_q(voidc_definitions_context_q);

    ctx = v_cast(v_std_any_get_value(intptr_t, any), *definitions_ctx_t);

    v_return(ctx);
}

//---------------------------------------------------------------------
//- Get "definitions context" "stmt_list" ...                       ???
//---------------------------------------------------------------------
{
    rt = v_reference_type(v_ast_stmt_list_ptr, 0);

    ft = v_function_type(rt, 0, 0, false);

    //-----------------------------------------------------------------
    f = v_function_hack("voidc_definitions_context_get_stmt_list", ft);
}
{
    ctx = *get_definitions_context();

    v_return(ctx[ctx_stmt_list]);
}

//---------------------------------------------------------------------
//- Get "definitions context" "mod_const" ...                       ???
//---------------------------------------------------------------------
{
    rt = v_reference_type(LLVMModuleRef, 0);

    ft = v_function_type(rt, 0, 0, false);

    //-----------------------------------------------------------------
    f = v_function_hack("voidc_definitions_context_get_mod_const", ft);
}
{
    ctx = *get_definitions_context();

    v_return(ctx[ctx_mod_const]);
}

//---------------------------------------------------------------------
//- Get "definitions context" "fun_params" ...                      ???
//---------------------------------------------------------------------
{
    rt = v_reference_type(v_prepare_function_parameters_ctx_t, 0);

    ft = v_function_type(rt, 0, 0, false);

    //-----------------------------------------------------------------
    f = v_function_hack("voidc_definitions_context_get_fun_params", ft);
}
{
    ctx = *get_definitions_context();

    v_return(ctx[ctx_fun_params]);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
{
    v_make_global("op_infix_tildeto",   v_ast_expr_t);
    v_make_global("op_prefix_const",    v_ast_expr_t);
    v_make_global("op_prefix_volatile", v_ast_expr_t);

    intptr_t_ = v_type_get_llvm_type(intptr_t);

    v_add_constant("qf_none",    intptr_t, LLVMConstInt(intptr_t_, 0, 0));
    v_add_constant("qf_export",  intptr_t, LLVMConstInt(intptr_t_, 1, 0));
    v_add_constant("qf_private", intptr_t, LLVMConstInt(intptr_t_, 2, 0));


    typ = v_alloca(v_type_ptr);

    typ[0] := void_ptr;

    ft = v_function_type(void, typ, 1, false);

    //-----------------------------------------------------------------
    f = v_function_hack("voidc_definitions_internal_globals_cleaner", ft);
}
{
//  printf("voidc_definitions_internal_globals_cleaner\n");

    v_terminate(op_infix_tildeto);
    v_terminate(op_prefix_const);
    v_terminate(op_prefix_volatile);
}

//---------------------------------------------------------------------
{
    q_ref = v_reference_type(v_quark_t, 0);

    q = v_quark_ptr_from_string;

    v_add_symbol("br_item_list_q",   q_ref, q("br_item_list"));
    v_add_symbol("unit_fun_defn_q",  q_ref, q("unit_fun_defn"));
    v_add_symbol("unit_var_defn_q",  q_ref, q("unit_var_defn"));
    v_add_symbol("unit_val_defn_q",  q_ref, q("unit_val_defn"));
    v_add_symbol("defn_list_unit_q", q_ref, q("defn_list_unit"));

    v_add_symbol("mod_const_q", q_ref, q("voidc.constants_module"));
}


//---------------------------------------------------------------------
//- mk_br_item - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_br_item_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_br_item_grammar_action\n");

    key  = v_std_any_get_pointer(v_ast_expr_t, any+0);
    type = v_std_any_get_pointer(v_ast_expr_t, any+1);

    expr = v_alloca(v_ast_expr_t, 2);
    v_initialize(expr, 2);
    defer v_terminate(expr, 2);

    if (key)    v_copy(expr+0, key);
    if (type)   v_copy(expr+1, type);

    lst = v_alloca(v_ast_expr_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, expr, 2);

    v_std_any_set_pointer(ret, lst);
}

//---------------------------------------------------------------------
//- mk_br_item_list - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_br_item_list_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_br_item_list_grammar_action\n");

    list = v_std_any_get_pointer(v_ast_expr_t, any+0);
    list = v_cast(list, v_ast_generic_list_ptr);                    //- Sic!!!

    item = v_std_any_get_pointer(v_ast_expr_list_t, any+1);

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    if (list)   v_list_append(lst, list, v_cast(item, v_ast_base_ptr));
    else
    {
        if (item)   v_make_list(lst, br_item_list_q, v_cast(item, v_ast_base_ptr), 1);
        else        v_make_list_nil(lst, br_item_list_q);
    }

    v_std_any_set_pointer(ret, v_cast(lst, v_ast_expr_ptr));        //- Sic!!!
}


//---------------------------------------------------------------------
//- mk_qualif_flags - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_qualif_flags_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_qlf_ident_grammar_action\n");

    flags = v_std_any_get_value(intptr_t, any+0);
    flag  = v_std_any_get_value(intptr_t, any+1);

    v_std_any_set_value(ret, flags|flag);
}


//---------------------------------------------------------------------
//- mk_qlf_ident - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_qlf_ident_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_qlf_ident_grammar_action\n");

    qualif = v_std_any_get_value(intptr_t, any+0);

    name = v_std_any_get_pointer(v_std_string_t, any+1);

    ast = v_alloca(v_ast_base_t, 2);
    v_initialize(ast, 2);
    defer v_terminate(ast, 2);

    v_ast_make_expr_integer(v_cast(&ast[0], v_ast_expr_ptr), qualif);

    v_ast_make_expr_identifier(v_cast(&ast[1], v_ast_expr_ptr), v_std_string_get(name));

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, 0, ast, 2);

    v_std_any_set_pointer(ret, lst);
}


//---------------------------------------------------------------------
//- mk_unit_fun_defn_hdr - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_unit_fun_defn_hdr_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_unit_fun_defn_hdr_grammar_action\n");

    q_id = v_std_any_get_pointer(v_ast_generic_list_t, any+0);

    args = v_std_any_get_pointer(v_ast_expr_t, any+1);
    type = v_std_any_get_pointer(v_ast_expr_t, any+2);

    ast = v_alloca(v_ast_base_t, 4);
    v_initialize(ast, 4);
    defer v_terminate(ast, 4);

    v_copy(ast+0, v_list_get_item(q_id, 0));
    v_copy(ast+1, v_list_get_item(q_id, 1));

    v_copy(ast+2, v_cast(args, v_ast_base_ptr));
    v_copy(ast+3, v_cast(type, v_ast_base_ptr));

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, unit_fun_defn_q, ast, 4);

    v_std_any_set_pointer(ret, lst);
}

//---------------------------------------------------------------------
//- mk_unit_fun_defn - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_unit_fun_defn_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_unit_fun_defn_grammar_action\n");

    head = v_std_any_get_pointer(v_ast_generic_list_t, any+0);
    body = v_std_any_get_pointer(v_ast_stmt_list_t,    any+1);

    ast = v_alloca(v_ast_base_t);
    v_initialize(ast);
    defer v_terminate(ast);

    if (body)   v_copy(ast, v_cast(body, v_ast_base_ptr));

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_list_append(lst, head, ast, 1);

    v_std_any_set_pointer(ret, v_cast(lst, v_ast_base_ptr));        //- Sic!!!
}

//---------------------------------------------------------------------
//- mk_unit_var_defn - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_unit_var_defn_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_unit_var_defn_grammar_action\n");
//  defer printf("mk_unit_var_defn_grammar_action leave\n");

    q_id = v_std_any_get_pointer(v_ast_generic_list_t, any+0);

    expr = v_std_any_get_pointer(v_ast_expr_t, any+1);

    ast = v_alloca(v_ast_base_t, 4);
    v_initialize(ast, 4);
    defer v_terminate(ast, 4);

    type  = v_cast(ast+2, v_ast_expr_ptr);
    value = v_cast(ast+3, v_ast_expr_ptr);

    v_copy(type, expr);

    block
    {
        tag = v_ast_base_get_visitor_method_tag(ast+2);

        if (tag != v_ast_expr_call_visitor_method_tag) v_break();

        ast2 = v_cast(ast+2, v_ast_expr_ptr);

        efun = v_ast_expr_call_get_fun_expr(ast2);

        tag = v_ast_base_get_visitor_method_tag(v_cast(efun, v_ast_base_ptr));

        if (tag != v_ast_expr_identifier_visitor_method_tag) v_break();

        qname = v_ast_expr_identifier_get_name_q(efun);

        if (qname != q_op_infix_assign)  v_break();

        arg_list = v_ast_expr_call_get_arg_list(ast2);

        v_copy(ast2+0, v_list_get_item(arg_list, 1));
        v_copy(ast2+1, v_list_get_item(arg_list, 2));
    }

    v_copy(ast+0, v_list_get_item(q_id, 0));
    v_copy(ast+1, v_list_get_item(q_id, 1));

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, unit_var_defn_q, ast, 4);

    v_std_any_set_pointer(ret, v_cast(lst, v_ast_base_ptr));        //- Sic!!!
}

//---------------------------------------------------------------------
//- mk_unit_val_defn - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_unit_val_defn_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_unit_val_defn_grammar_action\n");

    q_id = v_std_any_get_pointer(v_ast_generic_list_t, any+0);

    type  = v_std_any_get_pointer(v_ast_expr_t, any+1);
    value = v_std_any_get_pointer(v_ast_expr_t, any+2);

    ast = v_alloca(v_ast_base_t, 4);
    v_initialize(ast, 4);
    defer v_terminate(ast, 4);

    v_copy(ast+0, v_list_get_item(q_id, 0));
    v_copy(ast+1, v_list_get_item(q_id, 1));

    if (type)   v_copy(ast+2, v_cast(type, v_ast_base_ptr));

    v_copy(ast+3, v_cast(value, v_ast_base_ptr));

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, unit_val_defn_q, ast, 4);

    v_std_any_set_pointer(ret, v_cast(lst, v_ast_base_ptr));        //- Sic!!!
}


//---------------------------------------------------------------------
//- mk_unit_defn_list - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_unit_defn_list_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_unit_defn_list_grammar_action\n");

    list = v_std_any_get_pointer(v_ast_generic_list_t, any+0);
    item = v_std_any_get_pointer(v_ast_base_t,         any+1);

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    if (list)   v_list_append(lst, list, item);
    else
    {
        v_make_list(lst, 0, item, 1);
    }

    v_std_any_set_pointer(ret, lst);
}

//---------------------------------------------------------------------
//- mk_defn_list_unit - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_defn_list_unit_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_defn_list_unit_grammar_action\n");

    list = v_std_any_get_pointer(v_ast_generic_list_t, any+0);

    pos = v_std_any_get_value(size_t, any+1);

    line   = *v_alloca(size_t) := 0;
    column = *v_alloca(size_t) := 0;

    v_peg_get_line_column(pos, line, column);

    ast = v_alloca(v_ast_base_t, 3);
    v_initialize(ast, 3);
    defer v_terminate(ast, 3);

    v_copy(&ast[0], v_cast(list, v_ast_base_ptr));

    v_ast_make_expr_integer(v_cast(&ast[1], v_ast_expr_ptr), v_cast(line+1,   intptr_t));
    v_ast_make_expr_integer(v_cast(&ast[2], v_ast_expr_ptr), v_cast(column+1, intptr_t));

    lst = v_alloca(v_ast_generic_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, defn_list_unit_q, ast, 3);

    v_std_any_set_pointer(ret, v_cast(lst, v_ast_unit_ptr));        //- Sic!!!
}


//---------------------------------------------------------------------
//- mk_stmt_var_defn - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_stmt_var_defn_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_stmt_var_defn_grammar_action\n");

    name = v_std_any_get_pointer(v_std_string_t, any+0);

    expr = v_std_any_get_pointer(v_ast_expr_t, any+1);

    ast = v_alloca(v_ast_base_t, 2);
    v_initialize(ast, 2);
    defer v_terminate(ast, 2);

    type  = v_cast(ast+0, v_ast_expr_ptr);
    value = v_cast(ast+1, v_ast_expr_ptr);

    v_copy(type, expr);

    block
    {
        tag = v_ast_base_get_visitor_method_tag(ast+0);

        if (tag != v_ast_expr_call_visitor_method_tag) v_break();

        ast0 = v_cast(ast+0, v_ast_expr_ptr);

        efun = v_ast_expr_call_get_fun_expr(ast0);

        tag = v_ast_base_get_visitor_method_tag(v_cast(efun, v_ast_base_ptr));

        if (tag != v_ast_expr_identifier_visitor_method_tag) v_break();

        qopnm = v_ast_expr_identifier_get_name_q(efun);

        if (qopnm != q_op_infix_assign)  v_break();

        arg_list = v_ast_expr_call_get_arg_list(ast0);

        v_copy(ast0+0, v_list_get_item(arg_list, 1));
        v_copy(ast0+1, v_list_get_item(arg_list, 2));
    }

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);

    lst = v_alloca(v_ast_expr_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    etmp = v_alloca(v_ast_expr_t);
    v_initialize(etmp);
    defer v_terminate(etmp);

    if (v_empty(value))     //- Declaration
    {
        v_ast_make_expr_identifier(etmp, v_std_string_get(name));

        v_make_list(lst, etmp, 1);

        v_list_append(lst, lst, type, 1);

        v_ast_make_expr_identifier_q(etmp, q_internal_var_decl);

        v_ast_make_expr_call(etmp, etmp, lst);

        v_ast_make_stmt_q(stmt, 0, etmp);
    }
    else                    //- Definition
    {
        v_make_list(lst, type, 2);

        v_ast_make_expr_identifier_q(etmp, q_internal_var_defn);

        v_ast_make_expr_call(etmp, etmp, lst);

        v_ast_make_stmt(stmt, v_std_string_get(name), etmp);
    }

    v_std_any_set_pointer(ret, stmt);
}

//---------------------------------------------------------------------
//- mk_stmt_val_defn - grammar action
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("mk_stmt_val_defn_grammar_action", v_peg_grammar_action_fun_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ret",       v_std_any_ptr);
    v_add_parameter_name(f, 1, "aux",       void_ptr);
    v_add_parameter_name(f, 2, "any",       v_std_any_ptr);
    v_add_parameter_name(f, 3, "any_count", size_t);
}
{
//  printf("mk_stmt_val_defn_grammar_action\n");

    name = v_std_any_get_pointer(v_std_string_t, any+0);

    type = v_std_any_get_pointer(v_ast_expr_t, any+1);
    expr = v_std_any_get_pointer(v_ast_expr_t, any+2);

    lst = v_alloca(v_ast_expr_list_t);
    v_initialize(lst);
    defer v_terminate(lst);

    v_make_list(lst, expr, 1);

    v_list_append(lst, lst, type, 1);

    etmp = v_alloca(v_ast_expr_t);
    v_initialize(etmp);
    defer v_terminate(etmp);

    v_ast_make_expr_identifier_q(etmp, q_internal_val_defn);

    v_ast_make_expr_call(etmp, etmp, lst);

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);

    v_ast_make_stmt(stmt, v_std_string_get(name), etmp);

    v_std_any_set_pointer(ret, stmt);
}


//---------------------------------------------------------------------
//- convert_to_type - utility...
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("convert_to_type", convert_to_type_ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "void_ctx", void_ptr);
    v_add_parameter_name(f, 1, "type",     v_type_ptr);
    v_add_parameter_name(f, 2, "value",    LLVMValueRef);
    v_add_parameter_name(f, 3, "to_type",  v_type_ptr);
}
{
    if (type == to_type)  v_return(value);

    block
    {
        if (!v_type_is_struct(to_type))  v_break();

        typs_0 = v_type_struct_get_element_types(to_type)[0];

        if (!v_type_is_struct(typs_0))  v_break();

        if (v_type_struct_get_name_q(typs_0) != voidc_incomplete_array_type_tag)  v_break();

        v_set_result_type(type);        //- Sic!!!

        v_return(value);
    }

    ctx = v_cast(void_ctx, *convert_to_type_ctx_t);

    v_return( v_handle(ctx, type, value, to_type) );        //- Sic!!!
}


//---------------------------------------------------------------------
//- v.internal.var_decl - compiler intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("v_internal_var_decl_intrinsic", voidc_intrinsic_t);

    v_add_parameter_name(f, 0, "aux",     void_ptr);
    v_add_parameter_name(f, 1, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("v_internal_var_decl_intrinsic\n");
//  defer printf("v_internal_var_decl_intrinsic leave\n");

    call = v_cast(self, v_ast_expr_ptr);

    arg_list = v_ast_expr_call_get_arg_list(call);

    arg0 = v_list_get_item(arg_list, 0);
    arg1 = v_list_get_item(arg_list, 1);

    name = v_ast_expr_identifier_get_name(arg0);                            //- Name

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(v_cast(arg1, v_ast_base_ptr), visitor);            //- Type

    type = *v_alloca(v_type_ptr) := v_cast(v_get_result_value(), v_type_ptr);

    if (v_type_is_pointer(type))
    {
        type := v_type_refptr_get_element_type(type);       //- Sic!    WTF !?!?!?!
    }

    v_add_symbol(name, type, 0);
}

//---------------------------------------------------------------------
//- v.internal.var_defn - compiler intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("v_internal_var_defn_intrinsic", voidc_intrinsic_t);

    v_add_parameter_name(f, 0, "aux",     void_ptr);
    v_add_parameter_name(f, 1, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("v_internal_var_defn_intrinsic\n");
//  defer printf("v_internal_var_defn_intrinsic leave\n");

    call = v_cast(self, v_ast_expr_ptr);

    arg_list = v_ast_expr_call_get_arg_list(call);

    arg0 = v_list_get_item(arg_list, 0);
    arg1 = v_list_get_item(arg_list, 1);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(v_cast(arg0, v_ast_base_ptr), visitor);            //- Type

    var_type = v_cast(v_get_result_value(), v_type_ptr);

    t = v_type_refptr_get_element_type(var_type);       //- Sic!
    a = v_type_refptr_get_address_space(var_type);      //- Sic!

    v_set_result_type(t);
    v_set_result_value(0);

    v_ast_accept_visitor(v_cast(arg1, v_ast_base_ptr), visitor);            //- Value

    t = v_get_result_type();
    v = v_get_result_value();

    builder = v_target_get_builder();

    t_ = v_type_get_llvm_type(t);

    var_value = LLVMBuildAlloca(builder, t_, "");

    LLVMBuildStore(builder, v, var_value);

    v_set_result_type(v_reference_type(t, a));
    v_set_result_value(var_value);
}

//---------------------------------------------------------------------
//- v.internal.val_defn - compiler intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("v_internal_val_defn_intrinsic", voidc_intrinsic_t);

    v_add_parameter_name(f, 0, "aux",     void_ptr);
    v_add_parameter_name(f, 1, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("v_internal_val_defn_intrinsic\n");
//  defer printf("v_internal_val_defn_intrinsic leave\n");

    call = v_cast(self, v_ast_expr_ptr);

    arg_list = v_ast_expr_call_get_arg_list(call);

    arg0 = v_list_get_item(arg_list, 0);
    arg1 = v_list_get_item(arg_list, 1);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(v_cast(arg1, v_ast_base_ptr), visitor);            //- Type

    t = v_cast(v_get_result_value(), v_type_ptr);

    is_ref = v_type_is_reference(t);

    if (is_ref)  v_set_result_type(INVIOLABLE_TAG);
    else         v_set_result_type(t);

    v_set_result_value(0);

    v_ast_accept_visitor(v_cast(arg0, v_ast_base_ptr), visitor);            //- Value

    if (is_ref)
    {
        tr = v_get_result_type();

        if (!v_type_is_reference(tr))  abort();         //- !?!?!?!?!?!

        vr = v_get_result_value();

        v_set_result_type(t);
        v_set_result_value(0);

        v_adopt_result(tr, vr);
    }
}


//---------------------------------------------------------------------
//- compile_br_item_list - visitor method - special cases for '(' _ (expr _ ':')? _ expr _ ')'
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_br_item_list", voidc_visitor_method_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "aux",     void_ptr);
    v_add_parameter_name(f, 1, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("compile_br_item_list\n");
//  defer printf("compile_br_item_list leave\n");

    list = v_cast(self, v_ast_generic_list_ptr);

    lst = v_cast(v_list_get_item(list, 0), v_ast_expr_list_ptr);

    expr = v_alloca(v_ast_expr_t);
    v_initialize(expr);
    defer v_terminate(expr);

    v_copy(expr, v_list_get_item(lst, 0));

    if (!v_empty(expr))
    {
        v_ast_make_expr_identifier_q(expr, q_cast);

        v_ast_make_expr_call(expr, expr, lst);
    }
    else
    {
        v_copy(expr, v_list_get_item(lst, 1));
    }

    v_ast_accept_visitor(v_cast(expr, v_ast_base_ptr), visitor);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
{
    typ = *v_alloca(v_type_ptr) := void_ptr;

    ft = v_function_type(LLVMModuleRef, &typ, 1, false);

    //-----------------------------------------------------------------
    f = v_function_hack("check_defn_module", ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ctx", void_ptr);
}
{
    defn_module = *v_cast(ctx, *LLVMModuleRef);

    if (!defn_module)
    {
        //- voidc_guard_target(...);

        defn_module := LLVMModuleCreateWithName("voidc_definitions_internal_defn_module");
    }

    v_return(defn_module);
}


//---------------------------------------------------------------------
//- v_prepare_function_parameters_default ...
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("v_prepare_function_parameters_default", v_prepare_function_parameters_ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "aux",      void_ptr);
    v_add_parameter_name(f, 1, "fun",      LLVMValueRef);
    v_add_parameter_name(f, 2, "qualif",   intptr_t);
    v_add_parameter_name(f, 3, "fun_name", char_ptr);
    v_add_parameter_name(f, 4, "fun_type", v_type_ptr);
    v_add_parameter_name(f, 5, "fun_args", v_ast_generic_list_ptr);
}
{
    count = v_type_function_get_param_count(fun_type);
    types = v_type_function_get_param_types(fun_type);

    if (count == 0) v_return();

    i = *v_alloca(int) := 0;

    loop
    {
        if (i >= count) v_break();

        item = v_cast(v_list_get_item(fun_args, i), v_ast_generic_list_ptr);

        etmp = v_cast(v_list_get_item(item, 0), v_ast_expr_ptr);

        if (!v_empty(etmp))
        {
            pname = v_ast_expr_identifier_get_name(etmp);

            v_add_parameter_name(fun, i, pname, types[i]);
        }

        ++i;
    }
}

//---------------------------------------------------------------------
//- voidc_compile_unit_fun_defn_helper - ...
//---------------------------------------------------------------------
{
    typ = v_alloca(v_type_ptr, 6);
    typ[0] := voidc_visitor_ptr;
    typ[1] := intptr_t;
    typ[2] := char_ptr;
    typ[3] := v_type_ptr;
    typ[4] := v_ast_generic_list_ptr;
    typ[5] := v_ast_base_ptr;

    ft = v_function_type(void, typ, 6, false);

    //-----------------------------------------------------------------
    f = v_function_hack("voidc_compile_unit_fun_defn_helper", ft);

    v_add_parameter_name(f, 0, "vis",      voidc_visitor_ptr);
    v_add_parameter_name(f, 1, "qualif",   intptr_t);
    v_add_parameter_name(f, 2, "fun_name", char_ptr);
    v_add_parameter_name(f, 3, "fun_type", v_type_ptr);
    v_add_parameter_name(f, 4, "fun_args", v_ast_generic_list_ptr);
    v_add_parameter_name(f, 5, "fun_body", v_ast_base_ptr);
}
{
    def_ctx = *get_definitions_context();

    export_flag = def_ctx[ctx_export_flag];

    stmt_list = def_ctx[ctx_stmt_list];

    //-------------------------------------------------------------
    private = (qualif & qf_private);
    export  = (export_flag  ||  qualif & qf_export)  &&  !private;

    if (export) v_export_symbol_type(fun_name, fun_type);
    else        v_add_symbol(fun_name, fun_type, 0);

    //-------------------------------------------------------------
    if (!v_empty(fun_body))
    {
        //- assert(v_get_module() == 0);

        v_set_module(v_obtain_module());

        f = v_prepare_function(fun_name, fun_type);

        if (private)  LLVMSetLinkage(f, LLVMPrivateLinkage);

        v_handle(&def_ctx[ctx_fun_params], f, qualif, fun_name, fun_type, fun_args);

        v_ast_accept_visitor(fun_body, vis);

        v_finish_function();

        v_set_module(0);
    }

    //-------------------------------------------------------------
    if (!stmt_list)  v_return();


    expr = v_alloca(v_ast_expr_t, 3);
    v_initialize(expr, 3);
    defer v_terminate(expr, 3);

    elst = v_alloca(v_ast_expr_list_t);
    v_initialize(elst);
    defer v_terminate(elst);

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);


    v_ast_make_expr_integer(expr+0, v_cast(fun_type, intptr_t));        //- Sic!!!

    v_make_list(elst, expr+0, 1);

    v_ast_make_expr_identifier_q(expr+0, voidc_compile_type_q);

    v_ast_make_expr_call(expr+1, expr+0, elst);

    v_ast_make_expr_string(expr+0, fun_name);


    if (export)
    {
        v_ast_make_stmt_call(stmt, 0, q_export_symbol_type, expr, 2);
    }
    else
    {
        v_ast_make_expr_integer(expr+2, 0);

        v_ast_make_stmt_call(stmt, 0, q_add_symbol, expr, 3);
    }

    v_list_append(stmt_list, stmt_list, stmt);
}

//---------------------------------------------------------------------
//- compile_unit_fun_defn - visitor method
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_unit_fun_defn", voidc_visitor_method_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "aux",     void_ptr);
    v_add_parameter_name(f, 1, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("compile_unit_fun_defn\n");
//  defer printf("compile_unit_fun_defn leave\n");

    list = v_cast(self, v_ast_generic_list_ptr);

    ast0 = v_list_get_item(list, 0);
    ast1 = v_list_get_item(list, 1);

    //-------------------------------------------------------------
    qualif = v_ast_expr_integer_get_number(v_cast(ast0, v_ast_expr_ptr));

    name = v_ast_expr_identifier_get_name(v_cast(ast1, v_ast_expr_ptr));

    params   = v_list_get_item(list, 2);
    ret_type = v_list_get_item(list, 3);
    body     = v_list_get_item(list, 4);

    //-------------------------------------------------------------
    args = v_ast_expr_call_get_arg_list(v_cast(params, v_ast_expr_ptr));

    args = v_cast(v_list_get_item(args, 1), v_ast_generic_list_ptr);

    //-------------------------------------------------------------
    {   expr = v_alloca(v_ast_expr_t);
        v_initialize(expr);
        defer v_terminate(expr);

        v_ast_make_expr_op_binary(expr, op_infix_tildeto, v_cast(params, v_ast_expr_ptr), v_cast(ret_type, v_ast_expr_ptr));

        v_set_result_type(INVIOLABLE_TAG);
        v_set_result_value(0);

        v_ast_accept_visitor(v_cast(expr, v_ast_base_ptr), visitor);
    }

    fun_type = v_cast(v_get_result_value(), v_type_ptr);

    voidc_compile_unit_fun_defn_helper(visitor, qualif, name, fun_type, args, body);
}

//---------------------------------------------------------------------
//- compile_unit_var_defn - visitor method
//---------------------------------------------------------------------
//{ v_debug_print_module(2); }
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_unit_var_defn", voidc_visitor_method_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "aux",     void_ptr);
    v_add_parameter_name(f, 1, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("compile_unit_var_defn\n");
//  defer printf("compile_unit_var_defn leave\n");

    list = v_cast(self, v_ast_generic_list_ptr);

    ast0 = v_list_get_item(list, 0);
    ast1 = v_list_get_item(list, 1);

    //-------------------------------------------------------------
    def_ctx = *v_cast(aux, *definitions_ctx_t);

    export_flag = def_ctx[ctx_export_flag];

    stmt_list = def_ctx[ctx_stmt_list];

    //-------------------------------------------------------------
    qualif = v_ast_expr_integer_get_number(v_cast(ast0, v_ast_expr_ptr));

    private = (qualif & qf_private);
    export  = (export_flag  ||  qualif & qf_export)  &&  !private;

    name = v_ast_expr_identifier_get_name(v_cast(ast1, v_ast_expr_ptr));

    type  = v_list_get_item(list, 2);
    value = v_list_get_item(list, 3);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(type, visitor);

    var_type = *v_alloca(v_type_ptr);

    var_type := v_cast(v_get_result_value(), v_type_ptr);

    if (!v_empty(value))
    {
        //- assert(v_get_module() == 0);

        v_set_module(v_obtain_module());

        t = v_type_refptr_get_element_type(var_type);       //- Sic!
        a = v_type_refptr_get_address_space(var_type);      //- Sic!

        v_set_result_type(t);
        v_set_result_value(0);

        v_ast_accept_visitor(value, visitor);

        t = v_get_result_type();

        var_type := v_reference_type(t, a);
    }

    if (export) v_export_symbol_type(name, var_type);
    else        v_add_symbol(name, var_type, 0);

    if (!v_empty(value))
    {
        value_g = *v_alloca(LLVMValueRef);

        v_obtain_identifier(name, 0, &value_g);         //- Sic!

        if (private)  LLVMSetLinkage(value_g, LLVMPrivateLinkage);

        LLVMSetInitializer(value_g, v_get_result_value());

        v_set_module(0);
    }

    //-------------------------------------------------------------
    if (!stmt_list)  v_return();


    expr = v_alloca(v_ast_expr_t, 3);
    v_initialize(expr, 3);
    defer v_terminate(expr, 3);

    elst = v_alloca(v_ast_expr_list_t);
    v_initialize(elst);
    defer v_terminate(elst);

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);


    v_ast_make_expr_integer(expr+0, v_cast(var_type, intptr_t));        //- Sic!!!

    v_make_list(elst, expr+0, 1);

    v_ast_make_expr_identifier_q(expr+0, voidc_compile_type_q);

    v_ast_make_expr_call(expr+1, expr+0, elst);

    v_ast_make_expr_string(expr+0, name);


    if (export)
    {
        v_ast_make_stmt_call(stmt, 0, q_export_symbol_type, expr, 2);
    }
    else
    {
        v_ast_make_expr_integer(expr+2, 0);

        v_ast_make_stmt_call(stmt, 0, q_add_symbol, expr, 3);
    }

    v_list_append(stmt_list, stmt_list, stmt);
}

//---------------------------------------------------------------------
//- compile_unit_val_defn - visitor method
//---------------------------------------------------------------------
//{ v_debug_print_module(2); }
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_unit_val_defn", voidc_visitor_method_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "aux",     void_ptr);
    v_add_parameter_name(f, 1, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("compile_unit_val_defn\n");
//  defer printf("compile_unit_val_defn leave\n");

    list = v_cast(self, v_ast_generic_list_ptr);

    ast0 = v_list_get_item(list, 0);
    ast1 = v_list_get_item(list, 1);

    //-------------------------------------------------------------
    def_ctx = *v_cast(aux, *definitions_ctx_t);

    export_flag = def_ctx[ctx_export_flag];

    stmt_list = def_ctx[ctx_stmt_list];
    mod_const = def_ctx[ctx_mod_const];

    //-------------------------------------------------------------
    qualif = v_ast_expr_integer_get_number(v_cast(ast0, v_ast_expr_ptr));

    private = (qualif & qf_private);
    export  = (export_flag  ||  qualif & qf_export)  &&  !private;

    name = v_ast_expr_identifier_get_name(v_cast(ast1, v_ast_expr_ptr));

    type  = v_list_get_item(list, 2);
    value = v_list_get_item(list, 3);

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    if (!v_empty(type))
    {
        v_ast_accept_visitor(type, visitor);

        v_set_result_type(v_cast(v_get_result_value(), v_type_ptr));

        v_set_result_value(0);
    }

    v_ast_accept_visitor(value, visitor);

    t = v_get_result_type();
    v = v_get_result_value();

    if (export)
    {
        if (t == v_static_type_t) v_export_type(name, v_cast(v, v_type_ptr));
        else                      v_export_constant(name, t, v);
    }
    else
    {
        if (t == v_static_type_t) v_add_type(name, v_cast(v, v_type_ptr));
        else                      v_add_constant(name, t, v);
    }

    //-------------------------------------------------------------
    if (!stmt_list)  v_return();


    expr = v_alloca(v_ast_expr_t, 3);
    v_initialize(expr, 3);
    defer v_terminate(expr, 3);

    elst = v_alloca(v_ast_expr_list_t);
    v_initialize(elst);
    defer v_terminate(elst);

    stmt = v_alloca(v_ast_stmt_t);
    v_initialize(stmt);
    defer v_terminate(stmt);


    typ = *v_alloca(*void);

    if (t == v_static_type_t)  typ := v;
    else                       typ := t;

    v_ast_make_expr_integer(expr+0, v_cast(typ, intptr_t));         //- Sic!!!

    v_ast_make_stmt_call(stmt, typ_q, voidc_compile_type_q, expr+0, 1);

    v_list_append(stmt_list, stmt_list, stmt);

    v_ast_make_expr_identifier_q(expr+1, typ_q);

    v_ast_make_expr_string(expr+0, name);


    if (t != v_static_type_t)
    {
        t_ = v_type_get_llvm_type(t);

        if (!mod_const)
        {
            c_ = LLVMGetTypeContext(t_);

            mod_const := LLVMModuleCreateWithNameInContext("voidc_module_for_constants", c_);
        }

        v_ = LLVMAddGlobal(mod_const, t_, name);

        LLVMSetInitializer(v_, v);


        v_ast_make_expr_identifier_q(expr+2, mod_const_q);

        v_make_list(elst, expr+2, 1);

        v_list_append(elst, elst, expr+0, 1);           //- Sic!

        v_ast_make_expr_identifier_q(expr+2, LLVMGetNamedGlobal_q);

        v_ast_make_expr_call(expr+2, expr+2, elst);

        v_make_list(elst, expr+2, 1);

        v_ast_make_expr_identifier_q(expr+2, LLVMGetInitializer_q);

        v_ast_make_expr_call(expr+2, expr+2, elst);
    }


    if (export)
    {
        if (t == v_static_type_t) v_ast_make_stmt_call(stmt, 0, q_export_type,     expr, 2);
        else                      v_ast_make_stmt_call(stmt, 0, q_export_constant, expr, 3);
    }
    else
    {
        if (t == v_static_type_t) v_ast_make_stmt_call(stmt, 0, q_add_type,     expr, 2);
        else                      v_ast_make_stmt_call(stmt, 0, q_add_constant, expr, 3);
    }

    v_list_append(stmt_list, stmt_list, stmt);
}


//---------------------------------------------------------------------
//- voidc.compile_type - compiler intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("voidc_compile_type_intrinsic", voidc_intrinsic_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "aux",  void_ptr);
    v_add_parameter_name(f, 1, "vis",  voidc_visitor_ptr);
    v_add_parameter_name(f, 2, "self", v_ast_base_ptr);
}
{
//  printf("voidc_compile_type_intrinsic\n");
//  defer printf("voidc_compile_type_intrinsic leave\n");

    call = v_cast(self, v_ast_expr_ptr);

    args = v_ast_expr_call_get_arg_list(call);

    ctx = *v_cast(aux, *voidc_compile_type_ctx_t);

    arg = v_list_get_item(args, 0);

    num = v_ast_expr_integer_get_number(arg);

    typ = v_cast(num, v_type_ptr);

    v = voidc_compile_type(typ, ctx);

    v_adopt_result(v_type_ptr, v);
}


//---------------------------------------------------------------------
//- voidc_internal_constants_module_helper ...
//---------------------------------------------------------------------
{
    typ = v_alloca(v_type_ptr, 2);
    typ[0] := char_ptr;
    typ[1] := size_t;

    ft = v_function_type(LLVMModuleRef, typ, 2, false);

    //-----------------------------------------------------------------
    f = v_function_hack("voidc_internal_constants_module_helper", ft);

    v_add_parameter_name(f, 0, "data", char_ptr);
    v_add_parameter_name(f, 1, "size", size_t);
}
{
    membuf = LLVMCreateMemoryBufferWithMemoryRangeCopy(data, size, "constants_module_data");

    mod_const = v_alloca(LLVMModuleRef);

    LLVMParseBitcodeInContext2(v_target_get_llvm_ctx(), membuf, mod_const);

    LLVMDisposeMemoryBuffer(membuf);

    v_return(v_load(mod_const));
}

//---------------------------------------------------------------------
//- compile_defn_list_unit - visitor method
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_defn_list_unit", voidc_visitor_method_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "aux",     void_ptr);
    v_add_parameter_name(f, 1, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("compile_defn_list_unit\n");
//  defer printf("compile_defn_list_unit leave\n");

    {   vis = v_get_compiler();

        if (vis != visitor)
        {
            v_ast_accept_visitor(self, vis);            //- Sic!!!

            v_return();
        }
    }

    //-------------------------------------------------------------
    list = v_cast(self, v_ast_generic_list_ptr);

    //-------------------------------------------------------------
    def_ctx = *v_cast(aux, *definitions_ctx_t);

    saved_module = def_ctx[ctx_saved_module];
    defn_module  = def_ctx[ctx_defn_module];

    stmt_list = def_ctx[ctx_stmt_list];
    mod_const = def_ctx[ctx_mod_const];

    //- Definitions (i.e. "values of things") ---------------------

    saved_module := v_get_module();

    defn_module := saved_module;

    saved_obtain_module_ctx = *v_alloca(*void);
    saved_obtain_module_fun = v_get_obtain_module(&saved_obtain_module_ctx);

    v_set_obtain_module(check_defn_module, &defn_module);

    //- Declarations (i.e. "types of things") ---------------------

    stmt_list := 0;
    mod_const := 0;

    decl_stmt_list = v_alloca(v_ast_stmt_list_t);


    block
    {
        //- "Direct declaration" ?..

        {   gctx = v_target_get_global_ctx();
            vctx = v_target_get_voidc_global_ctx();

            if (gctx != vctx)   v_target_set_global_ctx(vctx);

            is_importing = v_target_local_ctx_has_parent();

            if (gctx != vctx)   v_target_set_global_ctx(gctx);

            if (!is_importing)  v_break();
        }

        //- Importing - need to build a unit

        v_initialize(decl_stmt_list);

        v_make_list_nil(decl_stmt_list);

        stmt_list := decl_stmt_list;
    }

    defer  if (stmt_list)  v_terminate(decl_stmt_list);

    v_set_module(0);


    //-------------------------------------------------------------
    lst0 = v_cast(v_list_get_item(list, 0), v_ast_generic_list_ptr);

    n = v_list_get_size(lst0);

    i = *v_alloca(int) := 0;

    loop
    {
        if (i == n) v_break();

        lst1 = v_cast(v_list_get_item(lst0, i), v_ast_generic_list_ptr);

        v_ast_accept_visitor(v_cast(lst1, v_ast_base_ptr), visitor);

        ++i;
    }


    //-------------------------------------------------------------
    if (stmt_list)      //- Importing
    {
        saved_target = v_target_get_global_ctx();

        v_target_set_global_ctx(v_target_get_voidc_global_ctx());

        saved_voidc_module = v_get_module();

        //---------------------------------------------------------
        v_import("level-00/voidc_target.void");
        v_import("level-00/voidc_types.void");

        v_import("llvm-c/Core.void");

        //---------------------------------------------------------
        expr0 = v_cast(v_list_get_item(list, 1), v_ast_expr_ptr);
        expr1 = v_cast(v_list_get_item(list, 2), v_ast_expr_ptr);

        line   = v_cast(v_ast_expr_integer_get_number(expr0), int);
        column = v_cast(v_ast_expr_integer_get_number(expr1), int);

        voidc_prepare_unit_action(line, column);

        //---------------------------------------------------------
        if (mod_const)
        {
            expr = v_alloca(v_ast_expr_t, 2);
            v_initialize(expr, 2);
            defer v_terminate(expr, 2);

            stmt = v_alloca(v_ast_stmt_t);
            v_initialize(stmt);
            defer v_terminate(stmt);

            m = LLVMWriteBitcodeToMemoryBuffer(mod_const);

            sz = LLVMGetBufferSize(m);

            v_ast_make_expr_string_data(expr+0, LLVMGetBufferStart(m), sz);

            v_ast_make_expr_integer(expr+1, sz);

            LLVMDisposeMemoryBuffer(m);

            v_ast_make_stmt_call(stmt, mod_const_q, voidc_internal_constants_module_helper_q, expr+0, 2);

            v_ast_accept_visitor(v_cast(stmt, v_ast_base_ptr), v_get_compiler());       //- Sic!


            v_ast_make_expr_identifier_q(expr+0, mod_const_q);

            v_ast_make_stmt_call(stmt, 0, LLVMDisposeModule_q, expr+0, 1);

            v_list_append(stmt_list, stmt_list, stmt);                      //- Sic!!!
        }

        //---------------------------------------------------------
        ctx_ptr = v_get_intrinsic_q(voidc_compile_type_q)[1];

        ctx = *v_cast(ctx_ptr, *voidc_compile_type_ctx_t);

        voidc_compile_type_ctx_initialize(ctx);


        int_ = v_type_get_llvm_type(int);

        int_ptr_    = v_type_get_llvm_type(v_pointer_type(int, 0));
        v_type_ptr_ = v_type_get_llvm_type(v_type_ptr);

        builder = v_target_get_builder();

        dummy_len_v = LLVMBuildLoad2(builder, int_, LLVMGetUndef(int_ptr_), "dummy_len");

        ctx_stack = LLVMBuildArrayMalloc(builder, v_type_ptr_, dummy_len_v, "stk");

        voidc_compile_type_ctx_set_stack(ctx, ctx_stack);


        v_ast_accept_visitor(v_cast(stmt_list, v_ast_base_ptr), v_get_compiler());      //- Sic!


        LLVMBuildFree(builder, ctx_stack);


        len = voidc_compile_type_ctx_get_stack_length(ctx);

        voidc_compile_type_ctx_terminate(ctx);

        LLVMReplaceAllUsesWith(dummy_len_v, LLVMConstInt(int_, len, 0));          //- Sic!!!

        LLVMInstructionEraseFromParent(dummy_len_v);


        //---------------------------------------------------------
        if (mod_const)  LLVMDisposeModule(mod_const);

        //---------------------------------------------------------
        if (defn_module  &&  !saved_module)
        {
            v_finish_module(defn_module);

            voidc_prepare_module_for_jit(defn_module);

            voidc_compile_load_module_to_jit(defn_module, true, false);     //- local?  (TODO)

            LLVMDisposeModule(defn_module);
        }

        voidc_finish_unit_action();

        v_set_module(saved_voidc_module);

        v_target_set_global_ctx(saved_target);
    }
    else    //- "direct declarations"
    {
        voidc_flush_unit_symbols();         //- WTF?

        if (defn_module  &&  !saved_module)
        {
            //- voidc_guard_target(...);

            v_finish_module(defn_module);

            voidc_prepare_module_for_jit(defn_module);

            voidc_add_local_module_to_jit(defn_module);             //- local?  (TODO)

            LLVMDisposeModule(defn_module);
        }
    }


    //-------------------------------------------------------------
    v_set_obtain_module(saved_obtain_module_fun, saved_obtain_module_ctx);

    v_set_module(saved_module);
}


//---------------------------------------------------------------------
//- op_prefix_const/volatile - compiler intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_op_prefix_cv", voidc_intrinsic_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "aux",     void_ptr);
    v_add_parameter_name(f, 1, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("compile_op_prefix_cv\n");

    call = v_cast(self, v_ast_expr_ptr);

    arg_list = v_ast_expr_call_get_arg_list(call);

    ast = v_list_get_item(arg_list, 1);

    //-----------------------------------------------------------------
    //- Just "ignore" it...
    //-----------------------------------------------------------------

    v_ast_accept_visitor(v_cast(ast, v_ast_base_ptr), visitor);
}


//---------------------------------------------------------------------
//- op_infix_tildeto - compiler intrinsic (types only(!))
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("compile_op_infix_tildeto", voidc_intrinsic_t);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "aux",     void_ptr);
    v_add_parameter_name(f, 1, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
//  printf("compile_op_infix_tildeto\n");
//  defer printf("compile_op_infix_tildeto leave\n");

    call = v_cast(self, v_ast_expr_ptr);

    arg_list = v_ast_expr_call_get_arg_list(call);

    ast0 = v_list_get_item(arg_list, 1);

    args = v_ast_expr_call_get_arg_list(v_cast(ast0, v_ast_expr_ptr));

    args = v_cast(v_list_get_item(args, 1), v_ast_generic_list_ptr);


    argtypes = *v_alloca(* v_type_ptr) := 0;
    defer if (argtypes) v_free(argtypes);

    is_vararg = *v_alloca(bool) := false;

    count = *v_alloca(size_t) := v_list_get_size(args);

    if (count)
    {
        argtypes := v_malloc(v_type_ptr, count);

        i = *v_alloca(size_t) := 0;

        loop
        {
            if (i >= count) v_break();

            item = v_cast(v_list_get_item(args, i), v_ast_expr_list_ptr);

            item = v_cast(v_list_get_item(item, 1), v_ast_base_ptr);

            if (v_empty(item))
            {
                is_vararg := true;

                count := i;     //- ?

                v_break();
            }

            v_set_result_type(INVIOLABLE_TAG);
            v_set_result_value(0);

            v_ast_accept_visitor(item, visitor);

            argtypes[i] := v_cast(v_get_result_value(), v_type_ptr);

            ++i;
        }
    }

    ast1 = v_list_get_item(arg_list, 2);        //- Sic!

    v_set_result_type(INVIOLABLE_TAG);
    v_set_result_value(0);

    v_ast_accept_visitor(v_cast(ast1, v_ast_base_ptr), visitor);

    rtyp = v_cast(v_get_result_value(), v_type_ptr);

    ft = v_function_type(rtyp, argtypes, v_cast(count, unsigned), is_vararg);

    v_set_result_type(v_static_type_t);
    v_set_result_value(v_cast(ft, LLVMValueRef));
}


//---------------------------------------------------------------------
//- Set "export_flag"
//---------------------------------------------------------------------
{
    typ = *v_alloca(v_type_ptr) := bool;

    ft = v_function_type(void, &typ, 1, false);

    //-----------------------------------------------------------------
    f = v_function_hack("v_set_export_flag", ft);

    v_add_parameter_name(f, 0, "flag", bool);
}
{
    def_ctx = *get_definitions_context();

    export_flag = def_ctx[ctx_export_flag];

    export_flag := flag;
}

//---------------------------------------------------------------------
//- Get "export_flag"
//---------------------------------------------------------------------
{
    ft = v_function_type(bool, 0, 0, false);

    //-----------------------------------------------------------------
    f = v_function_hack("v_get_export_flag", ft);
}
{
    def_ctx = *get_definitions_context();

    export_flag = def_ctx[ctx_export_flag];

    v_return(export_flag);
}


//---------------------------------------------------------------------
//- v_undef intrinsic
//---------------------------------------------------------------------
{
    //-----------------------------------------------------------------
    f = v_function_hack("v_undef_intrinsic", voidc_intrinsic_t);

    v_add_parameter_name(f, 0, "aux",     void_ptr);
    v_add_parameter_name(f, 1, "visitor", voidc_visitor_ptr);
    v_add_parameter_name(f, 2, "self",    v_ast_base_ptr);
}
{
    call = v_cast(self, v_ast_expr_ptr);

    arg_list = v_ast_expr_call_get_arg_list(call);

    t = *v_alloca(v_type_ptr) := v_get_result_type();

    if (v_list_get_size(arg_list))
    {
        arg = v_list_get_item(arg_list, 0);

        v_set_result_type(INVIOLABLE_TAG);
        v_set_result_value(0);

        v_ast_accept_visitor(v_cast(arg, v_ast_base_ptr), visitor);

        t := v_cast(v_get_result_value(), v_type_ptr);

        v_set_result_type(t);
    }

    v = LLVMGetUndef(v_type_get_llvm_type(t));

//  v_set_result_type(t);
    v_set_result_value(v);
}


//---------------------------------------------------------------------
//- Intrinsics table ...
//---------------------------------------------------------------------
{   v_add_symbol("voidc_definitions_intrinsics_table", v_reference_type(v_array_type(void_ptr, 12), 0), 0);
}

{   module = v_get_module();

    intrinsics_table = v_obtain_global("voidc_definitions_intrinsics_table", 0);

    void_ptr_ = v_type_get_llvm_type(void_ptr);

    vp_0 = LLVMConstNull(void_ptr_);

    val = v_alloca(LLVMValueRef, 12);

    val[ 0] := v_obtain_function("compile_op_infix_tildeto",  0);       val[ 1] := vp_0;
    val[ 2] := v_obtain_function("compile_op_prefix_cv",      0);       val[ 3] := vp_0;
    val[ 4] := v_obtain_function("v_internal_var_decl_intrinsic", 0);   val[ 5] := vp_0;
    val[ 6] := v_obtain_function("v_internal_var_defn_intrinsic", 0);   val[ 7] := vp_0;
    val[ 8] := v_obtain_function("v_internal_val_defn_intrinsic", 0);   val[ 9] := vp_0;
    val[10] := v_obtain_function("v_undef_intrinsic", 0);               val[11] := vp_0;

    LLVMSetInitializer(intrinsics_table, LLVMConstArray2(void_ptr_, val, 12));

    //-----------------------------------------------------------------
    typ = v_alloca(v_type_ptr, 3);

    typ[0] := voidc_compile_type_ctx_t;
    typ[1] := void_ptr;
    typ[2] := void_ptr;

    v_add_type("voidc_compile_type_intrinsic_ctx_t", v_struct_type(typ, 3, false));

    //-----------------------------------------------------------------
    voidc_skip_unit_save(1);
}


//---------------------------------------------------------------------
//- Enable definitions compiler
//---------------------------------------------------------------------
{
    ft = v_function_type(void, 0, 0, false);

    //-----------------------------------------------------------------
    v_function_hack("voidc_enable_definitions_compiler", ft);
}
{
    vis = v_get_compiler();

    v_return_if(voidc_visitor_get_void_method(vis, unit_fun_defn_q, 0));

    voidc_enable_expression_compiler();         //- Sic!


    //-------------------------------------------------------------
    def_ctx = *v_malloc(definitions_ctx_t) := 0;

    v_add_local_cleaner(free, &def_ctx);

    //-------------------------------------------------------------
    convert_ctx = def_ctx[ctx_convert_ctx];

    convert_ctx[0] := v_get_convert_to_type(&convert_ctx[1]);

    v_set_convert_to_type(convert_to_type, &convert_ctx);

    //-----------------------------------------------------------------
    fun_params = def_ctx[ctx_fun_params];

    fun_params[0] := v_prepare_function_parameters_default;
    fun_params[1] := 0;

    //-------------------------------------------------------------
    voidc_visitor_set_void_method(vis, vis, br_item_list_q,   compile_br_item_list,   &def_ctx);
    voidc_visitor_set_void_method(vis, vis, unit_fun_defn_q,  compile_unit_fun_defn,  &def_ctx);
    voidc_visitor_set_void_method(vis, vis, unit_var_defn_q,  compile_unit_var_defn,  &def_ctx);
    voidc_visitor_set_void_method(vis, vis, unit_val_defn_q,  compile_unit_val_defn,  &def_ctx);
    voidc_visitor_set_void_method(vis, vis, defn_list_unit_q, compile_defn_list_unit, &def_ctx);

    v_add_intrinsic("v.op_infix_tildeto",   &voidc_definitions_intrinsics_table[0]);
    v_add_intrinsic("v.op_prefix_const",    &voidc_definitions_intrinsics_table[2]);   //- Sic!
    v_add_intrinsic("v.op_prefix_volatile", &voidc_definitions_intrinsics_table[2]);   //- Sic!

    v_add_intrinsic("v.internal.var_decl",  &voidc_definitions_intrinsics_table[4]);
    v_add_intrinsic("v.internal.var_defn",  &voidc_definitions_intrinsics_table[6]);
    v_add_intrinsic("v.internal.val_defn",  &voidc_definitions_intrinsics_table[8]);

    v_add_intrinsic("v_undef",              &voidc_definitions_intrinsics_table[10]);

    //-----------------------------------------------------------------
    add_definitions_context(&def_ctx);


    //-----------------------------------------------------------------
    saved_gctx = v_target_get_global_ctx();
    v_target_set_global_ctx(v_target_get_voidc_global_ctx());

    if (!v_get_intrinsic_q(voidc_compile_type_q))
    {
        comp_type = *v_malloc(voidc_compile_type_intrinsic_ctx_t);

        comp_type[1] := voidc_compile_type_intrinsic;
        comp_type[2] := &comp_type[0];

        v_add_intrinsic_q(voidc_compile_type_q, &comp_type[1]);

        v_add_local_cleaner(free, &comp_type);

        //----------------------------------------------
        typ = *v_alloca(v_type_ptr) := bool;

        ft = v_function_type(void, &typ, 1, false);

        v_add_symbol("v_set_export_flag", ft, 0);

        ft = v_function_type(bool, 0, 0, false);

        v_add_symbol("v_get_export_flag", ft, 0);
    }

    v_target_set_global_ctx(saved_gctx);
}


//---------------------------------------------------------------------
//- Enable definitions
//---------------------------------------------------------------------
{
    ft = v_function_type(void, 0, 0, false);

    //-----------------------------------------------------------------
    v_function_hack("voidc_enable_definitions", ft);
}
{
    voidc_enable_definitions_compiler();


    v_return_if_not(voidc_has_grammar());
    v_return_if(voidc_grammar_has_parser("unit_fun_defn"));


    voidc_enable_expression();          //- Sic!


    any = v_alloca(v_std_any_t, 6);
    v_initialize(any, 6);
    defer v_terminate(any, 6);

    any_tildeto  = any + 0;
    any_const    = any + 1;
    any_volatile = any + 2;

    v_std_any_set_pointer(any_tildeto,  op_infix_tildeto);
    v_std_any_set_pointer(any_const,    op_prefix_const);
    v_std_any_set_pointer(any_volatile, op_prefix_volatile);

    any_qf_none    = any + 3;
    any_qf_export  = any + 4;
    any_qf_private = any + 5;

    v_std_any_set_value(any_qf_none,    qf_none);
    v_std_any_set_value(any_qf_export,  qf_export);
    v_std_any_set_value(any_qf_private, qf_private);


    gr0 = v_alloca(v_peg_grammar_t);
    v_initialize(gr0);
    defer v_terminate(gr0);

    v_peg_get_grammar(gr0);

    grammar gr0
    {
    values:
        op_infix_tildeto   = any_tildeto;
        op_prefix_const    = any_const;
        op_prefix_volatile = any_volatile;

        qf_none    = any_qf_none;
        qf_export  = any_qf_export;
        qf_private = any_qf_private;

    actions:
        mk_br_item_list      = mk_br_item_list_grammar_action;
        mk_br_item           = mk_br_item_grammar_action;
        mk_qualif_flags      = mk_qualif_flags_grammar_action;
        mk_qlf_ident         = mk_qlf_ident_grammar_action;
        mk_unit_fun_defn_hdr = mk_unit_fun_defn_hdr_grammar_action;
        mk_unit_fun_defn     = mk_unit_fun_defn_grammar_action;
        mk_unit_var_defn     = mk_unit_var_defn_grammar_action;
        mk_unit_val_defn     = mk_unit_val_defn_grammar_action;
        mk_unit_defn_list    = mk_unit_defn_list_grammar_action;
        mk_defn_list_unit    = mk_defn_list_unit_grammar_action;

        mk_stmt_var_defn = mk_stmt_var_defn_grammar_action;
        mk_stmt_val_defn = mk_stmt_val_defn_grammar_action;

    parsers:

        prefix += "const"    !ident_cont  { op_prefix_const }
                / "volatile" !ident_cont  { op_prefix_volatile }
                ;


        infix += "~>"   { op_infix_tildeto };


        bracketed = '('_ l:br_item_list _')'    { mk_bracketed(op_parentheses, l) }
                  ;

        br_item_list = br_item_list_lr
                     /                          { mk_br_item_list(0, 0) }
                     ;

        br_item_list_lr = l:br_item_list_lr _','_ i:br_item     { mk_br_item_list(l, i) }
                        / i:br_item                             { mk_br_item_list(0, i) }
                        ;

        br_item_list_lr is left-recursive;


        br_item = k:expr _':'_ e:expr           { mk_br_item(k, e) }
                / e:expr                        { mk_br_item(0, e) }
                / "..."                         { mk_br_item(0, 0) }
                ;


        qualif_flag = "export"  !ident_cont     {qf_export}
                    / "private" !ident_cont     {qf_private}
                    ;

        qualif_flags_lr = qfs:qualif_flags_lr _ qf:qualif_flag      { mk_qualif_flags(qfs, qf) }
                        / qualif_flag
                        ;

        qualif_flags_lr is left-recursive;

        qualif_flags = qualif_flags_lr
                     /                      {qf_none}
                     ;

        qlf_ident = q:qualif_flags _ i:identifier       { mk_qlf_ident(q, i) };


        unit_fun_defn_hdr = qf:qlf_ident _':'_ a:bracketed _"~>"_ r:expr    { mk_unit_fun_defn_hdr(qf, a, r) };

        unit_fun_defn = h:unit_fun_defn_hdr _';'                    { mk_unit_fun_defn(h, 0) }
                      / h:unit_fun_defn_hdr _'{'_ l:stmt_list _'}'  { mk_unit_fun_defn(h, l) }
                      ;


        unit_defn_list_lr = l:unit_defn_list_lr _ d:unit_defn   { mk_unit_defn_list(l, d) }
                          / d:unit_defn                         { mk_unit_defn_list(0, d) }
                          ;

        unit_defn_list_lr is left-recursive;


        unit_defn = unit_fun_defn
                  / unit_var_defn
                  / unit_val_defn
                  ;


        unit_var_defn = qi:qlf_ident _':'_ tv: expr _';'                { mk_unit_var_defn(qi, tv) }         //- Sic!!!
                      ;


        unit_val_defn = qi:qlf_ident _':'_ t: expr _'='_ v:expr _';'    { mk_unit_val_defn(qi, t, v) }
                      / qi:qlf_ident _'='_ v:expr _';'                  { mk_unit_val_defn(qi, 0, v) }
                      ;


        unit += _ <l:unit_defn_list_lr>     { mk_defn_list_unit(l, $1s) };


        stmt_defn = stmt_var_defn
                  / stmt_val_defn
                  ;


        stmt_var_defn = i:identifier _':'_ tv: expr _';'                { mk_stmt_var_defn(i, tv) }         //- Sic!!!
                 ;


        stmt_val_defn = i:identifier _':'_ t: expr _'='_ v:expr _';'    { mk_stmt_val_defn(i, t, v) }
                 ;


        stmt += stmt_defn;
    }

    v_peg_set_grammar(gr0);
}


//=====================================================================
{   voidc_unit_end_module(); }


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
{
    v_initialize(op_infix_tildeto);
    v_initialize(op_prefix_const);
    v_initialize(op_prefix_volatile);

    op_binary = v_ast_make_operator_binary;
    op_unary  = v_ast_make_operator_unary;

    q = v_quark_from_string;

    op_binary(op_infix_tildeto, q("v.op_infix_tildeto"), 2000, 0, 0);       //- "Lowest" priority, right-assoc

    op_unary(op_prefix_const,    q("v.op_prefix_const"),    20000, 0);      //- "Prefix" priority
    op_unary(op_prefix_volatile, q("v.op_prefix_volatile"), 20000, 0);      //- "Prefix" priority

    v_add_cleaner(voidc_definitions_internal_globals_cleaner, 0);
}


//---------------------------------------------------------------------
{
    v_make_export_symbol("voidc_compile_unit_fun_defn_helper");
    v_make_export_symbol("voidc_internal_constants_module_helper");

    v_make_export_symbol("voidc_definitions_context_get_stmt_list");        //- ???
    v_make_export_symbol("voidc_definitions_context_get_mod_const");        //- ???
    v_make_export_symbol("voidc_definitions_context_get_fun_params");       //- ???

    v_make_export_symbol("voidc_enable_definitions_compiler");
    v_make_export_symbol("voidc_enable_definitions");
}


