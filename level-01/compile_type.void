//---------------------------------------------------------------------
//- Copyright (C) 2020-2024 Dmitry Borodkin <borodkin.dn@gmail.com>
//- SDPX-License-Identifier: LGPL-3.0-or-later
//---------------------------------------------------------------------
{   voidc_guard_target("compile_type.void  must be imported into the voidc target only!");

    v_import("level-00");

    v_import("llvm-c/Core.void");

    v_import("function_hack.void");
    v_import("if_then_else.void");
    v_import("block.void");
    v_import("loop.void");
    v_import("grammar.void");
    v_import("switch.void");
    v_import("memory.void");
    v_import("expression.void");
    v_import("defer.void");
}

{   voidc_enable_statement_if_then_else();
    voidc_enable_statement_block();
    voidc_enable_statement_loop();
    voidc_enable_statement_grammar();
    voidc_enable_statement_switch();
    voidc_enable_expression();
    voidc_enable_statement_defer();
}


//---------------------------------------------------------------------
//- Types dictionary...
//---------------------------------------------------------------------
{   v_add_type("dict_t",   v_util_map_t);               //- Sic !!!
    v_add_type("dict_ptr", v_util_map_ptr);             //- Sic !!!
}


//---------------------------------------------------------------------
//- Context type
//---------------------------------------------------------------------
{
    typ = v_alloca(v_type_ptr, 3);

    typ[0] := unsigned;                 //- Stack length
    typ[1] := LLVMValueRef;             //- The stack...
    typ[2] := dict_t;                   //- Types dictionary

    ctx_t = v_struct_type(typ, 3, false);

    ctx_ref = v_reference_type(ctx_t, 0);

    v_add_type("ctx_t",   ctx_t);
    v_add_type("ctx_ref", ctx_ref);
}

//---------------------------------------------------------------------
{
    int_ = v_type_get_llvm_type(int);

    v_add_constant("stk_length", int, LLVMConstInt(int_, 0, 0));
    v_add_constant("stk_stack",  int, LLVMConstInt(int_, 1, 0));
    v_add_constant("stk_dict",   int, LLVMConstInt(int_, 2, 0));

    llvm_opaque_type = v_type_refptr_get_element_type(LLVMTypeRef);

    v_add_symbol("int_",            llvm_opaque_type, int_);
    v_add_symbol("unsigned_",       llvm_opaque_type, v_type_get_llvm_type(unsigned));
    v_add_symbol("bool_",           llvm_opaque_type, v_type_get_llvm_type(bool));
    v_add_symbol("uint64_t_",       llvm_opaque_type, v_type_get_llvm_type(uint64_t));
    v_add_symbol("v_type_ptr_",     llvm_opaque_type, v_type_get_llvm_type(v_type_ptr));
    v_add_symbol("v_type_ptr_ptr_", llvm_opaque_type, v_type_get_llvm_type(v_pointer_type(v_type_ptr, 0)));
}


//---------------------------------------------------------------------
{   module = LLVMModuleCreateWithName("voidc_compile_type_module");

    v_set_module(module);

    //-----------------------------------------------------------------
    LLVMDisposeMemoryBuffer(voidc_get_unit_buffer());
    voidc_set_unit_buffer(0);
}


//---------------------------------------------------------------------
//- Types dictionary API...
//---------------------------------------------------------------------
{   typ = v_alloca(v_type_ptr, 2);

    typ[0] := dict_ptr;
    typ[1] := v_type_ptr;

    ft = v_function_type(LLVMValueRef, typ, 2, false);

    //-----------------------------------------------------------------
    f = v_function_hack("dict_find", ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "dict", dict_ptr);
    v_add_parameter_name(f, 1, "key",  v_type_ptr);
}
{
    a = v_map_find(dict, v_cast(key, intptr_t));

    if (!a) v_return(0);

    v = v_std_any_get_value(intptr_t, a);

    v_return(v_cast(v, LLVMValueRef));
}

//---------------------------------------------------------------------
{   typ = v_alloca(v_type_ptr, 3);

    typ[0] := dict_ptr;
    typ[1] := v_type_ptr;
    typ[2] := LLVMValueRef;

    ft = v_function_type(void, typ, 3, false);

    //-----------------------------------------------------------------
    f = v_function_hack("dict_insert", ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "dict",  dict_ptr);
    v_add_parameter_name(f, 1, "key",   v_type_ptr);
    v_add_parameter_name(f, 2, "value", LLVMValueRef);
}
{
    a = v_alloca(v_std_any_t);
    v_initialize(a);
    defer v_terminate(a);

    v_std_any_set_value(a, v_cast(value, intptr_t));

    v_map_insert(dict, dict, v_cast(key, intptr_t), a);
}


//---------------------------------------------------------------------
//- Context utility
//---------------------------------------------------------------------
{   typ = v_alloca(v_type_ptr, 2);

    typ[0] := ctx_ref;
    typ[1] := unsigned;

    ft = v_function_type(void, typ, 2, false);

    //-----------------------------------------------------------------
    f = v_function_hack("ctx_stk_push", ft);

    LLVMSetLinkage(f, LLVMPrivateLinkage);

    v_add_parameter_name(f, 0, "ctx", ctx_ref);
    v_add_parameter_name(f, 1, "len", unsigned);
}
{
    if (ctx[stk_length] < len)
    {
        ctx[stk_length] := len;
    }
}


//---------------------------------------------------------------------
{
    typ = *v_alloca(v_type_ptr) := ctx_ref;

    ft = v_function_type(void, &typ, 1, false);

    //-----------------------------------------------------------------
    f = v_function_hack("voidc_compile_type_ctx_initialize", ft);

    v_add_parameter_name(f, 0, "ctx", ctx_ref);
}
{
    ctx[stk_length] := 0;
    ctx[stk_stack]  := 0;

    v_initialize(&ctx[stk_dict]);

    v_make_map(&ctx[stk_dict]);             //- Sic!!!
}

//---------------------------------------------------------------------
{
    typ = *v_alloca(v_type_ptr) := ctx_ref;

    ft = v_function_type(void, &typ, 1, false);

    //-----------------------------------------------------------------
    f = v_function_hack("voidc_compile_type_ctx_terminate", ft);

    v_add_parameter_name(f, 0, "ctx", ctx_ref);
}
{
    v_terminate(&ctx[stk_dict]);
}


//---------------------------------------------------------------------
{
    typ = *v_alloca(v_type_ptr) := ctx_ref;

    ft = v_function_type(int, &typ, 1, false);

    //-----------------------------------------------------------------
    f = v_function_hack("voidc_compile_type_ctx_get_stack_length", ft);

    v_add_parameter_name(f, 0, "ctx", ctx_ref);
}
{
    v_return(ctx[stk_length]);
}

//---------------------------------------------------------------------
{
    typ = v_alloca(v_type_ptr, 2);

    typ[0] := ctx_ref;
    typ[1] := LLVMValueRef;

    ft = v_function_type(void, typ, 2, false);

    //-----------------------------------------------------------------
    f = v_function_hack("voidc_compile_type_ctx_set_stack", ft);

    v_add_parameter_name(f, 0, "ctx", ctx_ref);
    v_add_parameter_name(f, 1, "stk", LLVMValueRef);
}
{
    ctx[stk_stack] := stk;
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
{
    typ = v_alloca(v_type_ptr, 2);

    typ[0] := v_type_ptr;       //- Argument
    typ[1] := ctx_ref;          //- Working context

    ft = v_function_type(LLVMValueRef, typ, 2, false);
    //-----------------------------------------------------------------
    f = v_function_hack("voidc_compile_type", ft);

    v_add_parameter_name(f, 0, "type", v_type_ptr);
    v_add_parameter_name(f, 1, "ctx",  ctx_ref);
}
{
    {   r = dict_find(&ctx[stk_dict], type);

        if (r)  v_return(r);
    }

    fn = *v_alloca(*char);

    k = v_kind(type);

    switch(k)
    {
    case v_type_kind_void:      fn := "v_void_type";        v_break();
    case v_type_kind_f16:       fn := "v_f16_type";         v_break();
    case v_type_kind_f32:       fn := "v_f32_type";         v_break();
    case v_type_kind_f64:       fn := "v_f64_type";         v_break();
    case v_type_kind_f128:      fn := "v_f128_type";        v_break();
    case v_type_kind_int:       fn := "v_int_type";         v_break();
    case v_type_kind_uint:      fn := "v_uint_type";        v_break();
    case v_type_kind_function:  fn := "v_function_type";    v_break();
    case v_type_kind_pointer:   fn := "v_pointer_type";     v_break();
    case v_type_kind_reference: fn := "v_reference_type";   v_break();
    case v_type_kind_struct:    fn := "v_struct_type";      v_break();
    case v_type_kind_array:     fn := "v_array_type";       v_break();
    case v_type_kind_vector:    fn := "v_vector_type";      v_break();
    case v_type_kind_svector:   fn := "v_svector_type";     v_break();
    }

    lltyp = v_alloca(LLVMTypeRef);

    f   = v_obtain_function(fn, lltyp);
    ft_ = v_load(lltyp);

    builder = v_target_get_builder();

    ret = *v_alloca(LLVMValueRef);

    switch(k)
    {
    case v_type_kind_void:
    case v_type_kind_f16:
    case v_type_kind_f32:
    case v_type_kind_f64:
    case v_type_kind_f128:

        ret := LLVMBuildCall2(builder, ft_, f, 0, 0, "");

        v_break();

    case v_type_kind_int:
    case v_type_kind_uint:
        {
            w = v_type_integer_get_width(type);

            val = LLVMConstInt(unsigned_, w, 0);

            ret := LLVMBuildCall2(builder, ft_, f, &val, 1, "");

            v_break();
        }

    case v_type_kind_function:
        {
            val = v_alloca(LLVMValueRef, 4);

            val[0] := voidc_compile_type(v_type_function_get_return_type(type), ctx);

            {   r = dict_find(&ctx[stk_dict], type);

                if (r)  v_return(r);                //- ?!?!?!?!?!?!?!?
            }

            n = v_type_function_get_param_count(type);

            if (n)
            {
                a_t = v_type_function_get_param_types(type);

                a_v = v_malloc(LLVMValueRef, n);
                defer v_free(a_v);

                i = *v_alloca(int) := 0;

                loop
                {
                    if (i == n) v_break();

                    a_v[i] := voidc_compile_type(a_t[i], ctx);

                    ++i;
                }

                {   r = dict_find(&ctx[stk_dict], type);

                    if (r)  v_return(r);                //- ?!?!?!?!?!?!?!?
                }

                val[1] := ctx[stk_stack];

                i := 0;

                loop
                {
                    if (i == n) v_break();

                    i_v = LLVMConstInt(int_, i, 0);

                    val_i_v = LLVMBuildGEP2(builder, v_type_ptr_, val[1], &i_v, 1, "");

                    LLVMBuildStore(builder, a_v[i], val_i_v);

                    ++i;
                }

                ctx_stk_push(ctx, n);
            }
            else
            {
                val[1] := LLVMConstNull(v_type_ptr_ptr_);
            }

            val[2] := LLVMConstInt(int_, n, 0);

            v = v_type_function_is_var_arg(type);

            val[3] := LLVMConstInt(bool_, v, 0);

            ret := LLVMBuildCall2(builder, ft_, f, val, 4, "");

            v_break();
        }

    case v_type_kind_pointer:
    case v_type_kind_reference:
        {
            val = v_alloca(LLVMValueRef, 2);

            val[0] := voidc_compile_type(v_type_refptr_get_element_type(type), ctx);

            {   r = dict_find(&ctx[stk_dict], type);

                if (r)  v_return(r);
            }

            val[1] := LLVMConstInt(unsigned_, v_type_refptr_get_address_space(type), 0);

            ret := LLVMBuildCall2(builder, ft_, f, val, 2, "");

            v_break();
        }

    case v_type_kind_struct:
        {
            name = v_type_struct_get_name(type);

            if (name)
            {
                name_v = LLVMBuildGlobalStringPtr(builder, name, "");

                struct_type_named_f   = v_obtain_function("v_struct_type_named", lltyp);
                struct_type_named_ft_ = v_load(lltyp);

                ret := LLVMBuildCall2(builder, struct_type_named_ft_, struct_type_named_f, &name_v, 1, "");

                dict_insert(&ctx[stk_dict], type, ret);     //- Sic!
            }

            elts_v   = *v_alloca(LLVMValueRef);
            count_v  = *v_alloca(LLVMValueRef);
            packed_v = *v_alloca(LLVMValueRef);

            has_body = !v_type_struct_is_opaque(type);

            if (has_body)
            {
                n = v_type_struct_get_element_count(type);

                if (n)
                {
                    a_t = v_type_struct_get_element_types(type);

                    a_v = v_malloc(LLVMValueRef, n);
                    defer v_free(a_v);

                    i = *v_alloca(int) := 0;

                    loop
                    {
                        if (i == n) v_break();

                        a_v[i] := voidc_compile_type(a_t[i], ctx);

                        ++i;
                    }

                    elts_v := ctx[stk_stack];

                    i := 0;

                    loop
                    {
                        if (i == n) v_break();

                        i_v = LLVMConstInt(int_, i, 0);

                        elt_i_v = LLVMBuildGEP2(builder, v_type_ptr_, elts_v, &i_v, 1, "");

                        LLVMBuildStore(builder, a_v[i], elt_i_v);

                        ++i;
                    }

                    ctx_stk_push(ctx, n);
                }
                else
                {
                    elts_v := LLVMConstNull(v_type_ptr_ptr_);
                }

                count_v := LLVMConstInt(unsigned_, n, 0);

                p = v_type_struct_is_packed(type);

                packed_v := LLVMConstInt(bool_, p, 0);
            }

            if (name)
            {
                if (has_body)
                {
                    val = v_alloca(LLVMValueRef, 4);

                    val[0] := ret;
                    val[1] := elts_v;
                    val[2] := count_v;
                    val[3] := packed_v;

                    set_body_f   = v_obtain_function("v_type_struct_set_body", lltyp);
                    set_body_ft_ = v_load(lltyp);

                    LLVMBuildCall2(builder, set_body_ft_, set_body_f, val, 4, "");
                }

                v_return(ret);      //- Sic!
            }
            else
            {
                //- assert(has_body);

                val = v_alloca(LLVMValueRef, 3);

                val[0] := elts_v;
                val[1] := count_v;
                val[2] := packed_v;

                ret := LLVMBuildCall2(builder, ft_, f, val, 3, "");
            }

            v_break();
        }

    case v_type_kind_array:
        {
            val = v_alloca(LLVMValueRef, 2);

            val[0] := voidc_compile_type(v_type_array_get_element_type(type), ctx);

            {   r = dict_find(&ctx[stk_dict], type);

                if (r)  v_return(r);
            }

            val[1] := LLVMConstInt(uint64_t_, v_type_array_get_length(type), 0);

            ret := LLVMBuildCall2(builder, ft_, f, val, 2, "");

            v_break();
        }

    case v_type_kind_vector:
    case v_type_kind_svector:
        {
            val = v_alloca(LLVMValueRef, 2);

            val[0] := voidc_compile_type(v_type_vector_get_element_type(type), ctx);

            {   r = dict_find(&ctx[stk_dict], type);

                if (r)  v_return(r);
            }

            val[1] := LLVMConstInt(unsigned_, v_type_vector_get_size(type), 0);

            ret := LLVMBuildCall2(builder, ft_, f, val, 2, "");

            v_break();
        }
    }

    dict_insert(&ctx[stk_dict], type, ret);

    v_return(ret);
}


//---------------------------------------------------------------------
//- ...
//---------------------------------------------------------------------
{
    module = v_get_module();

    //-----------------------------------------------------------------
//  v_debug_print_module(1);

    voidc_unit_load_module_to_jit(module, true);

    LLVMDisposeModule(module);
    v_set_module(0);
}


//---------------------------------------------------------------------
{
    v_export_type("voidc_compile_type_ctx_t", ctx_t);

    v_make_export_symbol("voidc_compile_type_ctx_initialize");
    v_make_export_symbol("voidc_compile_type_ctx_terminate");
    v_make_export_symbol("voidc_compile_type_ctx_get_stack_length");
    v_make_export_symbol("voidc_compile_type_ctx_set_stack");

    v_make_export_symbol("voidc_compile_type");
}


